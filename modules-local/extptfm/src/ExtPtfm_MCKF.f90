!**********************************************************************************************************************************
!> ## ExtPtfm_MCKF
!! The ExtPtfm_MCKF and ExtPtfm_MCKF_Types modules make up a template for creating user-defined calculations in the FAST Modularization
!! Framework. ExtPtfm_MCKF_Types will be auto-generated by the FAST registry program, based on the variables specified in the
!! ExtPtfm_MCKF_Registry.txt file.
!!
!! This template file contains comments in the style required for Doxygen, and it contains methods for handling errors.
!!
!! "ExtPtfm_MCKF" should be replaced with the name of your module. Example: ElastoDyn \n
!! "ExtPtfm" (in ExtPtfm_*) should be replaced with the module name or an abbreviation of it. Example: ED
! ..................................................................................................................................
!! ## LICENSING
!! Copyright (C) 2012-2013, 2015-2016  National Renewable Energy Laboratory
!!
!!    This file is part of ExtPtfm_MCKF.
!!
!! Licensed under the Apache License, Version 2.0 (the "License");
!! you may not use this file except in compliance with the License.
!! You may obtain a copy of the License at
!!
!!     http://www.apache.org/licenses/LICENSE-2.0
!!
!! Unless required by applicable law or agreed to in writing, software
!! distributed under the License is distributed on an "AS IS" BASIS,
!! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!! See the License for the specific language governing permissions and
!! limitations under the License.
!**********************************************************************************************************************************
MODULE ExtPtfm_MCKF

   USE ExtPtfm_MCKF_Types
   USE NWTC_Library

   IMPLICIT NONE

   PRIVATE

   TYPE(ProgDesc), PARAMETER :: ExtPtfm_Ver = ProgDesc( 'ExtPtfm_MCKF', '', '' ) !< module date/version information

   ! ..... Public Subroutines ...................................................................................................
   PUBLIC :: ExtPtfm_Init                           !  Initialization routine
   PUBLIC :: ExtPtfm_End                            !  Ending routine (includes clean up)
   PUBLIC :: ExtPtfm_UpdateStates                   !  Loose coupling routine for solving for constraint states, integrating
                                                    !    continuous states, and updating discrete states
   PUBLIC :: ExtPtfm_CalcOutput                     !  Routine for computing outputs
   PUBLIC :: ExtPtfm_CalcConstrStateResidual        !  Tight coupling routine for returning the constraint state residual
   PUBLIC :: ExtPtfm_CalcContStateDeriv             !  Tight coupling routine for computing derivatives of continuous states
   PUBLIC :: ExtPtfm_UpdateDiscState                !  Tight coupling routine for updating discrete states
   PUBLIC :: ExtPtfm_JacobianPInput                 !  Routine to compute the Jacobians of the output (Y), continuous- (X), discrete-
                                                    !    (Xd), and constraint-state (Z) functions all with respect to the inputs (u)
   PUBLIC :: ExtPtfm_JacobianPContState             !  Routine to compute the Jacobians of the output (Y), continuous- (X), discrete-
                                                    !    (Xd), and constraint-state (Z) functions all with respect to the continuous
                                                    !    states (x)
   PUBLIC :: ExtPtfm_JacobianPDiscState             !  Routine to compute the Jacobians of the output (Y), continuous- (X), discrete-
                                                    !    (Xd), and constraint-state (Z) functions all with respect to the discrete
                                                    !    states (xd)
   PUBLIC :: ExtPtfm_JacobianPConstrState           !  Routine to compute the Jacobians of the output (Y), continuous- (X), discrete-
                                                    !    (Xd), and constraint-state (Z) functions all with respect to the constraint
                                                    !    states (z)
   PUBLIC :: ExtPtfm_GetOP                          !  Routine to get the operating-point values for linearization (from data structures to arrays)



! ---------------------------------------------------------------------------------------------------
! Variables for output channels
   INTEGER(IntKi), PARAMETER      :: OutStrLenM1 = ChanLen - 1
   INTEGER(IntKi), PARAMETER      :: ID_Time     = 0
   INTEGER(IntKi), PARAMETER      :: ID_PtfFx    = 1
   INTEGER(IntKi), PARAMETER      :: ID_PtfFy    = 2
   INTEGER(IntKi), PARAMETER      :: ID_PtfFz    = 3
   INTEGER(IntKi), PARAMETER      :: ID_PtfMx    = 4
   INTEGER(IntKi), PARAMETER      :: ID_PtfMy    = 5
   INTEGER(IntKi), PARAMETER      :: ID_PtfMz    = 6
   INTEGER(IntKi), PARAMETER      :: ID_WaveElev = 7
   INTEGER(IntKi), PARAMETER      :: ID_QStart   = 8
! ---------------------------------------------------------------------------------------------------

CONTAINS
   
!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!> Helper functions for the module

!> This routine sets the error status and error message for a routine, it's a simplified version of SetErrStat from NWTC_Library
subroutine SetErrStatSimple(ErrStat, ErrMess, RoutineName)
  INTEGER(IntKi), INTENT(INOUT)  :: ErrStat      ! Error status of the operation
  CHARACTER(*),   INTENT(INOUT)  :: ErrMess      ! Error message if ErrStat /= ErrID_None
  CHARACTER(*),   INTENT(IN   )  :: RoutineName  ! Name of the routine error occurred in
  if (ErrStat /= ErrID_None) then
     ErrMess = TRIM(RoutineName)//':'//TRIM(ErrMess)
  end if
end subroutine SetErrStatSimple

subroutine disp2r8(u,varname,a)
    integer,intent(in) ::u
    character(len=*),intent(in)::varname
    real(ReKi),intent(in),dimension(:,:) ::a
    integer :: n, m,i
    character(len=20) :: fmt
    character(len=*),parameter :: RFMT='EN13.3E2'
    n=size(a,1)
    m=size(a,2)
    if (n>0 .and. m>0) then
        write(u,"(A,A)") varname,"=["
        write(fmt,*) m
        do i=1,n-1
            write(u,"("//adjustl(fmt)//RFMT//")") a(i,:)
        enddo
        i=n
        write(u,"("//trim(fmt)//RFMT//",A)") a(i,:), "  ];"
    else
        write(u,'(A,A)') varname,'=[];'
    endif
end subroutine

!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!> This routine is called at the start of the simulation to perform initialization steps.
!! The parameters are set here and not changed during the simulation.
!! The initial states and initial guess for the input are defined.
SUBROUTINE ExtPtfm_Init( InitInp, u, p, x, xd, z, OtherState, y, m, Interval, InitOut, ErrStat, ErrMsg )
!..................................................................................................................................
   TYPE(ExtPtfm_InitInputType),       INTENT(IN   )  :: InitInp     !< Input data for initialization routine
   TYPE(ExtPtfm_InputType),           INTENT(  OUT)  :: u           !< An initial guess for the input; input mesh must be defined
   TYPE(ExtPtfm_ParameterType),       INTENT(  OUT)  :: p           !< Parameters
   TYPE(ExtPtfm_ContinuousStateType), INTENT(  OUT)  :: x           !< Initial continuous states
   TYPE(ExtPtfm_DiscreteStateType),   INTENT(  OUT)  :: xd          !< Initial discrete states
   TYPE(ExtPtfm_ConstraintStateType), INTENT(  OUT)  :: z           !< Initial guess of the constraint states
   TYPE(ExtPtfm_OtherStateType),      INTENT(  OUT)  :: OtherState  !< Initial other states (logical, etc)
   TYPE(ExtPtfm_OutputType),          INTENT(  OUT)  :: y           !< Initial system outputs (outputs are not calculated;
                                                                    !!   only the output mesh is initialized)
   TYPE(ExtPtfm_MiscVarType),         INTENT(  OUT)  :: m           !< Misc variables for optimization (not copied in glue code)
   REAL(DbKi),                        INTENT(INOUT)  :: Interval    !< Coupling interval in seconds: the rate that
                                                                    !!   (1) ExtPtfm_UpdateStates() is called in loose coupling &
                                                                    !!   (2) ExtPtfm_UpdateDiscState() is called in tight coupling.
                                                                    !!   Input is the suggested time from the glue code;
                                                                    !!   Output is the actual coupling interval that will be used
                                                                    !!   by the glue code.
   TYPE(ExtPtfm_InitOutputType),      INTENT(  OUT)  :: InitOut     !< Output for initialization routine
   INTEGER(IntKi),                    INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                      INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None
   ! local variables
   INTEGER(IntKi)                                    :: I           ! Loop counter
   INTEGER(IntKi)                                    :: NumOuts     ! Number of outputs; would probably be in the parameter type
   CHARACTER(ChanLen), dimension(:), allocatable     :: OutList(:)   !< The list out user-requested outputs
   ! Initialize variables
   ErrStat = ErrID_None
   ErrMsg  = ""

   ! Initialize the NWTC Subroutine Library
   call NWTC_Init( )
   ! Display the module information
   call DispNVD( ExtPtfm_Ver )
   ! set parameters
   p%NumOuts   = 0
   p%nTot      = -1
   p%nCB       = -1
   p%IntMethod = 1     ! TODO, default, get it from glue code
   p%EP_DeltaT = 0.001
   print*,'>> DT Glue code',InitInp%DT
   call ReadPrimaryFile(InitInp%InputFile, p, ErrStat, ErrMsg); if(Failed()) return
   write(*,*)'Total number of DOF :',p%nTot
   write(*,*)'Number of CB modes  :',p%nCB
   write(*,*)'Number of time steps:',p%nPtfmFt

   ! Set the constant state matrices A,B,C,D
   call SetStateMatrices(p, ErrStat, ErrMsg)
  
   ! Allocate and init continuous states
   call AllocAry( x%qm    , p%nCB,'CB DOF positions' , ErrStat,ErrMsg); if(Failed()) return
   call AllocAry( x%qmdot , p%nCB,'CB DOF velocities', ErrStat,ErrMsg); if(Failed()) return
   do I=1,p%nCB; x%qm   (I)=0; end do
   do I=1,p%nCB; x%qmdot(I)=0; end do
   ! Other states
   xd%DummyDiscState          = 0.0_ReKi
   z%DummyConstrState         = 0.0_ReKi
   ! allocate OtherState%xdot if using multi-step method; initialize n
   if ( ( p%IntMethod .eq. 2) .OR. ( p%IntMethod .eq. 3)) THEN
       allocate( OtherState%xdot(4), STAT=ErrStat )
       ErrMsg='Error allocating OtherState%xdot'
       if(Failed()) return
   endif

   ! Initialize Misc Variables:
   m%Indx = 1 ! used to optimize interpolation of loads in time
   call AllocAry( m%PtfmFt, p%nTot,'Loads at t', ErrStat,ErrMsg); if(Failed()) return
   do I=1,p%nTot; m%PtfmFt(I)=0; end do
   call AllocAry( m%xFlat, 2*p%nCB,'xFlat', ErrStat,ErrMsg); if(Failed()) return
   do I=1,2*p%nCB; m%xFlat(I)=0; end do
   do I=1,18; m%uFlat(I)=0; end do
   
   ! Define initial guess (set up mesh first) for the system inputs here:
   call Init_meshes(u, y, ErrStat, ErrMsg); if(Failed()) return

   ! --- Outputs
   CALL AllocAry( m%AllOuts, ID_QStart+3*p%nCB-1, "ExtPtfm AllOut", ErrStat,ErrMsg ); if(Failed()) return
   m%AllOuts(1:ID_QStart+3*p%nCB-1) = 0.0
   ! TODO OutList from InputFile
   allocate(OutList(6))
   OutList( 1) = 'PtfmFx'
   OutList( 2) = 'PtfmFy'
   OutList( 3) = 'PtfmFz'
   OutList( 4) = 'PtfmMx'
   OutList( 5) = 'PtfmMy'
   OutList( 6) = 'PtfmMz'
!    OutList( 7) = 'CBQ_001'
!    OutList( 8) = 'CBQ_002'
!    OutList( 9) = 'CBQD_001'
!    OutList(10) = 'CBF_001'
!    OutList(11) = 'WavElev'
!    OutList(12) = 'CBF_004'
   ! Setting p%OutParam from OutList
   call SetOutParam(OutList, p, ErrStat, ErrMsg); if(Failed()) return

   call AllocAry( y%WriteOutput,        p%NumOuts,'WriteOutput',   ErrStat,ErrMsg); if(Failed()) return
   call AllocAry(InitOut%WriteOutputHdr,p%NumOuts,'WriteOutputHdr',ErrStat,ErrMsg); if(Failed()) return
   call AllocAry(InitOut%WriteOutputUnt,p%NumOuts,'WriteOutputUnt',ErrStat,ErrMsg); if(Failed()) return
   InitOut%WriteOutputHdr(1:p%NumOuts) = p%OutParam(1:p%NumOuts)%Name
   InitOut%WriteOutputUnt(1:p%NumOuts) = p%OutParam(1:p%NumOuts)%Units     
   InitOut%Ver = ExtPtfm_Ver
      
   if (InitInp%Linearize) then
      CALL SetErrStat( ErrID_Fatal, 'ExtPtfm_MCKF linearization analysis TODO.', ErrStat, ErrMsg, 'ExtPtfm_Init')
      !Appropriate Jacobian row/column names and rotating-frame flags here:   
      CALL AllocAry(InitOut%LinNames_y, 6      , 'LinNames_y', ErrStat, ErrMsg); if(Failed()) return
      CALL AllocAry(InitOut%RotFrame_y, 6      , 'RotFrame_y', ErrStat, ErrMsg); if(Failed()) return
      CALL AllocAry(InitOut%LinNames_x, 2*p%nCB, 'LinNames_x', ErrStat, ErrMsg); if(Failed()) return
      CALL AllocAry(InitOut%RotFrame_x, 2*p%nCB, 'RotFrame_x', ErrStat, ErrMsg); if(Failed()) return
      CALL AllocAry(InitOut%LinNames_u, 18     , 'LinNames_u', ErrStat, ErrMsg); if(Failed()) return
      CALL AllocAry(InitOut%RotFrame_u, 18     , 'RotFrame_u', ErrStat, ErrMsg); if(Failed()) return
      CALL AllocAry(InitOut%IsLoad_u  , 18     , 'IsLoad_u'  , ErrStat, ErrMsg); if(Failed()) return
      !do I=1,6;     InitOut%LinNames_y(I) = 'ExtPtm_Y'//trim(Num2LStr(I)); enddo
      !do I=1,18;    InitOut%LinNames_u(I) = 'ExtPtm_U'//trim(Num2LStr(I)); enddo
      !do I=1,p%nCB; 
      !    InitOut%LinNames_x(I)       = 'ExtPtm_X'//trim(Num2LStr(I));
      !    InitOut%LinNames_x(I+p%nCB) = 'ExtPtm_XP'//trim(Num2LStr(I));
      !enddo
      InitOut%RotFrame_x = .false. ! note that meshes are in the global, not rotating frame
      InitOut%RotFrame_y = .false. ! note that meshes are in the global, not rotating frame
      InitOut%RotFrame_u = .false. ! note that meshes are in the global, not rotating frame
      InitOut%IsLoad_u   = .false. ! the inputs are not loads but kinematics
!          CALL AllocAry(InitOutData%LinNames_u, InitInp%NumWindPoints*3 + 3, 'LinNames_u', TmpErrStat, TmpErrMsg)
!          CALL AllocAry(InitOutData%RotFrame_u, InitInp%NumWindPoints*3 + 3, 'RotFrame_u', TmpErrStat, TmpErrMsg)
!          CALL AllocAry(InitOutData%IsLoad_u  , InitInp%NumWindPoints*3 + 3, 'IsLoad_u', TmpErrStat, TmpErrMsg)
!          CALL AllocAry(InitOutData%RotFrame_y, InitInp%NumWindPoints*3 +p%NumOuts, 'RotFrame_y', TmpErrStat, TmpErrMsg)
!          do i=1,InitInp%NumWindPoints
!             do j=1,3
!                InitOutData%LinNames_y((i-1)*3+j) = UVW(j)//'-component inflow velocity at node '//trim(num2lstr(i))//', m/s'
!                InitOutData%LinNames_u((i-1)*3+j) = XYZ(j)//'-component position of node '//trim(num2lstr(i))//', m'
!             end do            
!          end do
!          InitOutData%LinNames_u(InitInp%NumWindPoints*3 + 1) = 'Extended input: horizontal wind speed (steady/uniform wind), m/s'
!          InitOutData%LinNames_u(InitInp%NumWindPoints*3 + 2) = 'Extended input: vertical power-law shear exponent, -'
!          InitOutData%LinNames_u(InitInp%NumWindPoints*3 + 3) = 'Extended input: propagation direction, rad'         
!          do i=1,p%NumOuts
!             InitOutData%LinNames_y(i+3*InitInp%NumWindPoints) = trim(p%OutParam(i)%Name)//', '//p%OutParam(i)%Units
!          end do
   end if
CONTAINS
    logical function Failed()
        CALL SetErrStatSimple(ErrStat, ErrMsg, 'ExtPtfm_Init')
        Failed =  ErrStat >= AbortErrLev
    end function Failed
END SUBROUTINE ExtPtfm_Init

SUBROUTINE SetOutParam(OutList, p, ErrStat, ErrMsg )
! This routine checks to see if any requested output channel names (stored in the OutList(:)) are invalid. It returns a 
! warning if any of the channels are not available outputs from the module.
!  It assigns the settings for OutParam(:) (i.e, the index, name, and units of the output channels, WriteOutput(:)).
!  the sign is set to 0 if the channel is invalid.
! It sets assumes the value p%NumOuts has been set before this routine has been called, and it sets the values of p%OutParam here.
!..................................................................................................................................
   CHARACTER(ChanLen),           INTENT(IN)     :: OutList(:)         !< The list out user-requested outputs
   TYPE(ExtPtfm_ParameterType),  INTENT(INOUT)  :: p                  !< The module parameters
   INTEGER(IntKi),               INTENT(OUT)    :: ErrStat            !< The error status code
   CHARACTER(*),                 INTENT(OUT)    :: ErrMsg             !< The error message, if an error occurred
   ! Local variables
   INTEGER                      :: ErrStat2                                        ! temporary (local) error status
   INTEGER                      :: I                                               ! Generic loop-counting index
   INTEGER                      :: INDX                                            ! Index for valid arrays
   CHARACTER(ChanLen)           :: OutListTmp                                      ! A string to temporarily hold OutList(I)
   CHARACTER(*), PARAMETER      :: RoutineName = "SetOutParam"

   CHARACTER(OutStrLenM1), PARAMETER  :: ValidParamAry(7) =  (/ & ! This lists the names of the allowed parameters, which must be sorted alphabetically
                               "PTFMFX   ","PTFMFY   ","PTFMFZ   ","PTFMMX   ","PTFMMY   ","PTFMMZ   ","WAVELEV  "/) 
   CHARACTER(OutStrLenM1), PARAMETER :: ParamUnitsAry(7) =  (/ &                     ! This lists the units corresponding to the allowed parameters
                               "(N)      ","(N)      ","(N)      ","(Nm)     ","(Nm)     ","(Nm)     ","(m)      "/)
   INTEGER(IntKi), PARAMETER :: ParamIndxAry(7) =  (/ &                            ! This lists the index into AllOuts(:) of the allowed parameters ValidParamAry(:)
                              ID_PtfFx, ID_PtfFy, ID_PtfFz, ID_PtfMx, ID_PtfMy, ID_PtfMz, ID_WaveElev /)
   
   p%NumOuts = size(OutList,1)
   allocate(p%OutParam(0:p%NumOuts) , stat=ErrStat )
   if ( ErrStat /= 0_IntKi )  THEN
      CALL SetErrStat(ErrID_Fatal,"Error allocating memory for the InflowWind OutParam array.", ErrStat, ErrMsg, RoutineName)
      return
   endif

   ! Set index, name, and units for the time output channel:
   p%OutParam(0)%Indx  = 0
   p%OutParam(0)%Name  = "Time"    ! OutParam(0) is the time channel by default.
   p%OutParam(0)%Units = "(s)"
   p%OutParam(0)%SignM = 1

  ! Set index, name, and units for all of the output channels.
   do I = 1,p%NumOuts
      p%OutParam(I)%Name  = OutList(I)
      OutListTmp          = OutList(I)
      p%OutParam(I)%Indx   = 0
      p%OutParam(I)%Units  = "(NA)"
      CALL Conv2UC( OutListTmp )  ! Convert OutListTmp to upper case
      ! Reverse the sign of the channel if the prefix is "-", "_" or "M"
      if  ( index( "-_M", OutListTmp(1:1) ) > 0 ) then
         p%OutParam(I)%SignM = -1 
         OutListTmp          = OutListTmp(2:)
      else
         p%OutParam(I)%SignM = 1
      end if
      ! Find the index of the channel in the AllOut list
      Indx = IndexCharAry( OutListTmp(1:OutStrLenM1), ValidParamAry )
      if (Indx>0) then
          p%OutParam(I)%Indx  = ParamIndxAry(Indx)
          p%OutParam(I)%Units = ParamUnitsAry(Indx)
      else if (index(OutListTmp,'CBQ_') > 0 ) then
          call setDOFChannel(5,ID_QStart+0*p%nCB-1)
      else if (index(OutListTmp,'CBQD_') > 0 ) then
          call setDOFChannel(6,ID_QStart+1*p%nCB-1)
      else if (index(OutListTmp,'CBF_') > 0 ) then
          call setDOFChannel(5,ID_QStart+2*p%nCB-1)
      else
          call setInvalidChannel() ! INVALID
      endif
      write(*,*) p%OutParam(I)%Name, p%OutParam(I)%Indx, p%OutParam(I)%Units
   end do
   return
contains
    logical function Failed()
        CALL SetErrStatSimple(ErrStat, ErrMsg, 'ExtPtfm_SetOutParam')
        Failed =  ErrStat >= AbortErrLev
    end function Failed
    subroutine setDOFChannel(nCharBefore,nOffset)
        !> Sets channel when the channel name has the form "YYYY_XXX" where XXX is a DOF number
        integer, intent(in) :: nCharBefore !< Number of characters to ignore in OutListTmp
        integer, intent(in) :: nOffset     !< Index offset to add to iDOF
        integer             :: idof ! index of CB DOF extracted from 
        iDOF = ReadIntFromStr(OutListTmp(nCharBefore:), 'Output channel '//trim(OutList(I)), ErrStat, ErrMsg); if(Failed()) return
        if ((iDOF> p%nCB) .or. (iDOF<1)) then
            call setInvalidChannel() ! INVALID
        else
            p%OutParam(I)%Indx  = nOffset+iDOF
            p%OutParam(I)%Units = '(NA)'
        endif
    end subroutine
    subroutine setInvalidChannel()
        ! If a selected output channel is not available by this module set ErrStat = ErrID_Warn.
        p%OutParam(I)%Units = "INVALID"
        p%OutParam(I)%Indx = 0
        call SetErrStat(ErrID_Warn, TRIM(p%OutParam(I)%Name)//" is not an available output channel.",ErrStat,ErrMsg,'ExtPtfm_SetOutParam')
        write(*,*)TRIM(p%OutParam(I)%Name)//" is not an available output channel."
    end subroutine
END SUBROUTINE SetOutParam
!----------------------------------------------------------------------------------------------------------------------------------
!..................................................................................................................................
!> This routine checks to see if any requested output channel names are to be output in linearization analysis.
!! note that we output all WriteOutput values and assume that none of them depend on inputs (so I don't need this mapping any more)
SUBROUTINE SetOutParamLin( p, ErrStat, ErrMsg )
   ! Passed variables
   TYPE(ExtPtfm_ParameterType),  INTENT(INOUT)  :: p                  !< The module parameters
   INTEGER(IntKi),               INTENT(OUT)    :: ErrStat            !< The error status code
   CHARACTER(*),                 INTENT(OUT)    :: ErrMsg             !< The error message, if an error occurred
   ! Local variables
   INTEGER                   :: ErrStat2                                        ! temporary (local) error status
   INTEGER                   :: I                                               ! Generic loop-counting index
   INTEGER                   :: J                                               ! Generic loop-counting index
   CHARACTER(ErrMsgLen)      :: ErrMsg2
   CHARACTER(*), PARAMETER   :: RoutineName = "SetOutParamLin"
   ErrStat = ErrID_None
   ErrMsg  = ""
!    call AllocAry(p%OutParamLinIndx, 2, p%NumOuts, 'OutParamLinIndx', ErrStat2, ErrMsg2)
!    call setErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
!    if (ErrStat >= AbortErrLev) return
   !do i = 1,p%NumOuts
   !   if (p%OutParam(i)%SignM /= 0 ) then
   !      do j=1,size(WindVelX)
   !         if ( p%OutParam(i)%Indx == WindVelX(j) ) then
   !            p%OutParamLinIndx(1,i) = j
   !            p%OutParamLinIndx(2,i) = 1
   !            exit !exit j loop; move to next parameter
   !         elseif ( p%OutParam(i)%Indx == WindVelY(j) ) then
   !            p%OutParamLinIndx(1,i) = j
   !            p%OutParamLinIndx(2,i) = 2
   !            exit !exit j loop; move to next parameter
   !         elseif ( p%OutParam(i)%Indx == WindVelZ(j) ) then
   !            p%OutParamLinIndx(1,i) = j
   !            p%OutParamLinIndx(2,i) = 3
   !            exit !exit j loop; move to next parameter
   !         end if
   !      end do
   !      
   !   end if      
   !end do
END SUBROUTINE SetOutParamLin


!----------------------------------------------------------------------------------------------------------------------------------
!> Helper functions to read primary file
real(ReKi) function ReadFloatFromStr(s, VarName, iStat, Msg ) result(myfloat)
   character(len=*), intent(in)    :: s
   character(len=*), intent(in)    :: VarName
   character(len=*), intent(inout) :: Msg
   integer, intent(out)            :: iStat
   read(s,*, iostat=iStat ) myfloat 
   if (iStat /= 0) then
      iStat=ErrID_Fatal
      Msg = trim(Msg)//'Error extracting float while reading '//VarName
   endif
end function ReadFloatFromStr
integer function ReadIntFromStr(s, VarName, iStat, Msg ) result(myint)
   character(len=*), intent(in)    :: s
   character(len=*), intent(in)    :: VarName
   character(len=*), intent(inout) :: Msg
   integer, intent(out)            :: iStat
   read(s,*, iostat=iStat ) myint 
   if (iStat /= 0) then
      iStat=ErrID_Fatal
      Msg = trim(Msg)//'Error extracting integer while reading '//VarName
   endif
end function ReadIntFromStr
subroutine ReadRealMatrix(fid, FileName, Mat, VarName, nLines,nRows, iStat, Msg, iLine )
   integer, intent(in)                     :: fid
   real(ReKi), dimension(:,:), allocatable :: Mat
   character(len=*), intent(in)            :: FileName
   character(len=*), intent(in)            :: VarName
   integer, intent(in)                     :: nLines
   integer, intent(in)                     :: nRows
   integer, intent(out)                    :: iStat
   integer, intent(inout)                  :: iLine
   character(len=*), intent(inout)         :: Msg
   ! local variables
   integer :: i
   call allocAry( Mat, nLines, nRows, VarName,  iStat, Msg); 
   if (iStat /= 0) return
   !Read Stiffness
   DO I =1,nLines
      iLine=iLine+1
      ! TODO use ReadCAryFromStr when available in the NWTCIO, it performs more checks
      CALL ReadAry( fid, FileName, Mat(I,:), nRows, trim(VarName)//' Line '//Num2LStr(iLine), VarName, iStat, Msg)
      if (iStat /= 0) return
   ENDDO
end subroutine
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE ReadPrimaryFile( InputFile, p, ErrStat, ErrMsg )
!..................................................................................................................................
   ! Passed variables
   CHARACTER(*),                INTENT(IN)    :: InputFile                           !< Name of the file containing the primary input data
   TYPE(ExtPtfm_ParameterType), INTENT(INOUT) :: p                                   !< All the parameter matrices stored in this input file
   INTEGER(IntKi),              INTENT(OUT)   :: ErrStat                             !< Error status                              
   CHARACTER(*),                INTENT(OUT)   :: ErrMsg                              !< Error message
   ! Local variables:
   REAL(ReKi), dimension(:),allocatable :: TmpAry                                 ! temporary array for reading row from file
   INTEGER(IntKi)                       :: I                                         ! loop counter
   INTEGER(IntKi)                       :: UnIn                                      ! Unit number for reading file
   INTEGER(IntKi)                       :: iLine                                     ! Current position in file
   CHARACTER(200)                       :: Line                                      ! Temporary storage of a line from the input file (to compare with "default")
   CHARACTER(200)                       :: Line2                                     ! Temporary storage of a line from the input file (to compare with "default")
   ! Initialize some variables:
   !CALL GetPath( InputFile, PriPath )     ! Input files will be relative to the path where the primary input file is located.
   
   ! Get an available unit number for the file.
   CALL GetNewUnit( UnIn, ErrStat, ErrMsg );               if(Failed()) return
   ! Open the Primary input file.
   CALL OpenFInpFile ( UnIn, InputFile, ErrStat, ErrMsg ); if(Failed()) return
   iLine=1
   !-------------------------- Read the first two lines
   CALL ReadStr( UnIn, InputFile, Line, 'Line'//Num2LStr(iLine), 'External Platform MCKF file', ErrStat, ErrMsg)
   if(Failed()) return
   iLine=iLine+1
   CALL ReadStr( UnIn, InputFile, Line2, 'Line'//Num2LStr(iLine), 'External Platform MCKF file', ErrStat, ErrMsg)
   if(Failed()) return
   iLine=iLine+1
   call CONV2UC(Line)
   call CONV2UC(Line2)
   call cleanup()
   !-------------------------- Detecting file format
   if (index(Line2,'#MASS')==1) then
       write(*,*) 'File detected as Guyan ASCII file format: '//trim(InputFile)
       call ReadGuyanASCII()
   else if (index(Line2,'FLEX 5 FORMAT')>=1) then
       write(*,*) 'File detected as FLEX ASCII file format: '//trim(InputFile)
       call ReadFlexASCII()
   endif

   ! Checking that everyting was correctly read and set
   call CheckAllInputsRead()
   if(Failed()) return
   
   return

CONTAINS
    !> 
    logical function Failed()
        CALL SetErrStatSimple( ErrStat, ErrMsg, 'ExtPtfm_ReadPrimaryFile' )
        Failed =  ErrStat >= AbortErrLev
        if(Failed) call cleanup()
    end function Failed
    
    !> 
    subroutine cleanup()
        close( UnIn )
        if (allocated(TmpAry)) deallocate(TmpAry)
    end subroutine cleanup
    
    !> Checks that all inputs were correctly read
    subroutine CheckAllInputsRead()
        if (ErrStat/=0) return
        if (p%nTot<0)                   then ; ErrStat=ErrID_Fatal; ErrMsg='The total number of DOF was not set'; endif
        if (.not.allocated(p%PtfmAM))   then ; ErrStat=ErrID_Fatal; ErrMsg='The mass matrix was not allocated.' ; endif
        if (.not.allocated(p%Stff))     then ; ErrStat=ErrID_Fatal; ErrMsg='The stiffness matrix was not allocated.' ; endif
        if (.not.allocated(p%Damp))     then ; ErrStat=ErrID_Fatal; ErrMsg='The damping matrix was not allocated.' ; endif
        if (.not.allocated(p%PtfmFt))   then ; ErrStat=ErrID_Fatal; ErrMsg='The loads were not allocated.';endif
        if (.not.allocated(p%PtfmFt_t)) then ; ErrStat=ErrID_Fatal; ErrMsg='The time vector was not allocated.'; endif
    end subroutine CheckAllInputsRead

   !> Reads a FLEX ASCII file for Guyan or CraigBampton reductions
   SUBROUTINE ReadFlexASCII()
       REAL(ReKi) :: dt !< time step
       REAL(ReKi) :: T  !< total simulation time

       T=-1
       dt=-1
       ! Get an available unit number for the file.
       CALL GetNewUnit( UnIn, ErrStat, ErrMsg );               if ( ErrStat /= 0 ) return
       ! Open the Primary input file.
       CALL OpenFInpFile ( UnIn, InputFile, ErrStat, ErrMsg ); if ( ErrStat /= 0 ) return

       ! --- Reading file line by line
       ErrStat=0
       iLine=0
       do while (ErrStat==0)
           iLine=iLine+1
           read(UnIn,'(A)', iostat=ErrStat) Line
           if (ErrStat/=0) then
               if (ErrStat < 0) then
                   ErrStat=0 ! End of file is fine
               else
                   ErrMsg='Error while reading file '//trim(InputFile)// ' line '//Num2LStr(iLine)
               endif
               exit
           endif
           ! Line content is analyzed as case incensitive 
           call Conv2UC(Line)
           if (index(Line,'!DIMENSION')==1) then
               p%nTot = ReadIntFromStr(Line(12:), '`dimension`, file '//trim(InputFile)//', line '//Num2LStr(iLine), ErrStat, ErrMsg); if (ErrStat /= 0) exit
               p%nCB=p%nTot-6

           else if (index(Line,'!TIME INCREMENT IN SIMULATION:')==1) then
               dt =  ReadFloatFromStr(Line(31:), '`time increment`, file '//trim(InputFile)//', line '//Num2LStr(iLine), ErrStat, ErrMsg); if (ErrStat /= 0) exit

           else if (index(Line,'!TOTAL SIMULATION TIME IN FILE:')==1) then
               T =  ReadFloatFromStr(Line(32:), '`total simulation time`, file '//trim(InputFile)//', line '//Num2LStr(iLine), ErrStat, ErrMsg ); if (ErrStat /= 0) exit

           else if (index(Line,'!MASS MATRIX')==1) then
               iLine=iLine+1
               CALL ReadCom( UnIn, InputFile, 'Comment - Line '//Num2LStr(iLine), ErrStat, ErrMsg); if (ErrStat /= 0) exit
               if (p%nTot<0) exit
               call ReadRealMatrix(UnIn, InputFile, p%PtfmAM, 'Mass Matrix', p%nTot, p%nTot, ErrStat, ErrMsg, iLine)

           else if (index(Line,'!STIFFNESS MATRIX')==1) then
               iLine=iLine+1
               CALL ReadCom( UnIn, InputFile, 'Comment - Line '//Num2LStr(iLine), ErrStat, ErrMsg);  if (ErrStat /= 0) exit
               if (p%nTot<0) exit
               call ReadRealMatrix(UnIn, InputFile, p%Stff, 'Stiffness Matrix', p%nTot, p%nTot, ErrStat, ErrMsg, iLine)

           else if (index(Line,'!DAMPING MATRIX')==1) then
               iLine=iLine+1
               CALL ReadCom( UnIn, InputFile, 'Comment - Line '//Num2LStr(iLine), ErrStat, ErrMsg); if (ErrStat /= 0) exit
               if (p%nTot<0) exit
               call ReadRealMatrix(UnIn, InputFile, p%Damp, 'Damping Matrix', p%nTot, p%nTot, ErrStat, ErrMsg, iLine)

           else if (index(Line,'!LOADING AND WAVE ELEVATION')==1) then
               iLine=iLine+1
               CALL ReadCom( UnIn, InputFile, 'Comment - Line '//Num2LStr(iLine), ErrStat, ErrMsg)
               if (ErrStat /= 0) exit
               p%nPtfmFt = nint(T/dt)+1
               if (p%nTot<0) exit
               call allocAry( p%PtfmFt,   max(1,p%nPtfmFt), p%nTot, 'p%PtfmFt',   ErrStat, ErrMsg); if (ErrStat /= 0) exit
               call allocAry( p%PtfmFt_t, max(1,p%nPtfmFt),         'p%PtfmFt_t', ErrStat, ErrMsg); if (ErrStat /= 0) exit
               if (p%nPtfmFt == 0) then
                  p%PtfmFt   = 0.0_ReKi
                  p%PtfmFt_t = 0.0_ReKi
                  p%nPtfmFt  = 1
               else
                  allocate(TmpAry(1:p%nTot+1))
                  do i=1,p%nPtfmFt
                     iLine=iLine+1
                     call ReadAry( UnIn, InputFile, TmpAry, p%nTot+1, 'PtfmFt - Line: '//Num2LStr(iLine)//' Value: '//trim(Num2LStr(i))//'/'//Num2LStr(p%nPtfmFt), 'PtfmFt time-history', ErrStat, ErrMsg)
                     if (ErrStat /= 0) exit
                     p%PtfmFt_t(i) = TmpAry(1)
                     p%PtfmFt(i,:) = TmpAry(2:p%nTot+1)
                  end do
               end if

           elseif (index(Line,'!')==1) then
               write(*,*) 'Ignored comment: '//trim(Line)
           else
                ! Ignore unsupported lines
!                write(*,*) 'Ignored line: '//trim(Line)
           endif
       enddo
       close( UnIn )
   END SUBROUTINE ReadFlexASCII

   !> Reads a Guyan ASCII file 
   SUBROUTINE ReadGuyanASCII()
       ! Guyan reduction has 6 DOF, 0 CB DOFs
       p%nCB  = 0
       p%nTot = 6
       ! Get an available unit number for the file.
       CALL GetNewUnit( UnIn, ErrStat, ErrMsg );               if ( ErrStat /= 0 ) return
       ! Open the Primary input file.
       CALL OpenFInpFile ( UnIn, InputFile, ErrStat, ErrMsg ); if ( ErrStat /= 0 ) return

       !-------------------------- HEADER ---------------------------------------------
       CALL ReadStr( UnIn, InputFile, Line, 'Header line', 'File Header: External Platform MCKF Matrices (line 1)', ErrStat, ErrMsg)
       if ( ErrStat /= 0 ) return
       !---------------------- MASS MATRIX --------------------------------------
       CALL ReadCom( UnIn, InputFile, 'Section Header: Mass Matrix', ErrStat, ErrMsg)
       if ( ErrStat /= 0 ) return
       CALL ReadRealMatrix(UnIn, InputFile, p%PtfmAM, 'Mass Matrix', p%nTot, p%nTot, ErrStat, ErrMsg, iLine)
       if ( ErrStat /= 0 ) return
       !---------------------- DAMPING MATRIX --------------------------------------
       CALL ReadCom( UnIn, InputFile, 'Section Header: Damping Matrix', ErrStat, ErrMsg)
       if ( ErrStat /= 0 ) return
       CALL ReadRealMatrix(UnIn, InputFile, p%Damp, 'Damping Matrix', p%nTot, p%nTot, ErrStat, ErrMsg, iLine)
       if ( ErrStat /= 0 ) return
       !---------------------- STIFFNESS MATRIX --------------------------------------
       CALL ReadCom( UnIn, InputFile, 'Section Header: Stiffness Matrix', ErrStat, ErrMsg)
       if ( ErrStat /= 0 ) return
       CALL ReadRealMatrix(UnIn, InputFile, p%Stff, 'Stiffness Matrix', p%nTot, p%nTot, ErrStat, ErrMsg, iLine)
       if ( ErrStat /= 0 ) return
       !---------------------- LOAD time-history --------------------------------------
       p%nPtfmFt = 0
       CALL ReadCom( UnIn, InputFile, 'Section Header: Loads time-history', ErrStat, ErrMsg)
       CALL ReadCom( UnIn, InputFile, 'Loads time-history table channel names', ErrStat, ErrMsg)
       CALL ReadCom( UnIn, InputFile, 'Loads time-history table channel units', ErrStat, ErrMsg)
       allocate(TmpAry(1:p%nTot+1))
       if (ErrStat < AbortErrLev) then
          ! let's figure out how many rows of data are in the time-history table:
          read( UnIn, *, IOSTAT=ErrStat ) TmpAry
          do while (ErrStat==0)
             p%nPtfmFt = p%nPtfmFt + 1
             read( UnIn, *, IOSTAT=ErrStat ) TmpAry
          end do
       end if
       call allocAry( p%PtfmFt,   max(1,p%nPtfmFt), p%nTot, 'p%PtfmFt',   ErrStat, ErrMsg); if ( ErrStat /= 0 ) return
       call allocAry( p%PtfmFt_t, max(1,p%nPtfmFt),         'p%PtfmFt_t', ErrStat, ErrMsg); if ( ErrStat /= 0 ) return
       if (p%nPtfmFt == 0) then
          p%PtfmFt = 0.0_ReKi
          p%PtfmFt_t = 0.0_ReKi
          p%nPtfmFt = 1
       else
          rewind(UnIn)
          do i=1,25 ! skip the first 25 rows of the file until we get to the data for the time-history table
             read(UnIn,*,IOSTAT=ErrStat) line
          end do
          do i=1,p%nPtfmFt
             call ReadAry( UnIn, InputFile, TmpAry, p%nTot+1, 'PtfmFt', 'PtfmFt time-history', ErrStat, ErrMsg)
             if ( ErrStat /= 0 ) return
             p%PtfmFt_t(i) = TmpAry(1)
             p%PtfmFt(i,:) = TmpAry(2:p%nTot+1)
          end do
       end if
       !---------------------- END OF FILE -----------------------------------------
       close( UnIn )
   END SUBROUTINE ReadGuyanASCII
END SUBROUTINE ReadPrimaryFile      

!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE SetStateMatrices( p, ErrStat, ErrMsg)
!..................................................................................................................................
   TYPE(ExtPtfm_ParameterType), INTENT(INOUT) :: p                                   !< All the parameter matrices stored in this input file
   INTEGER(IntKi),              INTENT(OUT)   :: ErrStat                             !< Error status                              
   CHARACTER(*),                INTENT(OUT)   :: ErrMsg                              !< Error message
   ! Local variables:
   REAL(ReKi)                              :: TmpAry(7)                                 ! temporary array for reading row from file
   INTEGER(IntKi)                          :: I,J                                       ! loop counter
   INTEGER(IntKi)                          :: UnIn                                      ! Unit number for reading file
   INTEGER(IntKi)                          :: nX                                        ! Number of states
   INTEGER(IntKi)                          :: nU                                        ! Number of inputs
   INTEGER(IntKi)                          :: nY                                        ! Number of ouputs
   INTEGER(IntKi)                          :: n1                                        ! Number of interface DOF
   INTEGER(IntKi)                          :: n2                                        ! Number of CB DOF
   CHARACTER(200)                          :: Line                                      ! Temporary storage of a line from the input file (to compare with "default")
   CHARACTER(200)                          :: Line2                                     ! Temporary storage of a line from the input file (to compare with "default")
   real(ReKi), dimension(:,:), allocatable :: I22
   ! Init 
   nX = 2*p%nCB
   nU = 3*6
   nY = 6
   n1 = 6
   n2 = p%nCB
   if (allocated(p%AMat)) deallocate(p%AMat)
   if (allocated(p%BMat)) deallocate(p%BMat)
   if (allocated(p%CMat)) deallocate(p%CMat)
   if (allocated(p%DMat)) deallocate(p%DMat)
   if (allocated(p%M11))  deallocate(p%M11)
   if (allocated(p%M12))  deallocate(p%M12)
   if (allocated(p%M22))  deallocate(p%M22)
   if (allocated(p%M21))  deallocate(p%M21)
   if (allocated(p%C11))  deallocate(p%C11)
   if (allocated(p%C12))  deallocate(p%C12)
   if (allocated(p%C22))  deallocate(p%C22)
   if (allocated(p%C21))  deallocate(p%C21)
   if (allocated(p%K11))  deallocate(p%C11)
   if (allocated(p%K22))  deallocate(p%C22)
   ! Allocation
   call allocAry(p%AMat, nX, nX, 'p%AMat', ErrStat, ErrMsg); if(Failed()) return ; p%AMat(1:nX,1:nX) =0
   call allocAry(p%BMat, nX, nU, 'p%BMat', ErrStat, ErrMsg); if(Failed()) return ; p%BMat(1:nX,1:nU) =0
   call allocAry(p%FX  , nX,     'p%FX'  , ErrStat, ErrMsg); if(Failed()) return ; p%Fx  (1:nX)      =0
   call allocAry(p%CMat, nY, nX, 'p%CMat', ErrStat, ErrMsg); if(Failed()) return ; p%CMat(1:nY,1:nX) =0
   call allocAry(p%DMat, nY, nU, 'p%DMat', ErrStat, ErrMsg); if(Failed()) return ; p%DMat(1:nY,1:nU) =0
   call allocAry(p%FY  , nY,     'p%FY'  , ErrStat, ErrMsg); if(Failed()) return ; p%FY  (1:nY)      =0
   call allocAry(p%M11 , n1, n1, 'p%M11' , ErrStat, ErrMsg); if(Failed()) return ; p%M11 (1:n1,1:n1) =0
   call allocAry(p%K11 , n1, n1, 'p%K11' , ErrStat, ErrMsg); if(Failed()) return ; p%K11 (1:n1,1:n1) =0
   call allocAry(p%C11 , n1, n1, 'p%C11' , ErrStat, ErrMsg); if(Failed()) return ; p%C11 (1:n1,1:n1) =0
   call allocAry(p%M22 , n2, n2, 'p%M22' , ErrStat, ErrMsg); if(Failed()) return ; p%M22 (1:n2,1:n2) =0
   call allocAry(p%K22 , n2, n2, 'p%K22' , ErrStat, ErrMsg); if(Failed()) return ; p%K22 (1:n2,1:n2) =0
   call allocAry(p%C22 , n2, n2, 'p%C22' , ErrStat, ErrMsg); if(Failed()) return ; p%C22 (1:n2,1:n2) =0
   call allocAry(p%M12 , n1, n2, 'p%M12' , ErrStat, ErrMsg); if(Failed()) return ; p%M12 (1:n1,1:n2) =0
   call allocAry(p%C12 , n1, n2, 'p%C12' , ErrStat, ErrMsg); if(Failed()) return ; p%C12 (1:n1,1:n2) =0
   call allocAry(p%M21 , n2, n1, 'p%M21' , ErrStat, ErrMsg); if(Failed()) return ; p%M21 (1:n2,1:n1) =0
   call allocAry(p%C21 , n2, n1, 'p%C21' , ErrStat, ErrMsg); if(Failed()) return ; p%C21 (1:n2,1:n1) =0
   call allocAry(  I22 , n2, n2, '  I22' , ErrStat, ErrMsg); if(Failed()) return ;   I22 (1:n2,1:n2) =0
   do I=1,n2 ; I22(I,I)=1; enddo ! Identity matrix
   ! Submatrices
   p%M11(1:n1,1:n1) = p%PtfmAM(1:n1      ,1:n1      )
   p%C11(1:n1,1:n1) = p%Damp  (1:n1      ,1:n1      )
   p%K11(1:n1,1:n1) = p%Stff  (1:n1      ,1:n1      )
   p%M12(1:n1,1:n2) = p%PtfmAM(1:n1      ,n1+1:n1+n2)
   p%C12(1:n1,1:n2) = p%Damp  (1:n1      ,n1+1:n1+n2)
   p%M21(1:n2,1:n1) = p%PtfmAM(n1+1:n1+n2,1:n1      )
   p%C21(1:n2,1:n1) = p%Damp  (n1+1:n1+n2,1:n1      )
   p%M22(1:n2,1:n2) = p%PtfmAM(n1+1:n1+n2,n1+1:n1+n2)
   p%C22(1:n2,1:n2) = p%Damp  (n1+1:n1+n2,n1+1:n1+n2)
   p%K22(1:n2,1:n2) = p%Stff  (n1+1:n1+n2,n1+1:n1+n2)
   ! A matrix
   p%AMat(1:n2   ,n2+1:nX) = I22   (1:n2,1:n2)
   p%AMat(n2+1:nX,1:n2   ) = -p%K22(1:n2,1:n2)
   p%AMat(n2+1:nX,n2+1:nX) = -p%C22(1:n2,1:n2)
   ! B matrix
   p%BMat(n2+1:nX,7 :12  ) = -p%C21(1:n2,1:6)
   p%BMat(n2+1:nX,13:18  ) = -p%M21(1:n2,1:6)
   ! C matrix
   p%CMat(1:nY,1:n2   ) = matmul(p%M12,p%K22)
   p%CMat(1:nY,n2+1:nX) = matmul(p%M12,p%C22)
   ! D matrix
   p%DMat(1:nY,1:6   ) = -p%K11
   p%DMat(1:nY,7:12  ) = -p%C11 + matmul(p%M12,p%C21)
   p%DMat(1:nY,13:18 ) = -p%M11 + matmul(p%M12,p%M21)
!    call disp2r8(6, 'M',p%PtfmAM)
!    call disp2r8(6, 'K',p%Stff)
!    call disp2r8(6, 'C',p%Damp)
!    call disp2r8(6, 'F',p%PtfmFt)
!    call disp2r8(6, 'M11',p%M11)
!    call disp2r8(6, 'M12',p%M12)
!    call disp2r8(6, 'M21',p%M21)
!    call disp2r8(6, 'M22',p%M22)
!    call disp2r8(6, 'K11',p%K11)
!    call disp2r8(6, 'K22',p%K22)
!    call disp2r8(6, 'C11',p%C11)
!    call disp2r8(6, 'C12',p%C12)
!    call disp2r8(6, 'C21',p%C21)
!    call disp2r8(6, 'C22',p%C22)
!    call disp2r8(6, 'A',p%AMat)
!    call disp2r8(6, 'B',p%BMat)
!    call disp2r8(6, 'C',p%CMat)
!    call disp2r8(6, 'D',p%DMat)

CONTAINS
    logical function Failed()
        CALL SetErrStatSimple(ErrStat, ErrMsg, 'ExtPtfm_SetStateMatrices')
        Failed =  ErrStat >= AbortErrLev
    end function Failed
END SUBROUTINE SetStateMatrices
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE Init_meshes(u, y, ErrStat, ErrMsg)
   TYPE(ExtPtfm_InputType),           INTENT(INOUT)  :: u           !< System inputs
   TYPE(ExtPtfm_OutputType),          INTENT(INOUT)  :: y           !< System outputs
   INTEGER(IntKi),                    INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                      INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None
   ! Create the input and output meshes associated with platform loads
   CALL MeshCreate(  BlankMesh         = u%PtfmMesh       , &
                     IOS               = COMPONENT_INPUT  , &
                     Nnodes            = 1                , &
                     ErrStat           = ErrStat          , &
                     ErrMess           = ErrMsg           , &
                     TranslationDisp   = .TRUE.           , &
                     Orientation       = .TRUE.           , &
                     TranslationVel    = .TRUE.           , &
                     RotationVel       = .TRUE.           , &
                     TranslationAcc    = .TRUE.           , &
                     RotationAcc       = .TRUE.)
   if(Failed()) return
      
   ! Create the node on the mesh
   CALL MeshPositionNode (u%PtfmMesh, 1, (/0.0_ReKi, 0.0_ReKi, 0.0_ReKi/), ErrStat, ErrMsg ); if(Failed()) return
   ! Create the mesh element
   CALL MeshConstructElement (  u%PtfmMesh, ELEMENT_POINT, ErrStat, ErrMsg, 1 ); if(Failed()) return
   CALL MeshCommit ( u%PtfmMesh, ErrStat, ErrMsg ); if(Failed()) return
   ! the output mesh is a sibling of the input:
   CALL MeshCopy( SrcMesh=u%PtfmMesh, DestMesh=y%PtfmMesh, CtrlCode=MESH_SIBLING, IOS=COMPONENT_OUTPUT, &
                  ErrStat=ErrStat, ErrMess=ErrMsg, Force=.TRUE., Moment=.TRUE. )
   if(Failed()) return
CONTAINS
    logical function Failed()
        CALL SetErrStatSimple(ErrStat, ErrMsg, 'Init_meshes')
        Failed =  ErrStat >= AbortErrLev
    end function Failed
END SUBROUTINE Init_meshes
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine is called at the end of the simulation.
SUBROUTINE ExtPtfm_End( u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg )
!..................................................................................................................................
   TYPE(ExtPtfm_InputType),           INTENT(INOUT)  :: u           !< System inputs
   TYPE(ExtPtfm_ParameterType),       INTENT(INOUT)  :: p           !< Parameters
   TYPE(ExtPtfm_ContinuousStateType), INTENT(INOUT)  :: x           !< Continuous states
   TYPE(ExtPtfm_DiscreteStateType),   INTENT(INOUT)  :: xd          !< Discrete states
   TYPE(ExtPtfm_ConstraintStateType), INTENT(INOUT)  :: z           !< Constraint states
   TYPE(ExtPtfm_OtherStateType),      INTENT(INOUT)  :: OtherState  !< Other states
   TYPE(ExtPtfm_OutputType),          INTENT(INOUT)  :: y           !< System outputs
   TYPE(ExtPtfm_MiscVarType),         INTENT(INOUT)  :: m           !< Misc variables for optimization (not copied in glue code)
   INTEGER(IntKi),                    INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                      INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None
   ! Place any last minute operations or calculations here:
   ! Close files here (but because of checkpoint-restart capability, it is not recommended to have files open during the simulation):
   ! Destroy the input data:
   call ExtPtfm_DestroyInput( u, ErrStat, ErrMsg ); if(Failed()) return
   ! Destroy the parameter data:
   call ExtPtfm_DestroyParam( p, ErrStat, ErrMsg ); if(Failed()) return
   ! Destroy the state data:
   call ExtPtfm_DestroyContState(   x,          ErrStat,ErrMsg); if(Failed()) return
   call ExtPtfm_DestroyDiscState(   xd,         ErrStat,ErrMsg); if(Failed()) return
   call ExtPtfm_DestroyConstrState( z,          ErrStat,ErrMsg); if(Failed()) return
   call ExtPtfm_DestroyOtherState(  OtherState, ErrStat,ErrMsg); if(Failed()) return
   ! Destroy the output data:
   call ExtPtfm_DestroyOutput( y, ErrStat, ErrMsg ); if(Failed()) return
   ! Destroy the misc data:
   call ExtPtfm_DestroyMisc( m, ErrStat, ErrMsg ); if(Failed()) return
CONTAINS
    logical function Failed()
        CALL SetErrStatSimple(ErrStat, ErrMsg, 'ExtPtfm_End')
        Failed =  ErrStat >= AbortErrLev
    end function Failed
END SUBROUTINE ExtPtfm_End


!----------------------------------------------------------------------------------------------------------------------------------
!> This subroutine implements the fourth-order Adams-Bashforth Method (RK4) for numerically integrating ordinary differential 
!! equations:
!!  Let f(t, x) = xdot denote the time (t) derivative of the continuous states (x). 
!!      x(t+dt) = x(t)  + (dt / 24.) * ( 55.*f(t,x) - 59.*f(t-dt,x) + 37.*f(t-2.*dt,x) - 9.*f(t-3.*dt,x) )
!!  See, e.g.,
!!      http://en.wikipedia.org/wiki/Linear_multistep_method
!!      K. E. Atkinson, "An Introduction to Numerical Analysis", 1989, John Wiley & Sons, Inc, Second Edition.
SUBROUTINE ExtPtfm_AB4( t, n, u, utimes, p, x, xd, z, OtherState, m, ErrStat, ErrMsg )
!..................................................................................................................................
   REAL(DbKi),                        INTENT(IN   )  :: t           !< Current simulation time in seconds
   INTEGER(IntKi),                    INTENT(IN   )  :: n           !< time step number
   TYPE(ExtPtfm_InputType),           INTENT(INOUT)  :: u(:)        !< Inputs at t
   REAL(DbKi),                        INTENT(IN   )  :: utimes(:)   !< times of input
   TYPE(ExtPtfm_ParameterType),       INTENT(IN   )  :: p           !< Parameters
   TYPE(ExtPtfm_ContinuousStateType), INTENT(INOUT)  :: x           !< Continuous states at t on input at t + dt on output
   TYPE(ExtPtfm_DiscreteStateType),   INTENT(IN   )  :: xd          !< Discrete states at t
   TYPE(ExtPtfm_ConstraintStateType), INTENT(IN   )  :: z           !< Constraint states at t (possibly a guess)
   TYPE(ExtPtfm_OtherStateType),      INTENT(INOUT)  :: OtherState  !< Other states at t on input at t + dt on output
   TYPE(ExtPtfm_MiscVarType),         INTENT(INOUT)  :: m           !< Misc/optimization variables
   INTEGER(IntKi),                    INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                      INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None
   ! local variables
   TYPE(ExtPtfm_ContinuousStateType) :: xdot       ! Continuous state derivs at t
   TYPE(ExtPtfm_InputType)           :: u_interp
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = "" 
   
   ! need xdot at t
   CALL ExtPtfm_CopyInput(u(1), u_interp, MESH_NEWCOPY, ErrStat, ErrMsg  )  ! we need to allocate input arrays/meshes before calling ExtrapInterp...
   CALL ExtPtfm_Input_ExtrapInterp(u, utimes, u_interp, t, ErrStat, ErrMsg)
   CALL ExtPtfm_CalcContStateDeriv( t, u_interp, p, x, xd, z, OtherState, m, xdot, ErrStat, ErrMsg ) ! initializes xdot
   CALL ExtPtfm_DestroyInput( u_interp, ErrStat, ErrMsg)   ! we don't need this local copy anymore
   if (n .le. 2) then
      OtherState%n = n
      CALL ExtPtfm_CopyContState(xdot, OtherState%xdot(3-n), MESH_UPDATECOPY, ErrStat, ErrMsg )
      CALL ExtPtfm_RK4(t, n, u, utimes, p, x, xd, z, OtherState, m, ErrStat, ErrMsg )
   else
      if (OtherState%n .lt. n) then
         OtherState%n = n
         CALL ExtPtfm_CopyContState(OtherState%xdot(3), OtherState%xdot(4), MESH_UPDATECOPY, ErrStat, ErrMsg )
         CALL ExtPtfm_CopyContState(OtherState%xdot(2), OtherState%xdot(3), MESH_UPDATECOPY, ErrStat, ErrMsg )
         CALL ExtPtfm_CopyContState(OtherState%xdot(1), OtherState%xdot(2), MESH_UPDATECOPY, ErrStat, ErrMsg )
      elseif (OtherState%n .gt. n) then
         ErrStat = ErrID_Fatal
         ErrMsg = ' Backing up in time is not supported with a multistep method '
         RETURN
      endif
      CALL ExtPtfm_CopyContState( xdot, OtherState%xdot ( 1 ), MESH_UPDATECOPY, ErrStat, ErrMsg )
      !OtherState%xdot ( 1 )     = xdot  ! make sure this is most up to date
      x%qm    = x%qm    + (p%EP_DeltaT / 24.) * ( 55.*OtherState%xdot(1)%qm - 59.*OtherState%xdot(2)%qm    + 37.*OtherState%xdot(3)%qm  &
                                    - 9. * OtherState%xdot(4)%qm )
      x%qmdot = x%qmdot + (p%EP_DeltaT / 24.) * ( 55.*OtherState%xdot(1)%qmdot - 59.*OtherState%xdot(2)%qmdot  &
                                       + 37.*OtherState%xdot(3)%qmdot  - 9.*OtherState%xdot(4)%qmdot )
   endif
   CALL ExtPtfm_DestroyContState(xdot, ErrStat, ErrMsg)
   CALL ExtPtfm_DestroyInput(u_interp, ErrStat, ErrMsg)
   
END SUBROUTINE ExtPtfm_AB4
!----------------------------------------------------------------------------------------------------------------------------------
!> This subroutine implements the fourth-order Adams-Bashforth-Moulton Method (RK4) for numerically integrating ordinary 
!! differential equations:
!!   Let f(t, x) = xdot denote the time (t) derivative of the continuous states (x). 
!!   Adams-Bashforth Predictor:
!!      x^p(t+dt) = x(t)  + (dt / 24.) * ( 55.*f(t,x) - 59.*f(t-dt,x) + 37.*f(t-2.*dt,x) - 9.*f(t-3.*dt,x) )
!!   Adams-Moulton Corrector:
!!      x(t+dt) = x(t)  + (dt / 24.) * ( 9.*f(t+dt,x^p) + 19.*f(t,x) - 5.*f(t-dt,x) + 1.*f(t-2.*dt,x) )
!!  See, e.g.,
!!      http://en.wikipedia.org/wiki/Linear_multistep_method
!!      K. E. Atkinson, "An Introduction to Numerical Analysis", 1989, John Wiley & Sons, Inc, Second Edition.
SUBROUTINE ExtPtfm_ABM4( t, n, u, utimes, p, x, xd, z, OtherState, m, ErrStat, ErrMsg )
!..................................................................................................................................
   REAL(DbKi),                          INTENT(IN   ) :: t           !< Current simulation time in seconds
   INTEGER(IntKi),                      INTENT(IN   ) :: n           !< time step number
   TYPE(ExtPtfm_InputType),             INTENT(INOUT) :: u(:)        !< Inputs at t
   REAL(DbKi),                          INTENT(IN   ) :: utimes(:)   !< times of input
   TYPE(ExtPtfm_ParameterType),         INTENT(IN   ) :: p           !< Parameters
   TYPE(ExtPtfm_ContinuousStateType),   INTENT(INOUT) :: x           !< Continuous states at t on input at t + dt on output
   TYPE(ExtPtfm_DiscreteStateType),     INTENT(IN   ) :: xd          !< Discrete states at t
   TYPE(ExtPtfm_ConstraintStateType),   INTENT(IN   ) :: z           !< Constraint states at t (possibly a guess)
   TYPE(ExtPtfm_OtherStateType),        INTENT(INOUT) :: OtherState  !< Other states at t on input at t + dt on output
   TYPE(ExtPtfm_MiscVarType),           INTENT(INOUT) :: m           !< Misc/optimization variables
   INTEGER(IntKi),                      INTENT(  OUT) :: ErrStat     !< Error status of the operation
   CHARACTER(*),                        INTENT(  OUT) :: ErrMsg      !< Error message if ErrStat /= ErrID_None
   ! local variables
   TYPE(ExtPtfm_InputType)            :: u_interp        ! Continuous states at t
   TYPE(ExtPtfm_ContinuousStateType)  :: x_pred          ! Continuous states at t
   TYPE(ExtPtfm_ContinuousStateType)  :: xdot_pred       ! Continuous states at t
   
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = "" 
   
   CALL ExtPtfm_CopyContState(x, x_pred, MESH_NEWCOPY, ErrStat, ErrMsg) !initialize x_pred      
   CALL ExtPtfm_AB4( t, n, u, utimes, p, x_pred, xd, z, OtherState, m, ErrStat, ErrMsg )
   if (n .gt. 2) then
      CALL ExtPtfm_CopyInput( u(1), u_interp, MESH_NEWCOPY, ErrStat, ErrMsg) ! make copy so that arrays/meshes get initialized/allocated for ExtrapInterp
      CALL ExtPtfm_Input_ExtrapInterp(u, utimes, u_interp, t + p%EP_DeltaT, ErrStat, ErrMsg)
      CALL ExtPtfm_CalcContStateDeriv(t + p%EP_DeltaT, u_interp, p, x_pred, xd, z, OtherState, m, xdot_pred, ErrStat, ErrMsg ) ! initializes xdot_pred
      CALL ExtPtfm_DestroyInput( u_interp, ErrStat, ErrMsg) ! local copy no longer needed
   
      x%qm    = x%qm    + (p%EP_DeltaT / 24.) * ( 9. * xdot_pred%qm +  19. * OtherState%xdot(1)%qm - 5. * OtherState%xdot(2)%qm &
                                       + 1. * OtherState%xdot(3)%qm )
   
      x%qmdot = x%qmdot + (p%EP_DeltaT / 24.) * ( 9. * xdot_pred%qmdot + 19. * OtherState%xdot(1)%qmdot - 5. * OtherState%xdot(2)%qmdot &
                                       + 1. * OtherState%xdot(3)%qmdot )
      CALL ExtPtfm_DestroyContState( xdot_pred, ErrStat, ErrMsg) ! local copy no longer needed
   else
      x%qm    = x_pred%qm
      x%qmdot = x_pred%qmdot
   endif
   CALL ExtPtfm_DestroyContState( x_pred, ErrStat, ErrMsg) ! local copy no longer needed
END SUBROUTINE ExtPtfm_ABM4

!----------------------------------------------------------------------------------------------------------------------------------
!> This subroutine implements the fourth-order Runge-Kutta Method (RK4) for numerically integrating ordinary differential equations:
!!   Let f(t, x) = xdot denote the time (t) derivative of the continuous states (x). 
!!   Define constants k1, k2, k3, and k4 as 
!!        k1 = dt * f(t        , x_t        )
!!        k2 = dt * f(t + dt/2 , x_t + k1/2 )
!!        k3 = dt * f(t + dt/2 , x_t + k2/2 ), and
!!        k4 = dt * f(t + dt   , x_t + k3   ).
!!   Then the continuous states at t = t + dt are
!!        x_(t+dt) = x_t + k1/6 + k2/3 + k3/3 + k4/6 + O(dt^5)
!! For details, see:
!!   Press, W. H.; Flannery, B. P.; Teukolsky, S. A.; and Vetterling, W. T. "Runge-Kutta Method" and "Adaptive Step Size Control for 
!!   Runge-Kutta." sections 16.1 and 16.2 in Numerical Recipes in FORTRAN: The Art of Scientific Computing, 2nd ed. Cambridge, England: 
!!   Cambridge University Press, pp. 704-716, 1992.
SUBROUTINE ExtPtfm_RK4( t, n, u, utimes, p, x, xd, z, OtherState, m, ErrStat, ErrMsg )
!..................................................................................................................................
   REAL(DbKi),                     INTENT(IN   )      :: t           !< Current simulation time in seconds
   INTEGER(IntKi),                 INTENT(IN   )      :: n           !< time step number
   TYPE(ExtPtfm_InputType),             INTENT(INOUT) :: u(:)        !< Inputs at t
   REAL(DbKi),                     INTENT(IN   )      :: utimes(:)   !< times of input
   TYPE(ExtPtfm_ParameterType),         INTENT(IN   ) :: p           !< Parameters
   TYPE(ExtPtfm_ContinuousStateType),   INTENT(INOUT) :: x           !< Continuous states at t on input at t + dt on output
   TYPE(ExtPtfm_DiscreteStateType),     INTENT(IN   ) :: xd          !< Discrete states at t
   TYPE(ExtPtfm_ConstraintStateType),   INTENT(IN   ) :: z           !< Constraint states at t (possibly a guess)
   TYPE(ExtPtfm_OtherStateType),        INTENT(INOUT) :: OtherState  !< Other states at t on input at t + dt on output
   TYPE(ExtPtfm_MiscVarType),           INTENT(INOUT) :: m           !< Misc/optimization variables
   INTEGER(IntKi),                 INTENT(  OUT)      :: ErrStat     !< Error status of the operation
   CHARACTER(*),                   INTENT(  OUT)      :: ErrMsg      !< Error message if ErrStat /= ErrID_None
   ! local variables
   TYPE(ExtPtfm_ContinuousStateType)                 :: xdot        ! time derivatives of continuous states      
   TYPE(ExtPtfm_ContinuousStateType)                 :: k1          ! RK4 constant; see above
   TYPE(ExtPtfm_ContinuousStateType)                 :: k2          ! RK4 constant; see above 
   TYPE(ExtPtfm_ContinuousStateType)                 :: k3          ! RK4 constant; see above 
   TYPE(ExtPtfm_ContinuousStateType)                 :: k4          ! RK4 constant; see above 
   TYPE(ExtPtfm_ContinuousStateType)                 :: x_tmp       ! Holds temporary modification to x
   TYPE(ExtPtfm_InputType)                           :: u_interp    ! interpolated value of inputs 
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = "" 
   
   ! Initialize interim vars
   !bjj: the state type contains allocatable arrays, so we must first allocate space:
   CALL ExtPtfm_CopyContState( x, k1,       MESH_NEWCOPY, ErrStat, ErrMsg )
   CALL ExtPtfm_CopyContState( x, k2,       MESH_NEWCOPY, ErrStat, ErrMsg )
   CALL ExtPtfm_CopyContState( x, k3,       MESH_NEWCOPY, ErrStat, ErrMsg )
   CALL ExtPtfm_CopyContState( x, k4,       MESH_NEWCOPY, ErrStat, ErrMsg )
   CALL ExtPtfm_CopyContState( x, x_tmp,    MESH_NEWCOPY, ErrStat, ErrMsg )
   
   ! interpolate u to find u_interp = u(t)
   CALL ExtPtfm_CopyInput(u(1), u_interp, MESH_NEWCOPY, ErrStat, ErrMsg  )  ! we need to allocate input arrays/meshes before calling ExtrapInterp...     
   CALL ExtPtfm_Input_ExtrapInterp( u, utimes, u_interp, t, ErrStat, ErrMsg )
   
   ! find xdot at t
   CALL ExtPtfm_CalcContStateDeriv( t, u_interp, p, x, xd, z, OtherState, m, xdot, ErrStat, ErrMsg ) !initializes xdot
   
   k1%qm    = p%EP_DeltaT * xdot%qm
   k1%qmdot = p%EP_DeltaT * xdot%qmdot
   x_tmp%qm    = x%qm    + 0.5 * k1%qm
   x_tmp%qmdot = x%qmdot + 0.5 * k1%qmdot
   
   ! interpolate u to find u_interp = u(t + dt/2)
   CALL ExtPtfm_Input_ExtrapInterp(u, utimes, u_interp, t+0.5*p%EP_DeltaT, ErrStat, ErrMsg)
   
   ! find xdot at t + dt/2
   CALL ExtPtfm_CalcContStateDeriv( t + 0.5*p%EP_DeltaT, u_interp, p, x_tmp, xd, z, OtherState, m, xdot, ErrStat, ErrMsg )
   
   k2%qm    = p%EP_DeltaT * xdot%qm
   k2%qmdot = p%EP_DeltaT * xdot%qmdot
   x_tmp%qm    = x%qm    + 0.5 * k2%qm
   x_tmp%qmdot = x%qmdot + 0.5 * k2%qmdot
   
   ! find xdot at t + dt/2
   CALL ExtPtfm_CalcContStateDeriv( t + 0.5*p%EP_DeltaT, u_interp, p, x_tmp, xd, z, OtherState, m, xdot, ErrStat, ErrMsg )
   
   k3%qm    = p%EP_DeltaT * xdot%qm
   k3%qmdot = p%EP_DeltaT * xdot%qmdot
   x_tmp%qm    = x%qm    + k3%qm
   x_tmp%qmdot = x%qmdot + k3%qmdot
   
   ! interpolate u to find u_interp = u(t + dt)
   CALL ExtPtfm_Input_ExtrapInterp(u, utimes, u_interp, t + p%EP_DeltaT, ErrStat, ErrMsg)
   
   ! find xdot at t + dt
   CALL ExtPtfm_CalcContStateDeriv( t + p%EP_DeltaT, u_interp, p, x_tmp, xd, z, OtherState, m, xdot, ErrStat, ErrMsg )
   
   k4%qm    = p%EP_DeltaT * xdot%qm
   k4%qmdot = p%EP_DeltaT * xdot%qmdot
   x%qm    = x%qm    +  ( k1%qm    + 2. * k2%qm    + 2. * k3%qm    + k4%qm    ) / 6.      
   x%qmdot = x%qmdot +  ( k1%qmdot + 2. * k2%qmdot + 2. * k3%qmdot + k4%qmdot ) / 6.      
   CALL ExitThisRoutine()
CONTAINS      
   !...............................................................................................................................
   SUBROUTINE ExitThisRoutine()
      ! This subroutine destroys all the local variables
      INTEGER(IntKi)             :: ErrStat3    ! The error identifier (ErrStat)
      CHARACTER(1024)            :: ErrMsg3     ! The error message (ErrMsg)
      CALL ExtPtfm_DestroyContState( xdot,     ErrStat3, ErrMsg3 )
      CALL ExtPtfm_DestroyContState( k1,       ErrStat3, ErrMsg3 )
      CALL ExtPtfm_DestroyContState( k2,       ErrStat3, ErrMsg3 )
      CALL ExtPtfm_DestroyContState( k3,       ErrStat3, ErrMsg3 )
      CALL ExtPtfm_DestroyContState( k4,       ErrStat3, ErrMsg3 )
      CALL ExtPtfm_DestroyContState( x_tmp,    ErrStat3, ErrMsg3 )
      CALL ExtPtfm_DestroyInput(     u_interp, ErrStat3, ErrMsg3 )
   END SUBROUTINE ExitThisRoutine            
      
END SUBROUTINE ExtPtfm_RK4


!----------------------------------------------------------------------------------------------------------------------------------
!> This is a loose coupling routine for solving constraint states, integrating continuous states, and updating discrete and other
!! states. Continuous, constraint, discrete, and other states are updated to values at t + Interval.
SUBROUTINE ExtPtfm_UpdateStates( t, n, Inputs, InputTimes, p, x, xd, z, OtherState, m, ErrStat, ErrMsg )
!..................................................................................................................................
   REAL(DbKi),                         INTENT(IN   ) :: t               !< Current simulation time in seconds
   INTEGER(IntKi),                     INTENT(IN   ) :: n               !< Current step of the simulation: t = n*Interval
   TYPE(ExtPtfm_InputType),            INTENT(INOUT) :: Inputs(:)       !< Inputs at InputTimes (output from this routine only
                                                                        !!  because of record keeping in routines that copy meshes)
   REAL(DbKi),                         INTENT(IN   ) :: InputTimes(:)   !< Times in seconds associated with Inputs
   TYPE(ExtPtfm_ParameterType),        INTENT(IN   ) :: p               !< Parameters
   TYPE(ExtPtfm_ContinuousStateType),  INTENT(INOUT) :: x               !< Input: Continuous states at t;
                                                                        !!   Output: Continuous states at t + Interval
   TYPE(ExtPtfm_DiscreteStateType),    INTENT(INOUT) :: xd              !< Input: Discrete states at t;
                                                                        !!   Output: Discrete states at t + Interval
   TYPE(ExtPtfm_ConstraintStateType),  INTENT(INOUT) :: z               !< Input: Constraint states at t;
                                                                        !!   Output: Constraint states at t + Interval
   TYPE(ExtPtfm_OtherStateType),       INTENT(INOUT) :: OtherState      !< Other states: Other states at t;
                                                                        !!   Output: Other states at t + Interval
   TYPE(ExtPtfm_MiscVarType),          INTENT(INOUT) :: m               !<  Misc variables for optimization (not copied in glue code)
   INTEGER(IntKi),                     INTENT(  OUT) :: ErrStat         !< Error status of the operation
   CHARACTER(*),                       INTENT(  OUT) :: ErrMsg          !< Error message if ErrStat /= ErrID_None
   ! Initialize variables
   ErrStat   = ErrID_None           ! no error has occurred
   ErrMsg    = ""
   if ( p%nCB == 0) return ! no modes = no states
   if (p%IntMethod .eq. 1) then 
      call ExtPtfm_RK4( t, n, Inputs, InputTimes, p, x, xd, z, OtherState, m, ErrStat, ErrMsg )
   elseif (p%IntMethod .eq. 2) then
      call ExtPtfm_AB4( t, n, Inputs, InputTimes, p, x, xd, z, OtherState, m, ErrStat, ErrMsg )
   elseif (p%IntMethod .eq. 3) then
      call ExtPtfm_ABM4( t, n, Inputs, InputTimes, p, x, xd, z, OtherState, m, ErrStat, ErrMsg )
   else  
      call SetErrStat(ErrID_Fatal,'Invalid time integration method:'//Num2LStr(p%IntMethod),ErrStat,ErrMsg,'ExtPtfm_UpdateState') 
   end IF
END SUBROUTINE ExtPtfm_UpdateStates
!----------------------------------------------------------------------------------------------------------------------------------
!> This is a routine for computing outputs, used in both loose and tight coupling.
SUBROUTINE ExtPtfm_CalcOutput( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg )
!..................................................................................................................................
   REAL(DbKi),                        INTENT(IN   )  :: t           !< Current simulation time in seconds
   TYPE(ExtPtfm_InputType),           INTENT(IN   )  :: u           !< Inputs at t
   TYPE(ExtPtfm_ParameterType),       INTENT(IN   )  :: p           !< Parameters
   TYPE(ExtPtfm_ContinuousStateType), INTENT(IN   )  :: x           !< Continuous states at t
   TYPE(ExtPtfm_DiscreteStateType),   INTENT(IN   )  :: xd          !< Discrete states at t
   TYPE(ExtPtfm_ConstraintStateType), INTENT(IN   )  :: z           !< Constraint states at t
   TYPE(ExtPtfm_OtherStateType),      INTENT(IN   )  :: OtherState  !< Other states at t
   TYPE(ExtPtfm_MiscVarType),         INTENT(INOUT)  :: m           !< Misc variables for optimization (not copied in glue code)
   TYPE(ExtPtfm_OutputType),          INTENT(INOUT)  :: y           !< Outputs computed at t (Input only so that mesh con-
                                                                     !!   nectivity information does not have to be recalculated)
   INTEGER(IntKi),                    INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                      INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None
   ! Local variables
   INTEGER(IntKi)                                  :: I                 !< Generic counters
   real(ReKi), dimension(6)                        :: Fc                !< Output coupling force
   ! Compute the loads `fr1 fr2` at t (fr1 without added mass) by time interpolation of the inputs loads p%PtfmFt
   call InterpStpMat(REAL(t,ReKi), p%PtfmFt_t, p%PtfmFt, m%Indx, p%nPtfmFt, m%PtfmFt)

   ! --- Flatening vectors and using linear state formulation y=Cx+Du+Fy
   ! u flat (x1, \dot{x1}, \ddot{x1})
   m%uFlat(1:3)   = u%PtfmMesh%TranslationDisp(:,1)
   m%uFlat(4:6)   = GetSmllRotAngs(u%PtfmMesh%Orientation(:,:,1), ErrStat, ErrMsg); CALL SetErrStatSimple(ErrStat, ErrMsg, 'ExtPtfm_CalcOutput')
   m%uFlat(7:9  ) = u%PtfmMesh%TranslationVel(:,1)
   m%uFlat(10:12) = u%PtfmMesh%RotationVel   (:,1)
   m%uFlat(13:15) = u%PtfmMesh%TranslationAcc(:,1)
   m%uFlat(16:18) = u%PtfmMesh%RotationAcc   (:,1)
   if (p%nCB>0) then
       ! x flat
       m%xFlat(1:p%nCB)         = x%qm(1:p%nCB)
       m%xFlat(p%nCB+1:2*p%nCB) = x%qmdot(1:p%nCB)
       ! y = Cx + Du + Fy  - TODO consider using lapack for efficiency
       Fc = matmul(p%CMat, m%xFlat) + matmul(p%DMat, m%uFlat) + m%PtfmFt(1:6) - matmul(p%M12, m%PtfmFt(6+1:6+p%nCB))
   else
       Fc =                           matmul(p%DMat, m%uFlat) + m%PtfmFt(1:6) 
   endif

   ! Update the output mesh
   do i=1,3
      y%PtfmMesh%Force(I,1)  = Fc(I)
      y%PtfmMesh%Moment(I,1) = Fc(I+3)
   enddo

   ! --- All Outputs
   m%AllOuts(ID_PtfFx) = y%PtfmMesh%Force (1,1)
   m%AllOuts(ID_PtfFy) = y%PtfmMesh%Force (2,1)
   m%AllOuts(ID_PtfFz) = y%PtfmMesh%Force (3,1)
   m%AllOuts(ID_PtfMx) = y%PtfmMesh%Moment(1,1)
   m%AllOuts(ID_PtfMy) = y%PtfmMesh%Moment(2,1)
   m%AllOuts(ID_PtfMz) = y%PtfmMesh%Moment(3,1)
   !y%WriteOutput(ID_WaveElev) = .. ! TODO
   do i=1,p%nCB
      m%AllOuts(ID_QStart + 0*p%nCB -1 + I) = x%qm   (I)    ! CBQ  - DOF Positions
      m%AllOuts(ID_QStart + 1*p%nCB -1 + I) = x%qmdot(I)    ! CBQD - DOF Velocities
      m%AllOuts(ID_QStart + 2*p%nCB -1 + I) = m%PtfmFt(6+I) ! CBF  - DOF Forces
   enddo
   ! --- Selected output channels only
   do I = 1,p%NumOuts
      if (p%OutParam(I)%Indx>0) then
          y%WriteOutput(I) = p%OutParam(I)%SignM * m%AllOuts( p%OutParam(I)%Indx )
      else
          y%WriteOutput(I) = -999.99e-99
      endif
   enddo    
END SUBROUTINE ExtPtfm_CalcOutput
!----------------------------------------------------------------------------------------------------------------------------------


!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!> This is a tight coupling routine for computing derivatives of continuous states.
SUBROUTINE ExtPtfm_CalcContStateDeriv( t, u, p, x, xd, z, OtherState, m, dxdt, ErrStat, ErrMsg )
!..................................................................................................................................
   REAL(DbKi),                        INTENT(IN   )  :: t           !< Current simulation time in seconds
   TYPE(ExtPtfm_InputType),           INTENT(IN   )  :: u           !< Inputs at t
   TYPE(ExtPtfm_ParameterType),       INTENT(IN   )  :: p           !< Parameters
   TYPE(ExtPtfm_ContinuousStateType), INTENT(IN   )  :: x           !< Continuous states at t
   TYPE(ExtPtfm_DiscreteStateType),   INTENT(IN   )  :: xd          !< Discrete states at t
   TYPE(ExtPtfm_ConstraintStateType), INTENT(IN   )  :: z           !< Constraint states at t
   TYPE(ExtPtfm_OtherStateType),      INTENT(IN   )  :: OtherState  !< Other states at t
   TYPE(ExtPtfm_MiscVarType),         INTENT(INOUT)  :: m           !< Misc variables for optimization (not copied in glue code)
   TYPE(ExtPtfm_ContinuousStateType), INTENT(  OUT)  :: dxdt        !< Continuous state derivatives at t
   INTEGER(IntKi),                    INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                      INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None
   ! Local variables
   INTEGER(IntKi)                                    :: I
   ! Allocation of output dxdt (since intent(out))
   call AllocAry(dxdt%qm,    p%nCB, 'dxdt%qm',    ErrStat, ErrMsg); if(Failed()) return
   call AllocAry(dxdt%qmdot, p%nCB, 'dxdt%qmdot', ErrStat, ErrMsg); if(Failed()) return
   if ( p%nCB == 0 ) return
   do I=1,p%nCB; dxdt%qm   (I)=0; enddo
   do I=1,p%nCB; dxdt%qmdot(I)=0; enddo

   ! Compute the loads `fr1 fr2` at t (fr1 without added mass) by time interpolation of the inputs loads p%PtfmFt
   call InterpStpMat(REAL(t,ReKi), p%PtfmFt_t, p%PtfmFt, m%Indx, p%nPtfmFt, m%PtfmFt)

   ! u flat (x1, \dot{x1}, \ddot{x1})
   m%uFlat(1:3)   = u%PtfmMesh%TranslationDisp(:,1)
   m%uFlat(4:6)   = GetSmllRotAngs(u%PtfmMesh%Orientation(:,:,1), ErrStat, ErrMsg); if(Failed()) return
   m%uFlat(7:9  ) = u%PtfmMesh%TranslationVel(:,1)
   m%uFlat(10:12) = u%PtfmMesh%RotationVel   (:,1)
   m%uFlat(13:15) = u%PtfmMesh%TranslationAcc(:,1)
   m%uFlat(16:18) = u%PtfmMesh%RotationAcc   (:,1)

   dxdt%qm= x%qmdot
   ! \ddot{x2} = -K22 x2 - C22 \dot{x2}  - C21 \dot{x1} - M21 \ddot{x1} + fr2
   dxdt%qmdot = - matmul(p%K22,x%qm) - matmul(p%C22,x%qmdot) &
                - matmul(p%C21,m%uFlat(7:12)) - matmul(p%M21, m%uFlat(13:18)) + m%PtfmFt(6+1:6+p%nCB)
CONTAINS
    logical function Failed()
        CALL SetErrStatSimple(ErrStat, ErrMsg, 'ExtPtfm_CalcContStateDeriv')
        Failed =  ErrStat >= AbortErrLev
    end function Failed
END SUBROUTINE ExtPtfm_CalcContStateDeriv
!----------------------------------------------------------------------------------------------------------------------------------
!> This is a tight coupling routine for updating discrete states.
SUBROUTINE ExtPtfm_UpdateDiscState( t, n, u, p, x, xd, z, OtherState, m, ErrStat, ErrMsg )
!..................................................................................................................................
   REAL(DbKi),                        INTENT(IN   )  :: t           !< Current simulation time in seconds
   INTEGER(IntKi),                    INTENT(IN   )  :: n           !< Current step of the simulation: t = n*Interval
   TYPE(ExtPtfm_InputType),           INTENT(IN   )  :: u           !< Inputs at t
   TYPE(ExtPtfm_ParameterType),       INTENT(IN   )  :: p           !< Parameters
   TYPE(ExtPtfm_ContinuousStateType), INTENT(IN   )  :: x           !< Continuous states at t
   TYPE(ExtPtfm_DiscreteStateType),   INTENT(INOUT)  :: xd          !< Input: Discrete states at t, Output: Discrete states at t + Interval
   TYPE(ExtPtfm_ConstraintStateType), INTENT(IN   )  :: z           !< Constraint states at t
   TYPE(ExtPtfm_OtherStateType),      INTENT(IN   )  :: OtherState  !< Other states at t
   TYPE(ExtPtfm_MiscVarType),         INTENT(INOUT)  :: m           !< Misc variables for optimization (not copied in glue code)
   INTEGER(IntKi),                    INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                      INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ""
   ! Update discrete states here:
   xd%DummyDiscState = 0.0_Reki
END SUBROUTINE ExtPtfm_UpdateDiscState
!----------------------------------------------------------------------------------------------------------------------------------
!> This is a tight coupling routine for solving for the residual of the constraint state functions.
SUBROUTINE ExtPtfm_CalcConstrStateResidual( t, u, p, x, xd, z, OtherState, m, Z_residual, ErrStat, ErrMsg )
!..................................................................................................................................
   REAL(DbKi),                        INTENT(IN   )  :: t           !< Current simulation time in seconds
   TYPE(ExtPtfm_InputType),           INTENT(IN   )  :: u           !< Inputs at t
   TYPE(ExtPtfm_ParameterType),       INTENT(IN   )  :: p           !< Parameters
   TYPE(ExtPtfm_ContinuousStateType), INTENT(IN   )  :: x           !< Continuous states at t
   TYPE(ExtPtfm_DiscreteStateType),   INTENT(IN   )  :: xd          !< Discrete states at t
   TYPE(ExtPtfm_ConstraintStateType), INTENT(IN   )  :: z           !< Constraint states at t (possibly a guess)
   TYPE(ExtPtfm_OtherStateType),      INTENT(IN   )  :: OtherState  !< Other states at t
   TYPE(ExtPtfm_MiscVarType),         INTENT(INOUT)  :: m           !< Misc variables for optimization (not copied in glue code)
   TYPE(ExtPtfm_ConstraintStateType), INTENT(  OUT)  :: Z_residual  !< Residual of the constraint state functions using
                                                                    !!     the input values described above
   INTEGER(IntKi),                    INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                      INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ""
   ! Solve for the residual of the constraint state functions here:
   Z_residual%DummyConstrState = 0.0_ReKi

END SUBROUTINE ExtPtfm_CalcConstrStateResidual
!----------------------------------------------------------------------------------------------------------------------------------

!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! ###### The following four routines are Jacobian routines for linearization capabilities #######
! If the module does not implement them, set ErrStat = ErrID_Fatal in ExtPtfm_Init() when InitInp%Linearize is .true.
!----------------------------------------------------------------------------------------------------------------------------------
!> Routine to compute the Jacobians of the output (Y), continuous- (X), discrete- (Xd), and constraint-state (Z) functions
!! with respect to the inputs (u). The partial derivatives dY/du, dX/du, dXd/du, and DZ/du are returned.
SUBROUTINE ExtPtfm_JacobianPInput( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg, dYdu, dXdu, dXddu, dZdu)
!..................................................................................................................................

   REAL(DbKi),                         INTENT(IN   ) :: t          !< Time in seconds at operating point
   TYPE(ExtPtfm_InputType),            INTENT(IN   ) :: u          !< Inputs at operating point (may change to inout if a mesh copy is required)
   TYPE(ExtPtfm_ParameterType),        INTENT(IN   ) :: p          !< Parameters
   TYPE(ExtPtfm_ContinuousStateType),  INTENT(IN   ) :: x          !< Continuous states at operating point
   TYPE(ExtPtfm_DiscreteStateType),    INTENT(IN   ) :: xd         !< Discrete states at operating point
   TYPE(ExtPtfm_ConstraintStateType),  INTENT(IN   ) :: z          !< Constraint states at operating point
   TYPE(ExtPtfm_OtherStateType),       INTENT(IN   ) :: OtherState !< Other states at operating point
   TYPE(ExtPtfm_OutputType),           INTENT(IN   ) :: y          !< Output (change to inout if a mesh copy is required); 
                                                                   !!   Output fields are not used by this routine, but type is   
                                                                   !!   available here so that mesh parameter information (i.e.,  
                                                                   !!   connectivity) does not have to be recalculated for dYdu.
   TYPE(ExtPtfm_MiscVarType),          INTENT(INOUT) :: m          !< Misc/optimization variables
   INTEGER(IntKi),                     INTENT(  OUT) :: ErrStat    !< Error status of the operation
   CHARACTER(*),                       INTENT(  OUT) :: ErrMsg     !< Error message if ErrStat /= ErrID_None
   REAL(ReKi), ALLOCATABLE, OPTIONAL,  INTENT(INOUT) :: dYdu(:,:)  !< Partial derivatives of output functions (Y) with respect 
                                                                   !!   to the inputs (u) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,  INTENT(INOUT) :: dXdu(:,:)  !< Partial derivatives of continuous state functions (X) with 
                                                                   !!   respect to the inputs (u) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,  INTENT(INOUT) :: dXddu(:,:) !< Partial derivatives of discrete state functions (Xd) with 
                                                                   !!   respect to the inputs (u) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,  INTENT(INOUT) :: dZdu(:,:)  !< Partial derivatives of constraint state functions (Z) with 
                                                                   !!   respect to the inputs (u) [intent in to avoid deallocation]
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   IF ( PRESENT( dYdu ) ) THEN
      ! allocate and set dYdu
      if (.not. allocated(dYdu)) then
          call AllocAry(dYdu, 6, 18, 'dYdu', ErrStat, ErrMsg); if(Failed()) return
      end if
      dYdu(1:6,1:18) = p%DMat(1:6,1:18)
   END IF
   IF ( PRESENT( dXdu ) ) THEN
      ! allocate and set dXdu
      if (.not. allocated(dXdu)) then
          call AllocAry(dXdu, 2*p%nCB, 18, 'dXdu', ErrStat, ErrMsg); if(Failed()) return
      end if
      dXdu(1:2*p%nCB,1:18) = p%DMat(1:2*p%nCB,1:18)
   END IF
   IF ( PRESENT( dXddu ) ) THEN
   END IF
   IF ( PRESENT( dZdu ) ) THEN
   END IF
CONTAINS
    logical function Failed()
        CALL SetErrStatSimple(ErrStat, ErrMsg, 'ExtPtfm_JacobianPInput')
        Failed =  ErrStat >= AbortErrLev
    end function Failed
END SUBROUTINE ExtPtfm_JacobianPInput
!----------------------------------------------------------------------------------------------------------------------------------
!> Routine to compute the Jacobians of the output (Y), continuous- (X), discrete- (Xd), and constraint-state (Z) functions
!! with respect to the continuous states (x). The partial derivatives dY/dx, dX/dx, dXd/dx, and DZ/dx are returned.
SUBROUTINE ExtPtfm_JacobianPContState( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg, dYdx, dXdx, dXddx, dZdx )
!..................................................................................................................................
   REAL(DbKi),                         INTENT(IN   ) :: t          !< Time in seconds at operating point
   TYPE(ExtPtfm_InputType),            INTENT(IN   ) :: u          !< Inputs at operating point (may change to inout if a mesh copy is required)
   TYPE(ExtPtfm_ParameterType),        INTENT(IN   ) :: p          !< Parameters
   TYPE(ExtPtfm_ContinuousStateType),  INTENT(IN   ) :: x          !< Continuous states at operating point
   TYPE(ExtPtfm_DiscreteStateType),    INTENT(IN   ) :: xd         !< Discrete states at operating point
   TYPE(ExtPtfm_ConstraintStateType),  INTENT(IN   ) :: z          !< Constraint states at operating point
   TYPE(ExtPtfm_OtherStateType),       INTENT(IN   ) :: OtherState !< Other states at operating point
   TYPE(ExtPtfm_OutputType),           INTENT(IN   ) :: y          !< Output (change to inout if a mesh copy is required); 
                                                                   !!   Output fields are not used by this routine, but type is   
                                                                   !!   available here so that mesh parameter information (i.e.,  
                                                                   !!   connectivity) does not have to be recalculated for dYdx.
   TYPE(ExtPtfm_MiscVarType),          INTENT(INOUT) :: m          !< Misc/optimization variables
   INTEGER(IntKi),                     INTENT(  OUT) :: ErrStat    !< Error status of the operation
   CHARACTER(*),                       INTENT(  OUT) :: ErrMsg     !< Error message if ErrStat /= ErrID_None
   REAL(ReKi), ALLOCATABLE, OPTIONAL,  INTENT(INOUT) :: dYdx(:,:)  !< Partial derivatives of output functions
                                                                   !!   (Y) with respect to the continuous
                                                                   !!   states (x) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,  INTENT(INOUT) :: dXdx(:,:)  !< Partial derivatives of continuous state
                                                                   !!   functions (X) with respect to
                                                                   !!   the continuous states (x) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,  INTENT(INOUT) :: dXddx(:,:) !< Partial derivatives of discrete state
                                                                   !!   functions (Xd) with respect to
                                                                   !!   the continuous states (x) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,  INTENT(INOUT) :: dZdx(:,:)  !< Partial derivatives of constraint state
                                                                   !!   functions (Z) with respect to
                                                                   !!   the continuous states (x) [intent in to avoid deallocation]
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   IF ( PRESENT( dYdx ) ) THEN
      ! allocate and set dYdx
      if (.not. allocated(dYdx)) then
          call AllocAry(dYdx, 6, 2*p%nCB, 'dYdx', ErrStat, ErrMsg); if(Failed()) return
      end if
      dYdx(1:6,1:2*p%nCB) = p%CMat(1:6, 1:2*p%nCB)
   END IF
   IF ( PRESENT( dXdx ) ) THEN
      ! allocate and set dXdx
      if (.not. allocated(dXdx)) then
          call AllocAry(dXdx, 2*p%nCB, 2*p%nCB, 'dXdx', ErrStat, ErrMsg); if(Failed()) return
      end if
      dXdx(1:2*p%nCB,1:2*p%nCB) = p%AMat(1:2*p%nCB,1:2*p%nCB)
   END IF
   IF ( PRESENT( dXddx ) ) THEN
   END IF
   IF ( PRESENT( dZdx ) ) THEN
   END IF
CONTAINS
    logical function Failed()
        CALL SetErrStatSimple(ErrStat, ErrMsg, 'ExtPtfm_JacobianPInput')
        Failed =  ErrStat >= AbortErrLev
    end function Failed
END SUBROUTINE ExtPtfm_JacobianPContState
!----------------------------------------------------------------------------------------------------------------------------------
!> Routine to compute the Jacobians of the output (Y), continuous- (X), discrete- (Xd), and constraint-state (Z) functions
!! with respect to the discrete states (xd). The partial derivatives dY/dxd, dX/dxd, dXd/dxd, and DZ/dxd are returned.
SUBROUTINE ExtPtfm_JacobianPDiscState( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg, dYdxd, dXdxd, dXddxd, dZdxd )
!..................................................................................................................................

   REAL(DbKi),                                INTENT(IN   )           :: t          !< Time in seconds at operating point
   TYPE(ExtPtfm_InputType),                   INTENT(IN   )           :: u          !< Inputs at operating point (may change to inout if a mesh copy is required)
   TYPE(ExtPtfm_ParameterType),               INTENT(IN   )           :: p          !< Parameters
   TYPE(ExtPtfm_ContinuousStateType),         INTENT(IN   )           :: x          !< Continuous states at operating point
   TYPE(ExtPtfm_DiscreteStateType),           INTENT(IN   )           :: xd         !< Discrete states at operating point
   TYPE(ExtPtfm_ConstraintStateType),         INTENT(IN   )           :: z          !< Constraint states at operating point
   TYPE(ExtPtfm_OtherStateType),              INTENT(IN   )           :: OtherState !< Other states at operating point
   TYPE(ExtPtfm_OutputType),                  INTENT(IN   )           :: y          !< Output (change to inout if a mesh copy is required); 
                                                                                    !!   Output fields are not used by this routine, but type is   
                                                                                    !!   available here so that mesh parameter information (i.e.,  
                                                                                    !!   connectivity) does not have to be recalculated for dYdxd.
   TYPE(ExtPtfm_MiscVarType),                 INTENT(INOUT)           :: m          !< Misc/optimization variables
   INTEGER(IntKi),                            INTENT(  OUT)           :: ErrStat    !< Error status of the operation
   CHARACTER(*),                              INTENT(  OUT)           :: ErrMsg     !< Error message if ErrStat /= ErrID_None
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dYdxd(:,:) !< Partial derivatives of output functions
                                                                                    !!  (Y) with respect to the discrete
                                                                                    !!  states (xd) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dXdxd(:,:) !< Partial derivatives of continuous state
                                                                                    !!   functions (X) with respect to the
                                                                                    !!   discrete states (xd) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dXddxd(:,:)!< Partial derivatives of discrete state
                                                                                    !!   functions (Xd) with respect to the
                                                                                    !!   discrete states (xd) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dZdxd(:,:) !< Partial derivatives of constraint state
                                                                                    !!   functions (Z) with respect to the
                                                                                    !!   discrete states (xd) [intent in to avoid deallocation]
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   IF ( PRESENT( dYdxd ) ) THEN
      ! Calculate the partial derivative of the output functions (Y) with respect to the discrete states (xd) here:
      ! allocate and set dYdxd
   END IF
   IF ( PRESENT( dXdxd ) ) THEN
      ! Calculate the partial derivative of the continuous state functions (X) with respect to the discrete states (xd) here:
      ! allocate and set dXdxd
   END IF

   IF ( PRESENT( dXddxd ) ) THEN
      ! Calculate the partial derivative of the discrete state functions (Xd) with respect to the discrete states (xd) here:
      ! allocate and set dXddxd
   END IF
   IF ( PRESENT( dZdxd ) ) THEN
      ! Calculate the partial derivative of the constraint state functions (Z) with respect to the discrete states (xd) here:
      ! allocate and set dZdxd
   END IF
END SUBROUTINE ExtPtfm_JacobianPDiscState
!----------------------------------------------------------------------------------------------------------------------------------
!> Routine to compute the Jacobians of the output (Y), continuous- (X), discrete- (Xd), and constraint-state (Z) functions
!! with respect to the constraint states (z). The partial derivatives dY/dz, dX/dz, dXd/dz, and DZ/dz are returned.
SUBROUTINE ExtPtfm_JacobianPConstrState( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg, dYdz, dXdz, dXddz, dZdz )
!..................................................................................................................................
   REAL(DbKi),                                INTENT(IN   )           :: t          !< Time in seconds at operating point
   TYPE(ExtPtfm_InputType),                   INTENT(IN   )           :: u          !< Inputs at operating point (may change to inout if a mesh copy is required)
   TYPE(ExtPtfm_ParameterType),               INTENT(IN   )           :: p          !< Parameters
   TYPE(ExtPtfm_ContinuousStateType),         INTENT(IN   )           :: x          !< Continuous states at operating point
   TYPE(ExtPtfm_DiscreteStateType),           INTENT(IN   )           :: xd         !< Discrete states at operating point
   TYPE(ExtPtfm_ConstraintStateType),         INTENT(IN   )           :: z          !< Constraint states at operating point
   TYPE(ExtPtfm_OtherStateType),              INTENT(IN   )           :: OtherState !< Other states at operating point
   TYPE(ExtPtfm_OutputType),                  INTENT(IN   )           :: y          !< Output (change to inout if a mesh copy is required); 
                                                                                    !!   Output fields are not used by this routine, but type is   
                                                                                    !!   available here so that mesh parameter information (i.e.,  
                                                                                    !!   connectivity) does not have to be recalculated for dYdz.
   TYPE(ExtPtfm_MiscVarType),                 INTENT(INOUT)           :: m          !< Misc/optimization variables
   INTEGER(IntKi),                            INTENT(  OUT)           :: ErrStat    !< Error status of the operation
   CHARACTER(*),                              INTENT(  OUT)           :: ErrMsg     !< Error message if ErrStat /= ErrID_None
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dYdz(:,:)  !< Partial derivatives of output
                                                                                    !!  functions (Y) with respect to the
                                                                                    !!  constraint states (z) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dXdz(:,:)  !< Partial derivatives of continuous
                                                                                    !!  state functions (X) with respect to
                                                                                    !!  the constraint states (z) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dXddz(:,:) !< Partial derivatives of discrete state
                                                                                    !!  functions (Xd) with respect to the
                                                                                    !!  constraint states (z) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dZdz(:,:)  !< Partial derivatives of constraint
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   IF ( PRESENT( dYdz ) ) THEN
      ! Calculate the partial derivative of the output functions (Y) with respect to the constraint states (z) here:
      ! allocate and set dYdz
   END IF
   IF ( PRESENT( dXdz ) ) THEN
      ! Calculate the partial derivative of the continuous state functions (X) with respect to the constraint states (z) here:
      ! allocate and set dXdz
   END IF
   IF ( PRESENT( dXddz ) ) THEN
      ! Calculate the partial derivative of the discrete state functions (Xd) with respect to the constraint states (z) here:
      ! allocate and set dXddz
   END IF
   IF ( PRESENT( dZdz ) ) THEN
      ! Calculate the partial derivative of the constraint state functions (Z) with respect to the constraint states (z) here:
      ! allocate and set dZdz
   END IF
END SUBROUTINE ExtPtfm_JacobianPConstrState
!----------------------------------------------------------------------------------------------------------------------------------
!> Routine to pack the data structures representing the operating points into arrays for linearization.
SUBROUTINE ExtPtfm_GetOP( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg, u_op, y_op, x_op, dx_op, xd_op, z_op )
   REAL(DbKi),                           INTENT(IN   )           :: t          !< Time in seconds at operating point
   TYPE(ExtPtfm_InputType),              INTENT(IN   )           :: u          !< Inputs at operating point (may change to inout if a mesh copy is required)
   TYPE(ExtPtfm_ParameterType),          INTENT(IN   )           :: p          !< Parameters
   TYPE(ExtPtfm_ContinuousStateType),    INTENT(IN   )           :: x          !< Continuous states at operating point
   TYPE(ExtPtfm_DiscreteStateType),      INTENT(IN   )           :: xd         !< Discrete states at operating point
   TYPE(ExtPtfm_ConstraintStateType),    INTENT(IN   )           :: z          !< Constraint states at operating point
   TYPE(ExtPtfm_OtherStateType),         INTENT(IN   )           :: OtherState !< Other states at operating point
   TYPE(ExtPtfm_OutputType),             INTENT(IN   )           :: y          !< Output at operating point
   TYPE(ExtPtfm_MiscVarType),            INTENT(INOUT)           :: m          !< Misc/optimization variables
   INTEGER(IntKi),                       INTENT(  OUT)           :: ErrStat    !< Error status of the operation
   CHARACTER(*),                         INTENT(  OUT)           :: ErrMsg     !< Error message if ErrStat /= ErrID_None
   REAL(ReKi), ALLOCATABLE, OPTIONAL,    INTENT(INOUT)           :: u_op(:)    !< values of linearized inputs
   REAL(ReKi), ALLOCATABLE, OPTIONAL,    INTENT(INOUT)           :: y_op(:)    !< values of linearized outputs
   REAL(ReKi), ALLOCATABLE, OPTIONAL,    INTENT(INOUT)           :: x_op(:)    !< values of linearized continuous states
   REAL(ReKi), ALLOCATABLE, OPTIONAL,    INTENT(INOUT)           :: dx_op(:)   !< values of first time derivatives of linearized continuous states
   REAL(ReKi), ALLOCATABLE, OPTIONAL,    INTENT(INOUT)           :: xd_op(:)   !< values of linearized discrete states
   REAL(ReKi), ALLOCATABLE, OPTIONAL,    INTENT(INOUT)           :: z_op(:)    !< values of linearized constraint states
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''

   IF ( PRESENT( u_op ) ) THEN
   END IF

   IF ( PRESENT( y_op ) ) THEN
   END IF

   IF ( PRESENT( x_op ) ) THEN
   END IF

   IF ( PRESENT( dx_op ) ) THEN
   END IF

   IF ( PRESENT( xd_op ) ) THEN
   END IF
   
   IF ( PRESENT( z_op ) ) THEN
   END IF

END SUBROUTINE ExtPtfm_GetOP
!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

END MODULE ExtPtfm_MCKF
!**********************************************************************************************************************************
