!**********************************************************************************************************************************
!> ## ExtPtfm_MCKF
!! The ExtPtfm_MCKF and ExtPtfm_MCKF_Types modules make up a template for creating user-defined calculations in the FAST Modularization
!! Framework. ExtPtfm_MCKF_Types will be auto-generated by the FAST registry program, based on the variables specified in the
!! ExtPtfm_MCKF_Registry.txt file.
!!
!! This template file contains comments in the style required for Doxygen, and it contains methods for handling errors.
!!
!! "ExtPtfm_MCKF" should be replaced with the name of your module. Example: ElastoDyn \n
!! "ExtPtfm" (in ExtPtfm_*) should be replaced with the module name or an abbreviation of it. Example: ED
! ..................................................................................................................................
!! ## LICENSING
!! Copyright (C) 2012-2013, 2015-2016  National Renewable Energy Laboratory
!!
!!    This file is part of ExtPtfm_MCKF.
!!
!! Licensed under the Apache License, Version 2.0 (the "License");
!! you may not use this file except in compliance with the License.
!! You may obtain a copy of the License at
!!
!!     http://www.apache.org/licenses/LICENSE-2.0
!!
!! Unless required by applicable law or agreed to in writing, software
!! distributed under the License is distributed on an "AS IS" BASIS,
!! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!! See the License for the specific language governing permissions and
!! limitations under the License.
!**********************************************************************************************************************************
MODULE ExtPtfm_MCKF

   USE ExtPtfm_MCKF_Types
   USE NWTC_Library

   IMPLICIT NONE

   PRIVATE

   TYPE(ProgDesc), PARAMETER :: ExtPtfm_Ver = ProgDesc( 'ExtPtfm_MCKF', '', '' ) !< module date/version information


      ! ..... Public Subroutines ...................................................................................................

   PUBLIC :: ExtPtfm_Init                           !  Initialization routine
   PUBLIC :: ExtPtfm_End                            !  Ending routine (includes clean up)

   PUBLIC :: ExtPtfm_UpdateStates                   !  Loose coupling routine for solving for constraint states, integrating
                                                    !    continuous states, and updating discrete states
   PUBLIC :: ExtPtfm_CalcOutput                     !  Routine for computing outputs

   PUBLIC :: ExtPtfm_CalcConstrStateResidual        !  Tight coupling routine for returning the constraint state residual
   PUBLIC :: ExtPtfm_CalcContStateDeriv             !  Tight coupling routine for computing derivatives of continuous states
   PUBLIC :: ExtPtfm_UpdateDiscState                !  Tight coupling routine for updating discrete states

   PUBLIC :: ExtPtfm_JacobianPInput                 !  Routine to compute the Jacobians of the output (Y), continuous- (X), discrete-
                                                    !    (Xd), and constraint-state (Z) functions all with respect to the inputs (u)
   PUBLIC :: ExtPtfm_JacobianPContState             !  Routine to compute the Jacobians of the output (Y), continuous- (X), discrete-
                                                    !    (Xd), and constraint-state (Z) functions all with respect to the continuous
                                                    !    states (x)
   PUBLIC :: ExtPtfm_JacobianPDiscState             !  Routine to compute the Jacobians of the output (Y), continuous- (X), discrete-
                                                    !    (Xd), and constraint-state (Z) functions all with respect to the discrete
                                                    !    states (xd)
   PUBLIC :: ExtPtfm_JacobianPConstrState           !  Routine to compute the Jacobians of the output (Y), continuous- (X), discrete-
                                                    !    (Xd), and constraint-state (Z) functions all with respect to the constraint
                                                    !    states (z)
   
   PUBLIC :: ExtPtfm_GetOP                          !  Routine to get the operating-point values for linearization (from data structures to arrays)

CONTAINS
   
!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!> Helper functions for the module
subroutine disp2r8(u,varname,a)
    integer,intent(in) ::u
    character(len=*),intent(in)::varname
    real(ReKi),intent(in),dimension(:,:) ::a
    integer :: n, m,i
    character(len=20) :: fmt
    character(len=*),parameter :: RFMT='EN13.3E2'
    n=size(a,1)
    m=size(a,2)
    if (n>0 .and. m>0) then
        write(u,"(A,A)") varname,"=["
        write(fmt,*) m
        do i=1,n-1
            write(u,"("//adjustl(fmt)//RFMT//")") a(i,:)
        enddo
        i=n
        write(u,"("//trim(fmt)//RFMT//",A)") a(i,:), "  ];"
    else
        write(u,'(A,A)') varname,'=[];'
    endif
end subroutine

!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!> This routine is called at the start of the simulation to perform initialization steps.
!! The parameters are set here and not changed during the simulation.
!! The initial states and initial guess for the input are defined.
SUBROUTINE ExtPtfm_Init( InitInp, u, p, x, xd, z, OtherState, y, m, Interval, InitOut, ErrStat, ErrMsg )
!..................................................................................................................................
   TYPE(ExtPtfm_InitInputType),       INTENT(IN   )  :: InitInp     !< Input data for initialization routine
   TYPE(ExtPtfm_InputType),           INTENT(  OUT)  :: u           !< An initial guess for the input; input mesh must be defined
   TYPE(ExtPtfm_ParameterType),       INTENT(  OUT)  :: p           !< Parameters
   TYPE(ExtPtfm_ContinuousStateType), INTENT(  OUT)  :: x           !< Initial continuous states
   TYPE(ExtPtfm_DiscreteStateType),   INTENT(  OUT)  :: xd          !< Initial discrete states
   TYPE(ExtPtfm_ConstraintStateType), INTENT(  OUT)  :: z           !< Initial guess of the constraint states
   TYPE(ExtPtfm_OtherStateType),      INTENT(  OUT)  :: OtherState  !< Initial other states (logical, etc)
   TYPE(ExtPtfm_OutputType),          INTENT(  OUT)  :: y           !< Initial system outputs (outputs are not calculated;
                                                                    !!   only the output mesh is initialized)
   TYPE(ExtPtfm_MiscVarType),         INTENT(  OUT)  :: m           !< Misc variables for optimization (not copied in glue code)
   REAL(DbKi),                        INTENT(INOUT)  :: Interval    !< Coupling interval in seconds: the rate that
                                                                    !!   (1) ExtPtfm_UpdateStates() is called in loose coupling &
                                                                    !!   (2) ExtPtfm_UpdateDiscState() is called in tight coupling.
                                                                    !!   Input is the suggested time from the glue code;
                                                                    !!   Output is the actual coupling interval that will be used
                                                                    !!   by the glue code.
   TYPE(ExtPtfm_InitOutputType),      INTENT(  OUT)  :: InitOut     !< Output for initialization routine
   INTEGER(IntKi),                    INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                      INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None
   ! local variables
   INTEGER(IntKi)                                    :: I           ! Loop counter
   INTEGER(IntKi)                                    :: NumOuts     ! Number of outputs; would probably be in the parameter type
   INTEGER(IntKi)                                    :: ErrStat2    ! Local error status
   CHARACTER(ErrMsgLen)                              :: ErrMsg2     ! Local error message
   CHARACTER(*), PARAMETER                           :: RoutineName = 'ExtPtfm_Init'
   ! Initialize variables
   ErrStat = ErrID_None
   ErrMsg  = ""
   ! Initialize the NWTC Subroutine Library
   call NWTC_Init( )
   ! Display the module information
   call DispNVD( ExtPtfm_Ver )
   ! set parameters
   p%NumOuts = 0   
   p%nTot = -1   
   p%nCB = -1   
   call ReadPrimaryFile( InitInp%InputFile, p, ErrStat2, ErrMsg2 ); if(Failed()) return
   write(*,*)'Total number of DOF :',p%nTot
   write(*,*)'Number of CB modes  :',p%nCB
   write(*,*)'Number of time steps:',p%nPtfmFt

   ! Set the constant state matrices A,B,C,D
   call SetStateMatrices(p, ErrStat2, ErrMsg2)
  
   ! Allocate and init Continuous states
   call AllocAry( x%x2    , p%nCB,'CB DOF positions' , ErrStat2,ErrMsg2); if(Failed()) return
   call AllocAry( x%x2dot , p%nCB,'CB DOF velocities', ErrStat2,ErrMsg2); if(Failed()) return
   do I=1,p%nCB; x%x2   (I)=0; end do
   do I=1,p%nCB; x%x2dot(I)=0; end do
   ! Other states
   xd%DummyDiscState          = 0.0_ReKi
   z%DummyConstrState         = 0.0_ReKi
   OtherState%DummyOtherState = 0.0_ReKi

   ! Initialize Misc Variables:
   m%Indx = 1 ! used to optimize interpolation of loads in time
   call AllocAry( m%PtfmFt, p%nTot,'Loads at t', ErrStat2,ErrMsg2); if(Failed()) return
   do I=1,p%nTot; m%PtfmFt(I)=0; end do
   
   ! Define initial guess (set up mesh first) for the system inputs here:
   call Init_meshes(u, y, ErrStat2, ErrMsg2); if(Failed()) return

   ! Define system output initializations (set up mesh) here:
   call AllocAry( y%WriteOutput,        p%NumOuts,'WriteOutput',   ErrStat2,ErrMsg2); if(Failed()) return
   call AllocAry(InitOut%WriteOutputHdr,p%NumOuts,'WriteOutputHdr',ErrStat2,ErrMsg2); if(Failed()) return
   call AllocAry(InitOut%WriteOutputUnt,p%NumOuts,'WriteOutputUnt',ErrStat2,ErrMsg2); if(Failed()) return

   InitOut%Ver = ExtPtfm_Ver
      
   if (InitInp%Linearize) then
      ! If the module does not implement the four Jacobian routines at the end of this template, or the module cannot
      ! linearize with the features that are enabled, stop the simulation if InitInp%Linearize is true.
      CALL SetErrStat( ErrID_Fatal, 'ExtPtfm_MCKF cannot perform linearization analysis.', ErrStat, ErrMsg, RoutineName)
      ! Otherwise, if the module does allow linearization, return the appropriate Jacobian row/column names and rotating-frame flags here:   
      ! Allocate and set these variables: InitOut%LinNames_y, InitOut%LinNames_x, InitOut%LinNames_xd, InitOut%LinNames_z, InitOut%LinNames_u 
      ! Allocate and set these variables: InitOut%RotFrame_y, InitOut%RotFrame_x, InitOut%RotFrame_xd, InitOut%RotFrame_z, InitOut%RotFrame_u 
   end if
CONTAINS
    logical function Failed()
        CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
        Failed =  ErrStat >= AbortErrLev
    end function Failed
END SUBROUTINE ExtPtfm_Init

!----------------------------------------------------------------------------------------------------------------------------------
!> Helper functions to read primary file
real(ReKi) function ReadFloatFromStr(s, VarName, iStat, Msg ) result(myfloat)
   character(len=*), intent(in)    :: s
   character(len=*), intent(in)    :: VarName
   character(len=*), intent(inout) :: Msg
   integer, intent(out)            :: iStat
   read(s,*, iostat=iStat ) myfloat 
   if (iStat /= 0) then
      iStat=ErrID_Fatal
      Msg = trim(Msg)//'Error extracting float while reading '//VarName
   endif
end function ReadFloatFromStr
integer function ReadIntFromStr(s, VarName, iStat, Msg ) result(myint)
   character(len=*), intent(in)    :: s
   character(len=*), intent(in)    :: VarName
   character(len=*), intent(inout) :: Msg
   integer, intent(out)            :: iStat
   read(s,*, iostat=iStat ) myint 
   if (iStat /= 0) then
      iStat=ErrID_Fatal
      Msg = trim(Msg)//'Error extracting integer while reading '//VarName
   endif
end function ReadIntFromStr
subroutine ReadRealMatrix(fid, FileName, Mat, VarName, nLines,nRows, iStat, Msg, iLine )
   integer, intent(in)                     :: fid
   real(ReKi), dimension(:,:), allocatable :: Mat
   character(len=*), intent(in)            :: FileName
   character(len=*), intent(in)            :: VarName
   integer, intent(in)                     :: nLines
   integer, intent(in)                     :: nRows
   integer, intent(out)                    :: iStat
   integer, intent(inout)                  :: iLine
   character(len=*), intent(inout)         :: Msg
   ! local variables
   integer :: i
   call allocAry( Mat, nLines, nRows, 'p%Stff',  iStat, Msg); 
   if (iStat /= 0) return
   !Read Stiffness
   DO I =1,nLines
      iLine=iLine+1
      ! TODO use ReadCAryFromStr when available in the NWTCIO, it performs more checks
      CALL ReadAry( fid, FileName, Mat(I,:), nRows, trim(VarName)//' Line '//Num2LStr(iLine), VarName, iStat, Msg)
      if (iStat /= 0) return
   ENDDO
end subroutine
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE ReadPrimaryFile( InputFile, p, ErrStat, ErrMsg )
!..................................................................................................................................
   ! Passed variables
   CHARACTER(*),                INTENT(IN)    :: InputFile                           !< Name of the file containing the primary input data
   TYPE(ExtPtfm_ParameterType), INTENT(INOUT) :: p                                   !< All the parameter matrices stored in this input file
   INTEGER(IntKi),              INTENT(OUT)   :: ErrStat                             !< Error status                              
   CHARACTER(*),                INTENT(OUT)   :: ErrMsg                              !< Error message
   ! Local variables:
   REAL(ReKi), dimension(:),allocatable :: TmpAry                                 ! temporary array for reading row from file
   INTEGER(IntKi)                       :: I                                         ! loop counter
   INTEGER(IntKi)                       :: UnIn                                      ! Unit number for reading file
   INTEGER(IntKi)                       :: iLine                                     ! Current position in file
   INTEGER(IntKi)                       :: ErrStat2                                  ! Temporary Error status
   CHARACTER(ErrMsgLen)                 :: ErrMsg2                                   ! Temporary Error message
   CHARACTER(200)                       :: Line                                      ! Temporary storage of a line from the input file (to compare with "default")
   CHARACTER(200)                       :: Line2                                     ! Temporary storage of a line from the input file (to compare with "default")
   CHARACTER(*), PARAMETER              :: RoutineName = 'ReadPrimaryFile'
   ! Initialize some variables:
   ErrStat = ErrID_None
   ErrMsg  = ""
   !CALL GetPath( InputFile, PriPath )     ! Input files will be relative to the path where the primary input file is located.
   
   ! Get an available unit number for the file.
   CALL GetNewUnit( UnIn, ErrStat2, ErrMsg2 );               if(Failed()) return
   ! Open the Primary input file.
   CALL OpenFInpFile ( UnIn, InputFile, ErrStat2, ErrMsg2 ); if(Failed()) return
   iLine=1
   !-------------------------- Read the first two lines
   CALL ReadStr( UnIn, InputFile, Line, 'Line'//Num2LStr(iLine), 'External Platform MCKF file', ErrStat2, ErrMsg2)
   if(Failed()) return
   iLine=iLine+1
   CALL ReadStr( UnIn, InputFile, Line2, 'Line'//Num2LStr(iLine), 'External Platform MCKF file', ErrStat2, ErrMsg2)
   if(Failed()) return
   iLine=iLine+1
   call CONV2UC(Line)
   call CONV2UC(Line2)
   call cleanup()
   !-------------------------- Detecting file format
   if (index(Line2,'#MASS')==1) then
       write(*,*) 'File detected as Guyan ASCII file format: '//trim(InputFile)
       call ReadGuyanASCII()
   else if (index(Line2,'FLEX 5 FORMAT')>=1) then
       write(*,*) 'File detected as FLEX ASCII file format: '//trim(InputFile)
       call ReadFlexASCII()
   endif

   ! Checking that everyting was correctly read and set
   call CheckAllInputsRead()
   if(Failed()) return
   
   return

CONTAINS
    !> 
    logical function Failed()
        CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
        Failed =  ErrStat >= AbortErrLev
        if(Failed) call cleanup()
    end function Failed
    
    !> 
    subroutine cleanup()
        close( UnIn )
        if (allocated(TmpAry)) deallocate(TmpAry)
    end subroutine cleanup
    
    !> Checks that all inputs were correctly read
    subroutine CheckAllInputsRead()
        if (ErrStat2/=0) return
        if (p%nTot<0)                   then ; ErrStat2=ErrID_Fatal; ErrMsg2='ExtPtfm_MCKF, the total number of DOF was not set'; endif
        if (.not.allocated(p%PtfmAM))   then ; ErrStat2=ErrID_Fatal; ErrMsg2='ExtPtfm_MCKF, the mass matrix was not allocated.' ; endif
        if (.not.allocated(p%Stff))     then ; ErrStat2=ErrID_Fatal; ErrMsg2='ExtPtfm_MCKF, the stiffness matrix was not allocated.' ; endif
        if (.not.allocated(p%Damp))     then ; ErrStat2=ErrID_Fatal; ErrMsg2='ExtPtfm_MCKF, the damping matrix was not allocated.' ; endif
        if (.not.allocated(p%PtfmFt))   then ; ErrStat2=ErrID_Fatal; ErrMsg2='ExtPtfm_MCKF, the loads were not allocated.';endif
        if (.not.allocated(p%PtfmFt_t)) then ; ErrStat2=ErrID_Fatal; ErrMsg2='ExtPtfm_MCKF, the time vector was not allocated.'; endif
    end subroutine CheckAllInputsRead

   !> Reads a FLEX ASCII file for Guyan or CraigBampton reductions
   SUBROUTINE ReadFlexASCII()
       logical :: AllSet 
       REAL(ReKi) :: dt !< time step
       REAL(ReKi) :: T  !< total simulation time

       AllSet = .FALSE.
       T=-1
       dt=-1
       ! Get an available unit number for the file.
       CALL GetNewUnit( UnIn, ErrStat2, ErrMsg2 );               if ( ErrStat2 /= 0 ) return
       ! Open the Primary input file.
       CALL OpenFInpFile ( UnIn, InputFile, ErrStat2, ErrMsg2 ); if ( ErrStat2 /= 0 ) return

       ! --- Reading file line by line
       ErrStat2=0
       iLine=0
       do while (ErrStat2==0)
           iLine=iLine+1
           read(UnIn,'(A)', iostat=ErrStat2) Line
           if (ErrStat2/=0) then
               if (ErrStat2 < 0) then
                   ErrStat2=0 ! End of file is fine
               else
                   ErrMsg2='Error while reading file '//trim(InputFile)// ' line '//Num2LStr(iLine)
               endif
               exit
           endif
           ! Line content is analyzed as case incensitive 
           call Conv2UC(Line)
           if (index(Line,'!DIMENSION')==1) then
               p%nTot = ReadIntFromStr(Line(12:), '`dimension`, line '//Num2LStr(iLine), ErrStat2, ErrMsg2); if (ErrStat2 /= 0) exit
               p%nCB=p%nTot-6

           else if (index(Line,'!TIME INCREMENT IN SIMULATION:')==1) then
               dt =  ReadFloatFromStr(Line(31:), '`time increment`, line '//Num2LStr(iLine), ErrStat2, ErrMsg2); if (ErrStat2 /= 0) exit

           else if (index(Line,'!TOTAL SIMULATION TIME IN FILE:')==1) then
               T =  ReadFloatFromStr(Line(32:), '`total simulation time`, line '//Num2LStr(iLine), ErrStat2, ErrMsg2 ); if (ErrStat2 /= 0) exit

           else if (index(Line,'!MASS MATRIX')==1) then
               iLine=iLine+1
               CALL ReadCom( UnIn, InputFile, 'Comment - Line '//Num2LStr(iLine), ErrStat2, ErrMsg2); if (ErrStat2 /= 0) exit
               if (p%nTot<0) exit
               call ReadRealMatrix(UnIn, InputFile, p%PtfmAM, 'Mass Matrix', p%nTot, p%nTot, ErrStat2, ErrMsg2, iLine)

           else if (index(Line,'!STIFFNESS MATRIX')==1) then
               iLine=iLine+1
               CALL ReadCom( UnIn, InputFile, 'Comment - Line '//Num2LStr(iLine), ErrStat2, ErrMsg2);  if (ErrStat2 /= 0) exit
               if (p%nTot<0) exit
               call ReadRealMatrix(UnIn, InputFile, p%Stff, 'Stiffness Matrix', p%nTot, p%nTot, ErrStat2, ErrMsg2, iLine)

           else if (index(Line,'!DAMPING MATRIX')==1) then
               iLine=iLine+1
               CALL ReadCom( UnIn, InputFile, 'Comment - Line '//Num2LStr(iLine), ErrStat2, ErrMsg2); if (ErrStat2 /= 0) exit
               if (p%nTot<0) exit
               call ReadRealMatrix(UnIn, InputFile, p%Damp, 'Damping Matrix', p%nTot, p%nTot, ErrStat2, ErrMsg2, iLine)

           else if (index(Line,'!LOADING AND WAVE ELEVATION')==1) then
               iLine=iLine+1
               CALL ReadCom( UnIn, InputFile, 'Comment - Line '//Num2LStr(iLine), ErrStat2, ErrMsg2)
               if (ErrStat2 /= 0) exit
               p%nPtfmFt = nint(T/dt)+1
               if (p%nTot<0) exit
               call allocAry( p%PtfmFt,   max(1,p%nPtfmFt), p%nTot, 'p%PtfmFt',   ErrStat2, ErrMsg2); if (ErrStat2 /= 0) exit
               call allocAry( p%PtfmFt_t, max(1,p%nPtfmFt),         'p%PtfmFt_t', ErrStat2, ErrMsg2); if (ErrStat2 /= 0) exit
               if (p%nPtfmFt == 0) then
                  p%PtfmFt   = 0.0_ReKi
                  p%PtfmFt_t = 0.0_ReKi
                  p%nPtfmFt  = 1
               else
                  allocate(TmpAry(1:p%nTot+1))
                  do i=1,p%nPtfmFt
                     iLine=iLine+1
                     call ReadAry( UnIn, InputFile, TmpAry, p%nTot+1, 'PtfmFt - Line: '//Num2LStr(iLine)//' Value: '//trim(Num2LStr(i))//'/'//Num2LStr(p%nPtfmFt), 'PtfmFt time-history', ErrStat2, ErrMsg2)
                     if (ErrStat2 /= 0) exit
                     p%PtfmFt_t(i) = TmpAry(1)
                     p%PtfmFt(i,:) = TmpAry(2:p%nTot+1)
                  end do
               end if

           elseif (index(Line,'!')==1) then
               write(*,*) 'Ignored comment: '//trim(Line)
           else
                ! Ignore unsupported lines
!                write(*,*) 'Ignored line: '//trim(Line)
           endif
       enddo
       close( UnIn )
   END SUBROUTINE ReadFlexASCII

   !> Reads a Guyan ASCII file 
   SUBROUTINE ReadGuyanASCII()
       ! Guyan reduction has 6 DOF, 0 CB DOFs
       p%nCB  = 0
       p%nTot = 6
       ! Get an available unit number for the file.
       CALL GetNewUnit( UnIn, ErrStat2, ErrMsg2 );               if ( ErrStat2 /= 0 ) return
       ! Open the Primary input file.
       CALL OpenFInpFile ( UnIn, InputFile, ErrStat2, ErrMsg2 ); if ( ErrStat2 /= 0 ) return

       !-------------------------- HEADER ---------------------------------------------
       CALL ReadStr( UnIn, InputFile, Line, 'Header line', 'File Header: External Platform MCKF Matrices (line 1)', ErrStat2, ErrMsg2)
       if ( ErrStat2 /= 0 ) return
       !---------------------- MASS MATRIX --------------------------------------
       CALL ReadCom( UnIn, InputFile, 'Section Header: Mass Matrix', ErrStat2, ErrMsg2)
       if ( ErrStat2 /= 0 ) return
       CALL ReadRealMatrix(UnIn, InputFile, p%PtfmAM, 'Mass Matrix', p%nTot, p%nTot, ErrStat2, ErrMsg2, iLine)
       if ( ErrStat2 /= 0 ) return
       !---------------------- DAMPING MATRIX --------------------------------------
       CALL ReadCom( UnIn, InputFile, 'Section Header: Damping Matrix', ErrStat2, ErrMsg2)
       if ( ErrStat2 /= 0 ) return
       CALL ReadRealMatrix(UnIn, InputFile, p%Damp, 'Damping Matrix', p%nTot, p%nTot, ErrStat2, ErrMsg2, iLine)
       if ( ErrStat2 /= 0 ) return
       !---------------------- STIFFNESS MATRIX --------------------------------------
       CALL ReadCom( UnIn, InputFile, 'Section Header: Stiffness Matrix', ErrStat2, ErrMsg2)
       if ( ErrStat2 /= 0 ) return
       CALL ReadRealMatrix(UnIn, InputFile, p%Stff, 'Stiffness Matrix', p%nTot, p%nTot, ErrStat2, ErrMsg2, iLine)
       if ( ErrStat2 /= 0 ) return
       !---------------------- LOAD time-history --------------------------------------
       p%nPtfmFt = 0
       CALL ReadCom( UnIn, InputFile, 'Section Header: Loads time-history', ErrStat2, ErrMsg2)
       CALL ReadCom( UnIn, InputFile, 'Loads time-history table channel names', ErrStat2, ErrMsg2)
       CALL ReadCom( UnIn, InputFile, 'Loads time-history table channel units', ErrStat2, ErrMsg2)
       allocate(TmpAry(1:p%nTot+1))
       if (ErrStat2 < AbortErrLev) then
          ! let's figure out how many rows of data are in the time-history table:
          read( UnIn, *, IOSTAT=ErrStat2 ) TmpAry
          do while (ErrStat2==0)
             p%nPtfmFt = p%nPtfmFt + 1
             read( UnIn, *, IOSTAT=ErrStat2 ) TmpAry
          end do
       end if
       call allocAry( p%PtfmFt,   max(1,p%nPtfmFt), p%nTot, 'p%PtfmFt',   ErrStat2, ErrMsg2); if ( ErrStat2 /= 0 ) return
       call allocAry( p%PtfmFt_t, max(1,p%nPtfmFt),         'p%PtfmFt_t', ErrStat2, ErrMsg2); if ( ErrStat2 /= 0 ) return
       if (p%nPtfmFt == 0) then
          p%PtfmFt = 0.0_ReKi
          p%PtfmFt_t = 0.0_ReKi
          p%nPtfmFt = 1
       else
          rewind(UnIn)
          do i=1,25 ! skip the first 25 rows of the file until we get to the data for the time-history table
             read(UnIn,*,IOSTAT=ErrStat2) line
          end do
          do i=1,p%nPtfmFt
             call ReadAry( UnIn, InputFile, TmpAry, p%nTot+1, 'PtfmFt', 'PtfmFt time-history', ErrStat2, ErrMsg2)
             if ( ErrStat2 /= 0 ) return
             p%PtfmFt_t(i) = TmpAry(1)
             p%PtfmFt(i,:) = TmpAry(2:p%nTot+1)
          end do
       end if
       !---------------------- END OF FILE -----------------------------------------
       close( UnIn )
   END SUBROUTINE ReadGuyanASCII
END SUBROUTINE ReadPrimaryFile      

!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE SetStateMatrices( p, ErrStat, ErrMsg)
!..................................................................................................................................
   TYPE(ExtPtfm_ParameterType), INTENT(INOUT) :: p                                   !< All the parameter matrices stored in this input file
   INTEGER(IntKi),              INTENT(OUT)   :: ErrStat                             !< Error status                              
   CHARACTER(*),                INTENT(OUT)   :: ErrMsg                              !< Error message
   ! Local variables:
   REAL(ReKi)                              :: TmpAry(7)                                 ! temporary array for reading row from file
   INTEGER(IntKi)                          :: I,J                                       ! loop counter
   INTEGER(IntKi)                          :: UnIn                                      ! Unit number for reading file
   INTEGER(IntKi)                          :: nX                                        ! Number of states
   INTEGER(IntKi)                          :: nU                                        ! Number of inputs
   INTEGER(IntKi)                          :: nY                                        ! Number of ouputs
   INTEGER(IntKi)                          :: n1                                        ! Number of interface DOF
   INTEGER(IntKi)                          :: n2                                        ! Number of CB DOF
   INTEGER(IntKi)                          :: ErrStat2                                  ! Temporary Error status
   CHARACTER(ErrMsgLen)                    :: ErrMsg2                                   ! Temporary Error message
   CHARACTER(200)                          :: Line                                      ! Temporary storage of a line from the input file (to compare with "default")
   CHARACTER(200)                          :: Line2                                     ! Temporary storage of a line from the input file (to compare with "default")
   CHARACTER(*), PARAMETER                 :: RoutineName = 'SetStateMatrices'
   real(ReKi), dimension(:,:), allocatable :: I22
   ! Init 
   ErrStat = ErrID_None
   ErrMSg = ""
   nX = 2*p%nCB
   nU = 3*6
   nY = 6
   n1 = 6
   n2 = p%nCB
   if (allocated(p%AMat)) deallocate(p%AMat)
   if (allocated(p%BMat)) deallocate(p%BMat)
   if (allocated(p%CMat)) deallocate(p%CMat)
   if (allocated(p%DMat)) deallocate(p%DMat)
   if (allocated(p%M11))  deallocate(p%M11)
   if (allocated(p%M12))  deallocate(p%M12)
   if (allocated(p%M22))  deallocate(p%M22)
   if (allocated(p%M21))  deallocate(p%M21)
   if (allocated(p%C11))  deallocate(p%C11)
   if (allocated(p%C12))  deallocate(p%C12)
   if (allocated(p%C22))  deallocate(p%C22)
   if (allocated(p%C21))  deallocate(p%C21)
   if (allocated(p%K11))  deallocate(p%C11)
   if (allocated(p%K22))  deallocate(p%C22)
   ! Allocation
   call allocAry(p%AMat, nX, nX, 'p%AMat', ErrStat2, ErrMsg2); if(Failed()) return ; p%AMat(1:nX,1:nX) =0
   call allocAry(p%BMat, nX, nU, 'p%BMat', ErrStat2, ErrMsg2); if(Failed()) return ; p%BMat(1:nX,1:nU) =0
   call allocAry(p%FX  , nX,     'p%FX'  , ErrStat2, ErrMsg2); if(Failed()) return ; p%Fx  (1:nX)      =0
   call allocAry(p%CMat, nY, nX, 'p%CMat', ErrStat2, ErrMsg2); if(Failed()) return ; p%CMat(1:nY,1:nX) =0
   call allocAry(p%DMat, nY, nU, 'p%DMat', ErrStat2, ErrMsg2); if(Failed()) return ; p%DMat(1:nY,1:nU) =0
   call allocAry(p%FY  , nY,     'p%FY'  , ErrStat2, ErrMsg2); if(Failed()) return ; p%FY  (1:nY)      =0
   call allocAry(p%M11 , n1, n1, 'p%M11' , ErrStat2, ErrMsg2); if(Failed()) return ; p%M11 (1:n1,1:n1) =0
   call allocAry(p%K11 , n1, n1, 'p%K11' , ErrStat2, ErrMsg2); if(Failed()) return ; p%K11 (1:n1,1:n1) =0
   call allocAry(p%C11 , n1, n1, 'p%C11' , ErrStat2, ErrMsg2); if(Failed()) return ; p%C11 (1:n1,1:n1) =0
   call allocAry(p%M22 , n2, n2, 'p%M22' , ErrStat2, ErrMsg2); if(Failed()) return ; p%M22 (1:n2,1:n2) =0
   call allocAry(p%K22 , n2, n2, 'p%K22' , ErrStat2, ErrMsg2); if(Failed()) return ; p%K22 (1:n2,1:n2) =0
   call allocAry(p%C22 , n2, n2, 'p%C22' , ErrStat2, ErrMsg2); if(Failed()) return ; p%C22 (1:n2,1:n2) =0
   call allocAry(p%M12 , n1, n2, 'p%M12' , ErrStat2, ErrMsg2); if(Failed()) return ; p%M12 (1:n1,1:n2) =0
   call allocAry(p%C12 , n1, n2, 'p%C12' , ErrStat2, ErrMsg2); if(Failed()) return ; p%C12 (1:n1,1:n2) =0
   call allocAry(p%M21 , n2, n1, 'p%M21' , ErrStat2, ErrMsg2); if(Failed()) return ; p%M21 (1:n2,1:n1) =0
   call allocAry(p%C21 , n2, n1, 'p%C21' , ErrStat2, ErrMsg2); if(Failed()) return ; p%C21 (1:n2,1:n1) =0
   call allocAry(  I22 , n2, n2, '  I22' , ErrStat2, ErrMsg2); if(Failed()) return ;   I22 (1:n2,1:n2) =0
   do I=1,n2 ; I22(I,I)=1; enddo ! Identity matrix
   ! Submatrices
   p%M11(1:n1,1:n1) = p%PtfmAM(1:n1      ,1:n1      )
   p%C11(1:n1,1:n1) = p%Damp  (1:n1      ,1:n1      )
   p%K11(1:n1,1:n1) = p%Stff  (1:n1      ,1:n1      )
   p%M12(1:n1,1:n2) = p%PtfmAM(1:n1      ,n1+1:n1+n2)
   p%C12(1:n1,1:n2) = p%Damp  (1:n1      ,n1+1:n1+n2)
   p%M21(1:n2,1:n1) = p%PtfmAM(n1+1:n1+n2,1:n1      )
   p%C21(1:n2,1:n1) = p%Damp  (n1+1:n1+n2,1:n1      )
   p%M22(1:n2,1:n2) = p%PtfmAM(n1+1:n1+n2,n1+1:n1+n2)
   p%C22(1:n2,1:n2) = p%Damp  (n1+1:n1+n2,n1+1:n1+n2)
   p%K22(1:n2,1:n2) = p%Stff  (n1+1:n1+n2,n1+1:n1+n2)
   ! A matrix
   p%AMat(1:n2   ,n2+1:nX) = I22   (1:n2,1:n2)
   p%AMat(n2+1:nX,1:n2   ) = -p%K22(1:n2,1:n2)
   p%AMat(n2+1:nX,n2+1:nX) = -p%C22(1:n2,1:n2)
   ! B matrix
   p%BMat(n2+1:nX,7 :12  ) = -p%C21(1:n2,1:6)
   p%BMat(n2+1:nX,13:18  ) = -p%M21(1:n2,1:6)
   ! C matrix
   p%CMat(1:nY,1:n2   ) = matmul(p%M12,p%K22)
   p%CMat(1:nY,n2+1:nX) = matmul(p%M12,p%C22)
   ! D matrix
   p%DMat(1:nY,1:6   ) = -p%K11
   p%DMat(1:nY,7:12  ) = -p%C11 + matmul(p%M12,p%C21)
   p%DMat(1:nY,13:18 ) = -p%M11 + matmul(p%M12,p%M21)
!    call disp2r8(6, 'M',p%PtfmAM)
!    call disp2r8(6, 'K',p%Stff)
!    call disp2r8(6, 'C',p%Damp)
!    call disp2r8(6, 'F',p%PtfmFt)
!    call disp2r8(6, 'M11',p%M11)
!    call disp2r8(6, 'M12',p%M12)
!    call disp2r8(6, 'M21',p%M21)
!    call disp2r8(6, 'M22',p%M22)
!    call disp2r8(6, 'K11',p%K11)
!    call disp2r8(6, 'K22',p%K22)
!    call disp2r8(6, 'C11',p%C11)
!    call disp2r8(6, 'C12',p%C12)
!    call disp2r8(6, 'C21',p%C21)
!    call disp2r8(6, 'C22',p%C22)
!    call disp2r8(6, 'A',p%AMat)
!    call disp2r8(6, 'B',p%BMat)
!    call disp2r8(6, 'C',p%CMat)
!    call disp2r8(6, 'D',p%DMat)

CONTAINS
    logical function Failed()
        CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
        Failed =  ErrStat >= AbortErrLev
    end function Failed

END SUBROUTINE SetStateMatrices
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE Init_meshes(u, y, ErrStat, ErrMsg)
   TYPE(ExtPtfm_InputType),           INTENT(INOUT)  :: u           !< System inputs
   TYPE(ExtPtfm_OutputType),          INTENT(INOUT)  :: y           !< System outputs
   INTEGER(IntKi),                    INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                      INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None
   ! local variables
   INTEGER(IntKi)                                    :: ErrStat2    ! local error status
   CHARACTER(ErrMsgLen)                              :: ErrMsg2     ! local error message
   CHARACTER(*), PARAMETER                           :: RoutineName = 'Init_meshes'
   
   ErrStat = ErrID_None
   ErrMSg = ""
   ! Create the input and output meshes associated with platform loads
   CALL MeshCreate(  BlankMesh         = u%PtfmMesh       , &
                     IOS               = COMPONENT_INPUT  , &
                     Nnodes            = 1                , &
                     ErrStat           = ErrStat2         , &
                     ErrMess           = ErrMsg2          , &
                     TranslationDisp   = .TRUE.           , &
                     Orientation       = .TRUE.           , &
                     TranslationVel    = .TRUE.           , &
                     RotationVel       = .TRUE.           , &
                     TranslationAcc    = .TRUE.           , &
                     RotationAcc       = .TRUE.)

      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      if ( ErrStat >= AbortErrLev ) return
      
   ! Create the node on the mesh
   CALL MeshPositionNode (u%PtfmMesh, 1, (/0.0_ReKi, 0.0_ReKi, 0.0_ReKi/), ErrStat2, ErrMsg2 )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)

   ! Create the mesh element
   CALL MeshConstructElement (  u%PtfmMesh, ELEMENT_POINT, ErrStat2, ErrMsg2, 1 )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)

   CALL MeshCommit ( u%PtfmMesh, ErrStat2, ErrMsg2 )
   CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   if ( ErrStat >= AbortErrLev ) return

   ! the output mesh is a sibling of the input:
   CALL MeshCopy( SrcMesh=u%PtfmMesh, DestMesh=y%PtfmMesh, CtrlCode=MESH_SIBLING, IOS=COMPONENT_OUTPUT, &
                  ErrStat=ErrStat2, ErrMess=ErrMsg2, Force=.TRUE., Moment=.TRUE. )
   CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)

END SUBROUTINE Init_meshes
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine is called at the end of the simulation.
SUBROUTINE ExtPtfm_End( u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg )
!..................................................................................................................................
   TYPE(ExtPtfm_InputType),           INTENT(INOUT)  :: u           !< System inputs
   TYPE(ExtPtfm_ParameterType),       INTENT(INOUT)  :: p           !< Parameters
   TYPE(ExtPtfm_ContinuousStateType), INTENT(INOUT)  :: x           !< Continuous states
   TYPE(ExtPtfm_DiscreteStateType),   INTENT(INOUT)  :: xd          !< Discrete states
   TYPE(ExtPtfm_ConstraintStateType), INTENT(INOUT)  :: z           !< Constraint states
   TYPE(ExtPtfm_OtherStateType),      INTENT(INOUT)  :: OtherState  !< Other states
   TYPE(ExtPtfm_OutputType),          INTENT(INOUT)  :: y           !< System outputs
   TYPE(ExtPtfm_MiscVarType),         INTENT(INOUT)  :: m           !< Misc variables for optimization (not copied in glue code)
   INTEGER(IntKi),                    INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                      INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None
   ! local variables
   INTEGER(IntKi)                                    :: ErrStat2    ! local error status
   CHARACTER(ErrMsgLen)                              :: ErrMsg2     ! local error message
   CHARACTER(*), PARAMETER                           :: RoutineName = 'ExtPtfm_End'
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ""
   ! Place any last minute operations or calculations here:
   ! Close files here (but because of checkpoint-restart capability, it is not recommended to have files open during the simulation):
   ! Destroy the input data:
   call ExtPtfm_DestroyInput( u, ErrStat2, ErrMsg2 ); call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
   ! Destroy the parameter data:
   call ExtPtfm_DestroyParam( p, ErrStat2, ErrMsg2 ); call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
   ! Destroy the state data:
   call ExtPtfm_DestroyContState(   x,          ErrStat2,ErrMsg2); call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
   call ExtPtfm_DestroyDiscState(   xd,         ErrStat2,ErrMsg2); call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
   call ExtPtfm_DestroyConstrState( z,          ErrStat2,ErrMsg2); call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
   call ExtPtfm_DestroyOtherState(  OtherState, ErrStat2,ErrMsg2); call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
   ! Destroy the output data:
   call ExtPtfm_DestroyOutput( y, ErrStat2, ErrMsg2 ); call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
   ! Destroy the misc data:
   call ExtPtfm_DestroyMisc( m, ErrStat2, ErrMsg2 ); call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
END SUBROUTINE ExtPtfm_End
!----------------------------------------------------------------------------------------------------------------------------------
!> This is a loose coupling routine for solving constraint states, integrating continuous states, and updating discrete and other
!! states. Continuous, constraint, discrete, and other states are updated to values at t + Interval.
SUBROUTINE ExtPtfm_UpdateStates( t, n, Inputs, InputTimes, p, x, xd, z, OtherState, m, ErrStat, ErrMsg )
!..................................................................................................................................
   REAL(DbKi),                         INTENT(IN   ) :: t               !< Current simulation time in seconds
   INTEGER(IntKi),                     INTENT(IN   ) :: n               !< Current step of the simulation: t = n*Interval
   TYPE(ExtPtfm_InputType),            INTENT(INOUT) :: Inputs(:)       !< Inputs at InputTimes (output from this routine only
                                                                        !!  because of record keeping in routines that copy meshes)
   REAL(DbKi),                         INTENT(IN   ) :: InputTimes(:)   !< Times in seconds associated with Inputs
   TYPE(ExtPtfm_ParameterType),        INTENT(IN   ) :: p               !< Parameters
   TYPE(ExtPtfm_ContinuousStateType),  INTENT(INOUT) :: x               !< Input: Continuous states at t;
                                                                        !!   Output: Continuous states at t + Interval
   TYPE(ExtPtfm_DiscreteStateType),    INTENT(INOUT) :: xd              !< Input: Discrete states at t;
                                                                        !!   Output: Discrete states at t + Interval
   TYPE(ExtPtfm_ConstraintStateType),  INTENT(INOUT) :: z               !< Input: Constraint states at t;
                                                                        !!   Output: Constraint states at t + Interval
   TYPE(ExtPtfm_OtherStateType),       INTENT(INOUT) :: OtherState      !< Other states: Other states at t;
                                                                        !!   Output: Other states at t + Interval
   TYPE(ExtPtfm_MiscVarType),          INTENT(INOUT) :: m               !<  Misc variables for optimization (not copied in glue code)
   INTEGER(IntKi),                     INTENT(  OUT) :: ErrStat         !< Error status of the operation
   CHARACTER(*),                       INTENT(  OUT) :: ErrMsg          !< Error message if ErrStat /= ErrID_None
   ! Local variables
   !INTEGER(IntKi)                                    :: ErrStat2        ! local error status
   !CHARACTER(ErrMsgLen)                              :: ErrMsg2         ! local error message
   !CHARACTER(*), PARAMETER                           :: RoutineName = 'ExtPtfm_UpdateStates'
   ! Initialize variables
   ErrStat   = ErrID_None           ! no error has occurred
   ErrMsg    = ""
END SUBROUTINE ExtPtfm_UpdateStates
!----------------------------------------------------------------------------------------------------------------------------------
!> This is a routine for computing outputs, used in both loose and tight coupling.
SUBROUTINE ExtPtfm_CalcOutput( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg )
!..................................................................................................................................
   REAL(DbKi),                        INTENT(IN   )  :: t           !< Current simulation time in seconds
   TYPE(ExtPtfm_InputType),           INTENT(IN   )  :: u           !< Inputs at t
   TYPE(ExtPtfm_ParameterType),       INTENT(IN   )  :: p           !< Parameters
   TYPE(ExtPtfm_ContinuousStateType), INTENT(IN   )  :: x           !< Continuous states at t
   TYPE(ExtPtfm_DiscreteStateType),   INTENT(IN   )  :: xd          !< Discrete states at t
   TYPE(ExtPtfm_ConstraintStateType), INTENT(IN   )  :: z           !< Constraint states at t
   TYPE(ExtPtfm_OtherStateType),      INTENT(IN   )  :: OtherState  !< Other states at t
   TYPE(ExtPtfm_MiscVarType),         INTENT(INOUT)  :: m           !< Misc variables for optimization (not copied in glue code)
   TYPE(ExtPtfm_OutputType),          INTENT(INOUT)  :: y           !< Outputs computed at t (Input only so that mesh con-
                                                                     !!   nectivity information does not have to be recalculated)
   INTEGER(IntKi),                    INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                      INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None
   ! Local variables
   INTEGER(IntKi)                                  :: I,J               !< Generic counters
   INTEGER(IntKi)                                  :: ErrStat2          !< Temporary Error status of the operation
   CHARACTER(ErrMsgLen)                            :: ErrMsg2           !< Temporary Error message if ErrStat /= ErrID_None
   CHARACTER(*),     PARAMETER                     :: RoutineName='ExtPtfm_CalcOutput'
   real(ReKi), dimension(6)                        :: Fc                !< Output coupling force
   real(ReKi), dimension(:), allocatable           :: F2                !< Temporary force from CB modes
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ""
   
   ! translate inputs on mesh to arrays for computations:
   m%q(1:3) = u%PtfmMesh%TranslationDisp(:,1)
   m%q(4:6) = GetSmllRotAngs ( u%PtfmMesh%Orientation(:,:,1), ErrStat2, ErrMsg2 )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   
   m%qdot(1:3) = u%PtfmMesh%TranslationVel(:,1)
   m%qdot(4:6) = u%PtfmMesh%RotationVel(:,1)   

   m%qdotdot(1:3) = u%PtfmMesh%TranslationAcc(:,1)
   m%qdotdot(4:6) = u%PtfmMesh%RotationAcc(:,1)

   ! Compute the platform force `fr1` (without added mass):
   ! get interpolated (in time) loads, m%PtfmFt
   call InterpStpMat( REAL(t,ReKi), p%PtfmFt_t, p%PtfmFt, m%Indx, p%nPtfmFt, m%PtfmFt ) ! interpolate this based on the time history read in
   ! Add the loads from added mass matrix, damping and stiffness
   ! Fc = fr1 - M11 \ddot{x1} - C11 \dot{x1} - K x1
   Fc(1:6) = m%PtfmFt(1:6) ! Fc  = fr1
   DO J = 1,6
      DO I = 1,6
         Fc(I) = Fc(I) - p%PtfmAM(I,J)*m%qdotdot(J) - p%Damp(I,J) * m%qdot(J) - p%Stff(I,J) * m%q(J)
      ENDDO
   ENDDO      
   ! 
   if (p%nCB>0) then
       allocate(F2(1:p%nCB))
       ! fr2 - M21 \ddot{x1} - C21 \dot{x1} - C22 \dot{x2} - K22 x2
       F2 = m%PtfmFt(6+1:6+p%nCB) - matmul(p%M21,m%qdotdot) - matmul(p%C21, m%qdot) - matmul(p%C22, x%x2dot) - matmul(p%K22, x%x2)
       Fc = Fc - matmul(p%C12, x%x2dot) - matmul(p%M12, F2) 
       deallocate(F2)
   endif

   ! Update the Mesh with sum of these loads
   DO I=1,3
      y%PtfmMesh%Force(I,1)  = Fc(I)
      y%PtfmMesh%Moment(I,1) = Fc(I+3)
   ENDDO
   !y%WriteOutput(1) = y%PtfmMesh%Force(1,1)
   !y%WriteOutput(2) = y%PtfmMesh%Moment(1,1)
END SUBROUTINE ExtPtfm_CalcOutput
!----------------------------------------------------------------------------------------------------------------------------------


!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!> This is a tight coupling routine for computing derivatives of continuous states.
SUBROUTINE ExtPtfm_CalcContStateDeriv( t, u, p, x, xd, z, OtherState, m, dxdt, ErrStat, ErrMsg )
!..................................................................................................................................
   REAL(DbKi),                        INTENT(IN   )  :: t           !< Current simulation time in seconds
   TYPE(ExtPtfm_InputType),           INTENT(IN   )  :: u           !< Inputs at t
   TYPE(ExtPtfm_ParameterType),       INTENT(IN   )  :: p           !< Parameters
   TYPE(ExtPtfm_ContinuousStateType), INTENT(IN   )  :: x           !< Continuous states at t
   TYPE(ExtPtfm_DiscreteStateType),   INTENT(IN   )  :: xd          !< Discrete states at t
   TYPE(ExtPtfm_ConstraintStateType), INTENT(IN   )  :: z           !< Constraint states at t
   TYPE(ExtPtfm_OtherStateType),      INTENT(IN   )  :: OtherState  !< Other states at t
   TYPE(ExtPtfm_MiscVarType),         INTENT(INOUT)  :: m           !< Misc variables for optimization (not copied in glue code)
   TYPE(ExtPtfm_ContinuousStateType), INTENT(  OUT)  :: dxdt        !< Continuous state derivatives at t
   INTEGER(IntKi),                    INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                      INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ""
      ! Compute the first time derivatives of the continuous states here:
   !dxdt%DummyContState = 0.0_ReKi
END SUBROUTINE ExtPtfm_CalcContStateDeriv
!----------------------------------------------------------------------------------------------------------------------------------
!> This is a tight coupling routine for updating discrete states.
SUBROUTINE ExtPtfm_UpdateDiscState( t, n, u, p, x, xd, z, OtherState, m, ErrStat, ErrMsg )
!..................................................................................................................................
   REAL(DbKi),                        INTENT(IN   )  :: t           !< Current simulation time in seconds
   INTEGER(IntKi),                    INTENT(IN   )  :: n           !< Current step of the simulation: t = n*Interval
   TYPE(ExtPtfm_InputType),           INTENT(IN   )  :: u           !< Inputs at t
   TYPE(ExtPtfm_ParameterType),       INTENT(IN   )  :: p           !< Parameters
   TYPE(ExtPtfm_ContinuousStateType), INTENT(IN   )  :: x           !< Continuous states at t
   TYPE(ExtPtfm_DiscreteStateType),   INTENT(INOUT)  :: xd          !< Input: Discrete states at t, Output: Discrete states at t + Interval
   TYPE(ExtPtfm_ConstraintStateType), INTENT(IN   )  :: z           !< Constraint states at t
   TYPE(ExtPtfm_OtherStateType),      INTENT(IN   )  :: OtherState  !< Other states at t
   TYPE(ExtPtfm_MiscVarType),         INTENT(INOUT)  :: m           !< Misc variables for optimization (not copied in glue code)
   INTEGER(IntKi),                    INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                      INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ""
   ! Update discrete states here:
   xd%DummyDiscState = 0.0_Reki
END SUBROUTINE ExtPtfm_UpdateDiscState
!----------------------------------------------------------------------------------------------------------------------------------
!> This is a tight coupling routine for solving for the residual of the constraint state functions.
SUBROUTINE ExtPtfm_CalcConstrStateResidual( t, u, p, x, xd, z, OtherState, m, Z_residual, ErrStat, ErrMsg )
!..................................................................................................................................
   REAL(DbKi),                        INTENT(IN   )  :: t           !< Current simulation time in seconds
   TYPE(ExtPtfm_InputType),           INTENT(IN   )  :: u           !< Inputs at t
   TYPE(ExtPtfm_ParameterType),       INTENT(IN   )  :: p           !< Parameters
   TYPE(ExtPtfm_ContinuousStateType), INTENT(IN   )  :: x           !< Continuous states at t
   TYPE(ExtPtfm_DiscreteStateType),   INTENT(IN   )  :: xd          !< Discrete states at t
   TYPE(ExtPtfm_ConstraintStateType), INTENT(IN   )  :: z           !< Constraint states at t (possibly a guess)
   TYPE(ExtPtfm_OtherStateType),      INTENT(IN   )  :: OtherState  !< Other states at t
   TYPE(ExtPtfm_MiscVarType),         INTENT(INOUT)  :: m           !< Misc variables for optimization (not copied in glue code)
   TYPE(ExtPtfm_ConstraintStateType), INTENT(  OUT)  :: Z_residual  !< Residual of the constraint state functions using
                                                                    !!     the input values described above
   INTEGER(IntKi),                    INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                      INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ""
   ! Solve for the residual of the constraint state functions here:
   Z_residual%DummyConstrState = 0.0_ReKi

END SUBROUTINE ExtPtfm_CalcConstrStateResidual
!----------------------------------------------------------------------------------------------------------------------------------

!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! ###### The following four routines are Jacobian routines for linearization capabilities #######
! If the module does not implement them, set ErrStat = ErrID_Fatal in ExtPtfm_Init() when InitInp%Linearize is .true.
!----------------------------------------------------------------------------------------------------------------------------------
!> Routine to compute the Jacobians of the output (Y), continuous- (X), discrete- (Xd), and constraint-state (Z) functions
!! with respect to the inputs (u). The partial derivatives dY/du, dX/du, dXd/du, and DZ/du are returned.
SUBROUTINE ExtPtfm_JacobianPInput( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg, dYdu, dXdu, dXddu, dZdu)
!..................................................................................................................................

   REAL(DbKi),                                INTENT(IN   )           :: t          !< Time in seconds at operating point
   TYPE(ExtPtfm_InputType),                   INTENT(IN   )           :: u          !< Inputs at operating point (may change to inout if a mesh copy is required)
   TYPE(ExtPtfm_ParameterType),               INTENT(IN   )           :: p          !< Parameters
   TYPE(ExtPtfm_ContinuousStateType),         INTENT(IN   )           :: x          !< Continuous states at operating point
   TYPE(ExtPtfm_DiscreteStateType),           INTENT(IN   )           :: xd         !< Discrete states at operating point
   TYPE(ExtPtfm_ConstraintStateType),         INTENT(IN   )           :: z          !< Constraint states at operating point
   TYPE(ExtPtfm_OtherStateType),              INTENT(IN   )           :: OtherState !< Other states at operating point
   TYPE(ExtPtfm_OutputType),                  INTENT(IN   )           :: y          !< Output (change to inout if a mesh copy is required); 
                                                                                    !!   Output fields are not used by this routine, but type is   
                                                                                    !!   available here so that mesh parameter information (i.e.,  
                                                                                    !!   connectivity) does not have to be recalculated for dYdu.
   TYPE(ExtPtfm_MiscVarType),                 INTENT(INOUT)           :: m          !< Misc/optimization variables
   INTEGER(IntKi),                            INTENT(  OUT)           :: ErrStat    !< Error status of the operation
   CHARACTER(*),                              INTENT(  OUT)           :: ErrMsg     !< Error message if ErrStat /= ErrID_None
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dYdu(:,:)  !< Partial derivatives of output functions (Y) with respect 
                                                                                    !!   to the inputs (u) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dXdu(:,:)  !< Partial derivatives of continuous state functions (X) with 
                                                                                    !!   respect to the inputs (u) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dXddu(:,:) !< Partial derivatives of discrete state functions (Xd) with 
                                                                                    !!   respect to the inputs (u) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dZdu(:,:)  !< Partial derivatives of constraint state functions (Z) with 
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   IF ( PRESENT( dYdu ) ) THEN
      ! Calculate the partial derivative of the output functions (Y) with respect to the inputs (u) here:
      ! allocate and set dYdu
   END IF
   IF ( PRESENT( dXdu ) ) THEN
      ! Calculate the partial derivative of the continuous state functions (X) with respect to the inputs (u) here:
      ! allocate and set dXdu
   END IF
   IF ( PRESENT( dXddu ) ) THEN
      ! Calculate the partial derivative of the discrete state functions (Xd) with respect to the inputs (u) here:
      ! allocate and set dXddu
   END IF
   IF ( PRESENT( dZdu ) ) THEN
      ! Calculate the partial derivative of the constraint state functions (Z) with respect to the inputs (u) here:
      ! allocate and set dZdu
   END IF
END SUBROUTINE ExtPtfm_JacobianPInput
!----------------------------------------------------------------------------------------------------------------------------------
!> Routine to compute the Jacobians of the output (Y), continuous- (X), discrete- (Xd), and constraint-state (Z) functions
!! with respect to the continuous states (x). The partial derivatives dY/dx, dX/dx, dXd/dx, and DZ/dx are returned.
SUBROUTINE ExtPtfm_JacobianPContState( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg, dYdx, dXdx, dXddx, dZdx )
!..................................................................................................................................
   REAL(DbKi),                         INTENT(IN   ) :: t          !< Time in seconds at operating point
   TYPE(ExtPtfm_InputType),            INTENT(IN   ) :: u          !< Inputs at operating point (may change to inout if a mesh copy is required)
   TYPE(ExtPtfm_ParameterType),        INTENT(IN   ) :: p          !< Parameters
   TYPE(ExtPtfm_ContinuousStateType),  INTENT(IN   ) :: x          !< Continuous states at operating point
   TYPE(ExtPtfm_DiscreteStateType),    INTENT(IN   ) :: xd         !< Discrete states at operating point
   TYPE(ExtPtfm_ConstraintStateType),  INTENT(IN   ) :: z          !< Constraint states at operating point
   TYPE(ExtPtfm_OtherStateType),       INTENT(IN   ) :: OtherState !< Other states at operating point
   TYPE(ExtPtfm_OutputType),           INTENT(IN   ) :: y          !< Output (change to inout if a mesh copy is required); 
                                                                   !!   Output fields are not used by this routine, but type is   
                                                                   !!   available here so that mesh parameter information (i.e.,  
                                                                   !!   connectivity) does not have to be recalculated for dYdx.
   TYPE(ExtPtfm_MiscVarType),          INTENT(INOUT) :: m          !< Misc/optimization variables
   INTEGER(IntKi),                     INTENT(  OUT) :: ErrStat    !< Error status of the operation
   CHARACTER(*),                       INTENT(  OUT) :: ErrMsg     !< Error message if ErrStat /= ErrID_None
   REAL(ReKi), ALLOCATABLE, OPTIONAL,  INTENT(INOUT) :: dYdx(:,:)  !< Partial derivatives of output functions
                                                                   !!   (Y) with respect to the continuous
                                                                   !!   states (x) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,  INTENT(INOUT) :: dXdx(:,:)  !< Partial derivatives of continuous state
                                                                   !!   functions (X) with respect to
                                                                   !!   the continuous states (x) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,  INTENT(INOUT) :: dXddx(:,:) !< Partial derivatives of discrete state
                                                                   !!   functions (Xd) with respect to
                                                                   !!   the continuous states (x) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,  INTENT(INOUT) :: dZdx(:,:)  !< Partial derivatives of constraint state
                                                                             !!   functions (Z) with respect to
                                                                                    !!   the continuous states (x) [intent in to avoid deallocation]
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   IF ( PRESENT( dYdx ) ) THEN
      ! Calculate the partial derivative of the output functions (Y) with respect to the continuous states (x) here:
      ! allocate and set dYdx
   END IF
   IF ( PRESENT( dXdx ) ) THEN
      ! Calculate the partial derivative of the continuous state functions (X) with respect to the continuous states (x) here:
      ! allocate and set dXdx
   END IF
   IF ( PRESENT( dXddx ) ) THEN
      ! Calculate the partial derivative of the discrete state functions (Xd) with respect to the continuous states (x) here:
      ! allocate and set dXddx
   END IF
   IF ( PRESENT( dZdx ) ) THEN
      ! Calculate the partial derivative of the constraint state functions (Z) with respect to the continuous states (x) here:
      ! allocate and set dZdx
   END IF
END SUBROUTINE ExtPtfm_JacobianPContState
!----------------------------------------------------------------------------------------------------------------------------------
!> Routine to compute the Jacobians of the output (Y), continuous- (X), discrete- (Xd), and constraint-state (Z) functions
!! with respect to the discrete states (xd). The partial derivatives dY/dxd, dX/dxd, dXd/dxd, and DZ/dxd are returned.
SUBROUTINE ExtPtfm_JacobianPDiscState( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg, dYdxd, dXdxd, dXddxd, dZdxd )
!..................................................................................................................................

   REAL(DbKi),                                INTENT(IN   )           :: t          !< Time in seconds at operating point
   TYPE(ExtPtfm_InputType),                   INTENT(IN   )           :: u          !< Inputs at operating point (may change to inout if a mesh copy is required)
   TYPE(ExtPtfm_ParameterType),               INTENT(IN   )           :: p          !< Parameters
   TYPE(ExtPtfm_ContinuousStateType),         INTENT(IN   )           :: x          !< Continuous states at operating point
   TYPE(ExtPtfm_DiscreteStateType),           INTENT(IN   )           :: xd         !< Discrete states at operating point
   TYPE(ExtPtfm_ConstraintStateType),         INTENT(IN   )           :: z          !< Constraint states at operating point
   TYPE(ExtPtfm_OtherStateType),              INTENT(IN   )           :: OtherState !< Other states at operating point
   TYPE(ExtPtfm_OutputType),                  INTENT(IN   )           :: y          !< Output (change to inout if a mesh copy is required); 
                                                                                    !!   Output fields are not used by this routine, but type is   
                                                                                    !!   available here so that mesh parameter information (i.e.,  
                                                                                    !!   connectivity) does not have to be recalculated for dYdxd.
   TYPE(ExtPtfm_MiscVarType),                 INTENT(INOUT)           :: m          !< Misc/optimization variables
   INTEGER(IntKi),                            INTENT(  OUT)           :: ErrStat    !< Error status of the operation
   CHARACTER(*),                              INTENT(  OUT)           :: ErrMsg     !< Error message if ErrStat /= ErrID_None
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dYdxd(:,:) !< Partial derivatives of output functions
                                                                                    !!  (Y) with respect to the discrete
                                                                                    !!  states (xd) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dXdxd(:,:) !< Partial derivatives of continuous state
                                                                                    !!   functions (X) with respect to the
                                                                                    !!   discrete states (xd) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dXddxd(:,:)!< Partial derivatives of discrete state
                                                                                    !!   functions (Xd) with respect to the
                                                                                    !!   discrete states (xd) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dZdxd(:,:) !< Partial derivatives of constraint state
                                                                                    !!   functions (Z) with respect to the
                                                                                    !!   discrete states (xd) [intent in to avoid deallocation]
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''
   IF ( PRESENT( dYdxd ) ) THEN
      ! Calculate the partial derivative of the output functions (Y) with respect to the discrete states (xd) here:
      ! allocate and set dYdxd
   END IF
   IF ( PRESENT( dXdxd ) ) THEN
      ! Calculate the partial derivative of the continuous state functions (X) with respect to the discrete states (xd) here:
      ! allocate and set dXdxd
   END IF

   IF ( PRESENT( dXddxd ) ) THEN
      ! Calculate the partial derivative of the discrete state functions (Xd) with respect to the discrete states (xd) here:
      ! allocate and set dXddxd
   END IF
   IF ( PRESENT( dZdxd ) ) THEN
      ! Calculate the partial derivative of the constraint state functions (Z) with respect to the discrete states (xd) here:
      ! allocate and set dZdxd
   END IF
END SUBROUTINE ExtPtfm_JacobianPDiscState
!----------------------------------------------------------------------------------------------------------------------------------
!> Routine to compute the Jacobians of the output (Y), continuous- (X), discrete- (Xd), and constraint-state (Z) functions
!! with respect to the constraint states (z). The partial derivatives dY/dz, dX/dz, dXd/dz, and DZ/dz are returned.
SUBROUTINE ExtPtfm_JacobianPConstrState( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg, dYdz, dXdz, dXddz, dZdz )
!..................................................................................................................................
   REAL(DbKi),                                INTENT(IN   )           :: t          !< Time in seconds at operating point
   TYPE(ExtPtfm_InputType),                   INTENT(IN   )           :: u          !< Inputs at operating point (may change to inout if a mesh copy is required)
   TYPE(ExtPtfm_ParameterType),               INTENT(IN   )           :: p          !< Parameters
   TYPE(ExtPtfm_ContinuousStateType),         INTENT(IN   )           :: x          !< Continuous states at operating point
   TYPE(ExtPtfm_DiscreteStateType),           INTENT(IN   )           :: xd         !< Discrete states at operating point
   TYPE(ExtPtfm_ConstraintStateType),         INTENT(IN   )           :: z          !< Constraint states at operating point
   TYPE(ExtPtfm_OtherStateType),              INTENT(IN   )           :: OtherState !< Other states at operating point
   TYPE(ExtPtfm_OutputType),                  INTENT(IN   )           :: y          !< Output (change to inout if a mesh copy is required); 
                                                                                    !!   Output fields are not used by this routine, but type is   
                                                                                    !!   available here so that mesh parameter information (i.e.,  
                                                                                    !!   connectivity) does not have to be recalculated for dYdz.
   TYPE(ExtPtfm_MiscVarType),                 INTENT(INOUT)           :: m          !< Misc/optimization variables
   INTEGER(IntKi),                            INTENT(  OUT)           :: ErrStat    !< Error status of the operation
   CHARACTER(*),                              INTENT(  OUT)           :: ErrMsg     !< Error message if ErrStat /= ErrID_None
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dYdz(:,:)  !< Partial derivatives of output
                                                                                    !!  functions (Y) with respect to the
                                                                                    !!  constraint states (z) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dXdz(:,:)  !< Partial derivatives of continuous
                                                                                    !!  state functions (X) with respect to
                                                                                    !!  the constraint states (z) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dXddz(:,:) !< Partial derivatives of discrete state
                                                                                    !!  functions (Xd) with respect to the
                                                                                    !!  constraint states (z) [intent in to avoid deallocation]
   REAL(ReKi), ALLOCATABLE, OPTIONAL,         INTENT(INOUT)           :: dZdz(:,:)  !< Partial derivatives of constraint
                                                                                    !! state functions (Z) with respect to
                                                                                    !!  the constraint states (z) [intent in to avoid deallocation]
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''

   IF ( PRESENT( dYdz ) ) THEN
      ! Calculate the partial derivative of the output functions (Y) with respect to the constraint states (z) here:
      ! allocate and set dYdz
   END IF

   IF ( PRESENT( dXdz ) ) THEN
      ! Calculate the partial derivative of the continuous state functions (X) with respect to the constraint states (z) here:
      ! allocate and set dXdz
   END IF

   IF ( PRESENT( dXddz ) ) THEN
      ! Calculate the partial derivative of the discrete state functions (Xd) with respect to the constraint states (z) here:
      ! allocate and set dXddz
   END IF

   IF ( PRESENT( dZdz ) ) THEN
      ! Calculate the partial derivative of the constraint state functions (Z) with respect to the constraint states (z) here:
      ! allocate and set dZdz
   END IF


END SUBROUTINE ExtPtfm_JacobianPConstrState
!----------------------------------------------------------------------------------------------------------------------------------
!> Routine to pack the data structures representing the operating points into arrays for linearization.
SUBROUTINE ExtPtfm_GetOP( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg, u_op, y_op, x_op, dx_op, xd_op, z_op )
   REAL(DbKi),                           INTENT(IN   )           :: t          !< Time in seconds at operating point
   TYPE(ExtPtfm_InputType),              INTENT(IN   )           :: u          !< Inputs at operating point (may change to inout if a mesh copy is required)
   TYPE(ExtPtfm_ParameterType),          INTENT(IN   )           :: p          !< Parameters
   TYPE(ExtPtfm_ContinuousStateType),    INTENT(IN   )           :: x          !< Continuous states at operating point
   TYPE(ExtPtfm_DiscreteStateType),      INTENT(IN   )           :: xd         !< Discrete states at operating point
   TYPE(ExtPtfm_ConstraintStateType),    INTENT(IN   )           :: z          !< Constraint states at operating point
   TYPE(ExtPtfm_OtherStateType),         INTENT(IN   )           :: OtherState !< Other states at operating point
   TYPE(ExtPtfm_OutputType),             INTENT(IN   )           :: y          !< Output at operating point
   TYPE(ExtPtfm_MiscVarType),            INTENT(INOUT)           :: m          !< Misc/optimization variables
   INTEGER(IntKi),                       INTENT(  OUT)           :: ErrStat    !< Error status of the operation
   CHARACTER(*),                         INTENT(  OUT)           :: ErrMsg     !< Error message if ErrStat /= ErrID_None
   REAL(ReKi), ALLOCATABLE, OPTIONAL,    INTENT(INOUT)           :: u_op(:)    !< values of linearized inputs
   REAL(ReKi), ALLOCATABLE, OPTIONAL,    INTENT(INOUT)           :: y_op(:)    !< values of linearized outputs
   REAL(ReKi), ALLOCATABLE, OPTIONAL,    INTENT(INOUT)           :: x_op(:)    !< values of linearized continuous states
   REAL(ReKi), ALLOCATABLE, OPTIONAL,    INTENT(INOUT)           :: dx_op(:)   !< values of first time derivatives of linearized continuous states
   REAL(ReKi), ALLOCATABLE, OPTIONAL,    INTENT(INOUT)           :: xd_op(:)   !< values of linearized discrete states
   REAL(ReKi), ALLOCATABLE, OPTIONAL,    INTENT(INOUT)           :: z_op(:)    !< values of linearized constraint states
   ! Initialize ErrStat
   ErrStat = ErrID_None
   ErrMsg  = ''

   IF ( PRESENT( u_op ) ) THEN
   END IF

   IF ( PRESENT( y_op ) ) THEN
   END IF

   IF ( PRESENT( x_op ) ) THEN
   END IF

   IF ( PRESENT( dx_op ) ) THEN
   END IF

   IF ( PRESENT( xd_op ) ) THEN
   END IF
   
   IF ( PRESENT( z_op ) ) THEN
   END IF

END SUBROUTINE ExtPtfm_GetOP
!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

END MODULE ExtPtfm_MCKF
!**********************************************************************************************************************************
