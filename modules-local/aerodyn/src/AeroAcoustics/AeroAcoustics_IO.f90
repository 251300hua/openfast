!**********************************************************************************************************************************
! LICENSING
! Copyright (C) 2015-2016  National Renewable Energy Laboratory
!
!    This file is part of Noise.
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!**********************************************************************************************************************************
! File last committed: $Date$
! (File) Revision #: $Rev$
! URL: $HeadURL$
!**********************************************************************************************************************************
MODULE AeroAcoustics_IO
 
   use NWTC_Library
   use AeroAcoustics_Types
   
   implicit none
   
   type(ProgDesc), parameter  :: AA_Ver = ProgDesc( 'AeroAcoustics', 'v1.00.00', '18-Aug-2016' )
   character(*),   parameter  :: AA_Nickname = 'AA'
      
! ===================================================================================================
! NOTE: The following lines of code were generated by a Matlab script called "Write_ChckOutLst.m"
!      using the parameters listed in the "OutListParameters.xlsx" Excel file. Any changes to these 
!      lines should be modified in the Matlab script and/or Excel worksheet as necessary. 
! ===================================================================================================
! This code was generated by Write_ChckOutLst.m at 11-Mar-2016 14:45:58.

     ! Indices for computing output channels:
     ! NOTES: 
     !    (1) These parameters are in the order stored in "OutListParameters.xlsx"
     !    (2) Array AllOuts() must be dimensioned to the value of the largest output parameter

     !  Time: 

   INTEGER(IntKi), PARAMETER      :: Time      =    0

     ! Parameters related to output length (number of characters allowed in the output data headers):

   INTEGER(IntKi), PARAMETER      :: OutStrLenM1 = ChanLen - 1

   INTEGER(IntKi), PARAMETER        :: MaxBl    =  3                                   ! Maximum number of blades allowed in simulation
   
   ! model identifiers
   integer(intKi), parameter        :: ModelUnknown  = -1

! FLAG TO COMPUTE BLUNTNESS NOISE           = 0 No, =1 Yes      
   integer(intKi), parameter        :: IBLUNT_None  = 0  
   integer(intKi), parameter        :: IBLUNT_BPM  = 1
   
! FLAG TO COMPUTE Laminar Boundary Layer Noise          = 0 No, =1 Yes      
   integer(intKi), parameter        :: ILAM_None      = 0  ! steady model
   integer(intKi), parameter        :: ILAM_BPM       = 1  ! 

! FLAG TO COMPUTE Tip  Noise          = 0 No, =1 Yes      
   integer(intKi), parameter        :: ITIP_None  = 0  !
   integer(intKi), parameter        :: ITIP_On      = 1  ! 

   integer(intKi), parameter        :: ITRIP_None     = 0  ! not tripped boundary layer
   integer(intKi), parameter        :: ITRIP_Heavy    = 1  ! heavily tripped boundary layer 
   integer(intKi), parameter        :: ITRIP_Light      = 2  ! light tripped boundary layer 

! calculation method for boundary layer properties,  = 1 BPM = 2 Xfoil
   integer(intKi), parameter        :: X_BLMethod_BPM  = 1  ! 
   integer(intKi), parameter        :: X_BLMethod_Xfoil  = 2  ! 


   integer(intKi), parameter        :: XfoilCall_Interp  = 1  ! interpolate from pretabulated 
   integer(intKi), parameter        :: XfoilCall_Every   = 2  ! call xfoil for each each time step

   integer(intKi), parameter        :: TICalc_Interp  = 1  ! interpolate from pretabulated 
   integer(intKi), parameter        :: TICalc_Every   = 2  ! calculate ti automatically 



   integer(intKi), parameter        :: ITURB_None           = 0 	 ! TBLTE noise is not calculated 
   integer(intKi), parameter        :: ITURB_BPM            = 1  ! TBLTE noise is calculated with BPM
   integer(intKi), parameter        :: ITURB_TNO            = 2  ! TBLTE noise is calculated with TNO

   integer(intKi), parameter        :: IInflow_None                 = 0  ! IInflow noise is not calculated 
   integer(intKi), parameter        :: IInflow_BPM                  = 1  ! IInflow noise is calculated with BPM
   integer(intKi), parameter        :: IInflow_FullGuidati         = 2  ! IInflow noise is calculated with FullGuidati   
   integer(intKi), parameter        :: IInflow_SimpleGuidati    = 3  ! IInflow noise is calculated with SimpleGuidati
 
   integer(intKi), parameter        :: AweightFlagOn    = 1  ! 
   integer(intKi), parameter        :: AweightFlagOff    = 0

   INTEGER(IntKi), PARAMETER      :: MaxOutPts = 1103
contains
   
   
  
!----------------------------------------------------------------------------------------------------------------------------------
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE ReadInputFiles( InputFileName, InputFileData, Default_DT, OutFileRoot, NumBlades, UnEcho, ErrStat, ErrMsg )
! This subroutine reads the input file and stores all the data in the AA_InputFile structure.
! It does not perform data validation.
!..................................................................................................................................

      ! Passed variables
   REAL(DbKi),              INTENT(IN)    :: Default_DT      ! The default DT (from glue code)

   CHARACTER(*),            INTENT(IN)    :: InputFileName   ! Name of the input file
   CHARACTER(*),            INTENT(IN)    :: OutFileRoot     ! The rootname of all the output files written by this routine.

   TYPE(AA_InputFile),      INTENT(OUT)   :: InputFileData   ! Data stored in the module's input file
   INTEGER(IntKi),          INTENT(OUT)   :: UnEcho          ! Unit number for the echo file

   INTEGER(IntKi),          INTENT(IN)    :: NumBlades       ! Number of blades for this model
   INTEGER(IntKi),          INTENT(OUT)   :: ErrStat         ! The error status code
   CHARACTER(*),            INTENT(OUT)   :: ErrMsg          ! The error message, if an error occurred

      ! local variables

   INTEGER(IntKi)                         :: I
   INTEGER(IntKi)                         :: ErrStat2        ! The error status code
   CHARACTER(ErrMsgLen)                   :: ErrMsg2         ! The error message, if an error occurred
   CHARACTER(1024)                        :: AABlFile(MaxBl) ! File that contains the blade information (specified in the primary input file)
   LOGICAL                       	  :: readinornot        ! The error status code
   CHARACTER(*), PARAMETER                :: RoutineName = 'ReadInputFiles'
   
   
      ! initialize values:

   ErrStat = ErrID_None
   ErrMsg  = ''
   UnEcho  = -1
   InputFileData%DTAero = Default_DT  ! the glue code's suggested DT for the module (may be overwritten in ReadPrimaryFile())

      ! get the primary/platform input-file data
      ! sets UnEcho, AABlFile

	  CALL ReadPrimaryFile( InputFileName, InputFileData, AABlFile,  OutFileRoot, UnEcho, ErrStat2, ErrMsg2 )
      CALL SetErrStat(ErrStat2,ErrMsg2, ErrStat, ErrMsg, RoutineName)
      IF ( ErrStat >= AbortErrLev ) THEN
         CALL Cleanup()
         RETURN
      END IF
      
      ! get the blade input-file data
      
   ALLOCATE( InputFileData%BladeProps( NumBlades ), STAT = ErrStat2 )
   IF (ErrStat2 /= 0) THEN
      CALL SetErrStat(ErrID_Fatal,"Error allocating memory for BladeProps.", ErrStat, ErrMsg, RoutineName)
      CALL Cleanup()
      RETURN
   END IF
      
   do i = 1,NumBlades
      ! TODO: Make AABlFile an array (DONE)
      CALL ReadBladeInputs ( AABlFile(i), InputFileData%BladeProps(i), UnEcho, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2,ErrMsg2, ErrStat, ErrMsg, RoutineName//TRIM(':Blade')//TRIM(Num2LStr(I)))
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF
   end do

   readinornot=.true.
   IF(   (InputFileData%XfoilCall.eq.1) .and. (InputFileData%ITURB.eq.2)  ) THEN
	CALL ReadXfoilTables( InputFileName,InputFileData, InputFileData%BladeProps(1)%NumBlNds,  ErrStat2, ErrMsg2 )
        readinornot=.false.
   ENDIF 	

   IF(   (InputFileData%XfoilCall.eq.1) .and. (InputFileData%X_BLMethod.eq.2) .and. (readinornot)  ) THEN
	CALL ReadXfoilTables( InputFileName,InputFileData, InputFileData%BladeProps(1)%NumBlNds,  ErrStat2, ErrMsg2 )
   ENDIF 



	
   IF(   (InputFileData%TICalcMeth.eq.1) ) THEN	
	CALL REadTICalcTables(InputFileName,InputFileData,  ErrStat2, ErrMsg2 )
   ENDIF 	





   CALL Cleanup ( )


CONTAINS
   !...............................................................................................................................
   SUBROUTINE Cleanup()
   ! This subroutine cleans up before exiting this subroutine
   !...............................................................................................................................

      ! IF ( UnEcho > 0 ) CLOSE( UnEcho )

   END SUBROUTINE Cleanup

END SUBROUTINE ReadInputFiles
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE ReadPrimaryFile( InputFile, InputFileData, AABlFile,  OutFileRoot, UnEc, ErrStat, ErrMsg )
! This routine reads in the primary Noise input file and places the values it reads in the InputFileData structure.
!   It opens and prints to an echo file if requested.
!..................................................................................................................................


   implicit                        none

      ! Passed variables
   integer(IntKi),     intent(out)     :: UnEc                                ! I/O unit for echo file. If > 0, file is open for writing.
   integer(IntKi),     intent(out)     :: ErrStat                             ! Error status
   character(*),       intent(out)     :: AABlFile(MaxBl)                     ! name of the files containing blade inputs

   character(*),       intent(in)      :: InputFile                           ! Name of the file containing the primary input data
   character(*),       intent(out)     :: ErrMsg                              ! Error message
   character(*),       intent(in)      :: OutFileRoot                         ! The rootname of the echo file, possibly opened in this routine

   type(AA_InputFile), intent(inout)   :: InputFileData                       ! All the data in the Noise input file
   
      ! Local variables:
   real(ReKi)                    :: TmpAry(3)                                 ! array to help read tower properties table
   integer(IntKi)                :: I                                         ! loop counter
   integer(IntKi)                :: UnIn,UnIn2                                ! Unit number for reading file
   integer(IntKi)                :: loop1                                     ! loop counter
   character(1024)                  :: ObserverFile                              ! name of the files containing obesever location
   integer(IntKi)                :: ErrStat2, IOS,cou                             ! Temporary Error status
   logical                       :: Echo                                      ! Determines if an echo file should be written
   character(ErrMsgLen)          :: ErrMsg2                                   ! Temporary Error message
   character(1024)               :: PriPath                                   ! Path name of the primary file
   character(1024)               :: FTitle                                    ! "File Title": the 2nd line of the input file, which contains a description of its contents
   character(200)                :: Line                                      ! Temporary storage of a line from the input file (to compare with "default")
   character(*), parameter       :: RoutineName = 'ReadPrimaryFile'
   
   
      ! Initialize some variables:
   ErrStat = ErrID_None
   ErrMsg  = ""
      
   UnEc = -1
   Echo = .FALSE.   
   CALL GetPath( InputFile, PriPath )     ! Input files will be relative to the path where the primary input file is located.
   
      
      ! Get an available unit number for the file.

   CALL GetNewUnit( UnIn, ErrStat2, ErrMsg2 )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

      ! Open the Primary input file.

   CALL OpenFInpFile ( UnIn, InputFile, ErrStat2, ErrMsg2 )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      IF ( ErrStat >= AbortErrLev ) THEN
         CALL Cleanup()
         RETURN
      END IF
      
                  
      
   ! Read the lines up/including to the "Echo" simulation control variable
   ! If echo is FALSE, don't write these lines to the echo file. 
   ! If Echo is TRUE, rewind and write on the second try.
   
   I = 1 !set the number of times we've read the file
   DO 
   !----------- HEADER -------------------------------------------------------------
   
      CALL ReadCom( UnIn, InputFile, 'File header: Module Version (line 1)', ErrStat2, ErrMsg2, UnEc )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   
      CALL ReadStr( UnIn, InputFile, FTitle, 'FTitle', 'File Header: File Description (line 2)', ErrStat2, ErrMsg2, UnEc )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF
   
   
   !----------- GENERAL OPTIONS ----------------------------------------------------
   
      CALL ReadCom( UnIn, InputFile, 'Section Header: General Options', ErrStat2, ErrMsg2, UnEc )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   
         ! Echo - Echo input to "<RootName>.AD.ech".
   
      CALL ReadVar( UnIn, InputFile, Echo, 'Echo',   'Echo flag', ErrStat2, ErrMsg2, UnEc )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   
   
      IF (.NOT. Echo .OR. I > 1) EXIT !exit this loop
   
         ! Otherwise, open the echo file, then rewind the input file and echo everything we've read
      
      I = I + 1         ! make sure we do this only once (increment counter that says how many times we've read this file)
   
      CALL OpenEcho ( UnEc, TRIM(OutFileRoot)//'.ech', ErrStat2, ErrMsg2, AA_Ver )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF ( ErrStat >= AbortErrLev ) THEN
            CALL Cleanup()
            RETURN
         END IF
   
      IF ( UnEc > 0 )  WRITE (UnEc,'(/,A,/)')  'Data from '//TRIM(AA_Ver%Name)//' primary input file "'//TRIM( InputFile )//'":'
         
      REWIND( UnIn, IOSTAT=ErrStat2 )  
         IF (ErrStat2 /= 0_IntKi ) THEN
            CALL SetErrStat( ErrID_Fatal, 'Error rewinding file "'//TRIM(InputFile)//'".', ErrStat, ErrMsg, RoutineName )
            CALL Cleanup()
            RETURN
         END IF         
      
   END DO    

   IF (NWTC_VerboseLevel == NWTC_Verbose) THEN
      CALL WrScr( ' Heading of the '//TRIM(AA_Ver%Name)//' input file: ' )      
      CALL WrScr( '   '//TRIM( FTitle ) )
   END IF
   
   
      ! DTAero - Time interval for aerodynamic calculations {or default} (s):
   Line = ""
   CALL ReadVar( UnIn, InputFile, Line, "DTAero", "Time interval for aerodynamic calculations {or default} (s)", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         
      CALL Conv2UC( Line )
      IF ( INDEX(Line, "DEFAULT" ) /= 1 ) THEN ! If it's not "default", read this variable; otherwise use the value already stored in InputFileData%DTAero
         READ( Line, *, IOSTAT=IOS) InputFileData%DTAero
            CALL CheckIOS ( IOS, InputFile, 'DTAero', NumType, ErrStat2, ErrMsg2 )
            CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      END IF   
   CALL ReadVar( UnIn, InputFile, InputFileData%Comp_AA_After, "Comp_AA_After", "Comp_AA_After", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

   CALL ReadVar( UnIn, InputFile, InputFileData%saveeach, "saveeach", "saveeach", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
      ! IBLUNT - FLAG TO COMPUTE BLUNTNESS NOISE
   CALL ReadVar( UnIn, InputFile, InputFileData%IBLUNT, "IBLUNT", "FLAG TO COMPUTE BLUNTNESS NOISE {} (-)", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

      ! ILAM - FLAG TO COMPUTE LBL NOISE 
   CALL ReadVar( UnIn, InputFile, InputFileData%ILAM, "ILAM", "FLAG TO COMPUTE LBL NOISE {} (-)", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

      ! ITIP - FLAG TO COMPUTE TIP NOISE 
   CALL ReadVar( UnIn, InputFile, InputFileData%ITIP, "ITIP", "FLAG TO COMPUTE TIP NOISE {} (-)", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

      ! ITRIP - FLAG TO TRIP BOUNDARY LAYER 
   CALL ReadVar( UnIn, InputFile, InputFileData%ITRIP, "ITRIP", "FLAG TO TRIP BOUNDARY LAYER {0=none, 1=baseline potential flow, 2=potential flow with Bak correction} (-)", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

      ! ITURB - FLAG TO COMPUTE TBLTE NOISE 
   CALL ReadVar( UnIn, InputFile, InputFileData%ITURB, "ITURB", "FLAG TO COMPUTE TBLTE NOISE {0=none, 1=baseline potential flow, 2=potential flow with Bak correction} (-)", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

      ! 
   CALL ReadVar( UnIn, InputFile, InputFileData%IInflow, "IInflow", "FLAG TO COMPUTE Turbulent Inflow NOISE {0=none, 1=baseline potential flow, 2=potential flow with Bak correction} (-)", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

      ! 
   CALL ReadVar( UnIn, InputFile, InputFileData%X_BLMethod, "X_BLMethod", "Integer describing calculation method for boundary layer properties,  = 1 BPM = 2 Xfoil", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

      ! 
   CALL ReadVar( UnIn, InputFile, InputFileData%XfoilCall, "XfoilCall", "Integer describing Xfoil calls,  = 1 Interpolate from pretabulated = 2 Call Xfoil for each node etc", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

   CALL ReadVar( UnIn, InputFile, InputFileData%TICalcMeth, "TICalcMeth", "Integer describing TICalcMeth,  = 1 Interpolate from pretabulated = 2 calculate on the fly", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

      ! ROUND - LOGICAL INDICATING ROUNDED TIP
   CALL ReadVar( UnIn, InputFile, InputFileData%ROUND, "ROUND", "LOGICAL INDICATING ROUNDED TIP", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
 

      ! ALPRAT - TIP LIFT CURVE SLOPE and (Default = 1.0)  
   CALL ReadVar( UnIn, InputFile, InputFileData%ALPRAT, "ALPRAT", "TIP LIFT CURVE SLOPE and (Default = 1.0)", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )  

! AA_Bl_Prcntge - The calculations will be carried out for the nodes that are within the user input percntage value. 
! i.e. AA_Bl_Prcntge=60 means;Starting from tip 60% percent of the blade will be contributing to the overall noise levels.
   CALL ReadVar( UnIn, InputFile, InputFileData%AA_Bl_Prcntge, "AA_Bl_Prcntge", "-", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )  

! surface roughness
   CALL ReadVar( UnIn, InputFile, InputFileData%z0_AA, "z0_AA", "-", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )  

   CALL ReadVar( UnIn, InputFile, InputFileData%aweightflag, "aweightflag", "Integer describing a weighting", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

      ! Return on error at end of section
   IF ( ErrStat >= AbortErrLev ) THEN
      CALL Cleanup()
      RETURN
   END IF
            
   

   !----------- OBSERVER INPUT  ------------------------------
   CALL ReadCom( UnIn, InputFile, 'Section Header: Observer Input ', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

     ! NrObsLoc  - Nr of Observers (-):
   CALL ReadVar( UnIn, InputFile, InputFileData%NrObsLoc, "NrObsLoc", "Nr of Observers (-)", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )


      ! Observer location in tower-base coordinate X horizontal  (m):
   CALL AllocAry( InputFileData%ObsX,InputFileData%NrObsLoc, 'ObsX', ErrStat2, ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

!	READ( UnIn, *, IOStat=IOS ) InputFileData%ObsX
!    CALL CheckIOS( IOS, 'InputFileData%ObsX', 'InputFileData%ObsX', NumType, ErrStat2, ErrMsg2 )
!      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

      ! Observer location in tower-base coordinate Y horizontal  (m):
   CALL AllocAry( InputFileData%ObsY,InputFileData%NrObsLoc, 'ObsY', ErrStat2, ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

!	READ( UnIn, *, IOStat=IOS ) InputFileData%ObsY
!    CALL CheckIOS( IOS, 'InputFileData%ObsY', 'InputFileData%ObsY', NumType, ErrStat2, ErrMsg2 )
!         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
 
    ! Observer location in tower-base coordinate Z horizontal  (m):
   CALL AllocAry( InputFileData%ObsZ,InputFileData%NrObsLoc, 'ObsZ', ErrStat2, ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

!	READ( UnIn, *, IOStat=IOS ) InputFileData%ObsZ
!    CALL CheckIOS( IOS, 'InputFileData%ObsZ', 'InputFileData%ObsZ', NumType, ErrStat2, ErrMsg2 )
!      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

!----- read from observer file
   CALL ReadVar ( UnIn, InputFile, ObserverFile, ObserverFile, 'Name of file  observer locations', ErrStat2, ErrMsg2, UnEc )
       CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      IF ( PathIsRelative( ObserverFile ) ) ObserverFile = TRIM(PriPath)//TRIM(ObserverFile)
  
   CALL GetNewUnit( UnIn2, ErrStat2, ErrMsg2 )
      CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)

   CALL OpenFInpFile ( UnIn2, ObserverFile, ErrStat2, ErrMsg2 )
      CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      IF ( ErrStat >= AbortErrLev ) RETURN

   CALL ReadCom( UnIn2, InputFile, ' Header', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

	DO cou=1,InputFileData%NrObsLoc
	     READ( UnIn2, *, IOStat=IOS )  InputFileData%ObsX(cou), InputFileData%ObsY(cou), InputFileData%ObsZ(cou)
        	 CALL CheckIOS( IOS, ObserverFile, 'Obeserver Locations '//TRIM(Num2LStr(cou)), NumType, ErrStat2, ErrMsg2 )
        	 CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
        	       ! Return on error if we couldn't read this line
        	    IF ( ErrStat >= AbortErrLev ) THEN
        	       CALL Cleanup()
        	       RETURN
        	    END IF		
	ENDDO
   CLOSE ( UnIn2 )

!----- end read from observer file
 
   !----------- ROTOR/BLADE PROPERTIES  --------------------------------------------
   CALL ReadCom( UnIn, InputFile, 'Section Header: Rotor/Blade Properties', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
    
!      ! AABlFile - Names of files containing distributed aerodynamic properties for each blade (see AA_BladeInputFile type):
   DO I = 1,MaxBl            
      CALL ReadVar ( UnIn, InputFile, AABlFile(I), 'AABlFile('//TRIM(Num2Lstr(I))//')', 'Name of file containing distributed aerodynamic properties for blade '//TRIM(Num2Lstr(I)), ErrStat2, ErrMsg2, UnEc )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      IF ( PathIsRelative( AABlFile(I) ) ) AABlFile(I) = TRIM(PriPath)//TRIM(AABlFile(I))
   END DO      
   

      ! Return on error at end of section
   IF ( ErrStat >= AbortErrLev ) THEN
      CALL Cleanup()
      RETURN
   END IF

                  
   !----------- OUTPUTS  -----------------------------------------------------------
   CALL ReadCom( UnIn, InputFile, 'Section Header: Outputs', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      
     ! NrObsLoc  - Nr of Observers (-):
   CALL ReadVar( UnIn, InputFile, InputFileData%NrOutFile, "InputFileData%NrOutFile", "Nr of Output Files (-)", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

  CALL AllocAry( InputFileData%AAOutFile,InputFileData%NrOutFile, 'InputFileData%AAOutFile', ErrStat2, ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

      CALL ReadVar ( UnIn, InputFile, InputFileData%AAOutFile(1), 'InputFileData%AAOutFile', 'Name of output file ', ErrStat2, ErrMsg2, UnEc )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

	DO I=InputFileData%NrOutFile,1,-1
	! one file name is given by the user and the XXFile1.out XXFile2.out XXFile3.out is generated
     			IF ( PathIsRelative( InputFileData%AAOutFile(I) ) ) InputFileData%AAOutFile(I) = TRIM(PriPath)//TRIM(InputFileData%AAOutFile(1))//TRIM(Num2Lstr(I))//".out"
       ENDDO

      CALL ReadVar ( UnIn, InputFile, InputFileData%LargeBinOutput, 'InputFileData%LargeBinOutput', 'Name of output file ', ErrStat2, ErrMsg2, UnEc )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

      ! Return on error at end of section
   IF ( ErrStat >= AbortErrLev ) THEN
      CALL Cleanup()
      RETURN
   END IF            
 
   !---------------------- END OF FILE -----------------------------------------
      
   CALL Cleanup( )
   RETURN


CONTAINS
   !...............................................................................................................................
   SUBROUTINE Cleanup()
   ! This subroutine cleans up any local variables and closes input files
   !...............................................................................................................................

   IF (UnIn > 0) CLOSE ( UnIn )

   END SUBROUTINE Cleanup
   !...............................................................................................................................
END SUBROUTINE ReadPrimaryFile      
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE ReadBladeInputs ( AABlFile, BladeKInputFileData, UnEc, ErrStat, ErrMsg )
! This routine reads a blade input file.
!..................................................................................................................................


      ! Passed variables:

   TYPE(AA_BladePropsType),  INTENT(INOUT)  :: BladeKInputFileData                 ! Data for Blade K stored in the module's input file
   CHARACTER(*),             INTENT(IN)     :: AABlFile                            ! Name of the blade input file data
   INTEGER(IntKi),           INTENT(IN)     :: UnEc                                ! I/O unit for echo file. If present and > 0, write to UnEc

   INTEGER(IntKi),           INTENT(OUT)    :: ErrStat                             ! Error status
   CHARACTER(*),             INTENT(OUT)    :: ErrMsg                              ! Error message


      ! Local variables:

   INTEGER(IntKi)               :: I                                               ! A generic DO index.
   INTEGER( IntKi )             :: UnIn                                            ! Unit number for reading file
   INTEGER(IntKi)               :: ErrStat2 , IOS                                  ! Temporary Error status
   CHARACTER(ErrMsgLen)         :: ErrMsg2                                         ! Temporary Err msg
   CHARACTER(*), PARAMETER      :: RoutineName = 'ReadBladeInputs'

   ErrStat = ErrID_None
   ErrMsg  = ""
   UnIn = -1
      
   ! Allocate space for these variables
   
   
   CALL GetNewUnit( UnIn, ErrStat2, ErrMsg2 )
      CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)

   CALL OpenFInpFile ( UnIn, AABlFile, ErrStat2, ErrMsg2 )
      CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      IF ( ErrStat >= AbortErrLev ) RETURN


   !  -------------- HEADER -------------------------------------------------------

      ! Skip the header.

   CALL ReadCom ( UnIn, AABlFile, 'unused blade file header line 1', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)

   CALL ReadCom ( UnIn, AABlFile, 'unused blade file header line 2', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      
   !  -------------- Blade properties table ------------------------------------------                                    
   CALL ReadCom ( UnIn, AABlFile, 'Section header: Blade Properties', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)

      ! NumBlNds - Number of blade nodes used in the analysis (-):
   CALL ReadVar( UnIn, AABlFile, BladeKInputFileData%NumBlNds, "NumBlNds", "Number of blade nodes used in the analysis (-)", ErrStat2, ErrMsg2, UnEc)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      IF ( ErrStat >= AbortErrLev ) RETURN

   CALL ReadCom ( UnIn, AABlFile, 'Table header: names', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)

   CALL ReadCom ( UnIn, AABlFile, 'Table header: units', ErrStat2, ErrMsg2, UnEc )
      CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      
   IF ( ErrStat>= AbortErrLev ) THEN 
      CALL Cleanup()
      RETURN
   END IF
   
      
      ! allocate space for blade inputs:
    CALL AllocAry( BladeKInputFileData%TEAngle, BladeKInputFileData%NumBlNds, 'TEAngle', ErrStat2, ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   CALL AllocAry( BladeKInputFileData%TEThick,   BladeKInputFileData%NumBlNds, 'TEThick',   ErrStat2, ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   CALL AllocAry( BladeKInputFileData%StallStart,   BladeKInputFileData%NumBlNds, 'StallStart',   ErrStat2, ErrMsg2)
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

      ! Return on error if we didn't allocate space for the next inputs
   IF ( ErrStat >= AbortErrLev ) THEN
      CALL Cleanup()
      RETURN
   END IF
            
   DO I=1,BladeKInputFileData%NumBlNds
      READ( UnIn, *, IOStat=IOS )  BladeKInputFileData%TEAngle(I), BladeKInputFileData%TEThick(I) , BladeKInputFileData%StallStart(I)
         CALL CheckIOS( IOS, AABlFile, 'Blade properties row '//TRIM(Num2LStr(I)), NumType, ErrStat2, ErrMsg2 )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
               ! Return on error if we couldn't read this line
            IF ( ErrStat >= AbortErrLev ) THEN
               CALL Cleanup()
               RETURN
            END IF
         
        IF (UnEc > 0) THEN
           WRITE( UnEc, "(6(F9.4,1x),I9)", IOStat=IOS)  BladeKInputFileData%TEAngle(I), BladeKInputFileData%TEThick(I), BladeKInputFileData%StallStart(I)
        END IF         
   END DO
              
   !  -------------- END OF FILE --------------------------------------------

   
 


   CALL Cleanup()
   RETURN


CONTAINS
   !...............................................................................................................................
   SUBROUTINE Cleanup()
   ! This subroutine cleans up local variables and closes files
   !...............................................................................................................................

      IF (UnIn > 0) CLOSE(UnIn)

   END SUBROUTINE Cleanup

END SUBROUTINE ReadBladeInputs      






SUBROUTINE ReadXfoilTables( InputFile,InputFileData, BldNodes, ErrStat, ErrMsg )
! This routine reads in the primary Noise input file and places the values it reads in the InputFileData structure.
!   It opens and prints to an echo file if requested.
!..................................................................................................................................


   implicit none

      ! Passed variables
   integer(IntKi),     intent(out)     :: ErrStat                             ! Error status
   character(*),       intent(out)     :: ErrMsg                              ! Error message
   integer(IntKi),     intent(in)      :: BldNodes                             ! Error status
   type(AA_InputFile), intent(inout)   :: InputFileData                       ! All the data in the Noise input file
   character(*),       intent(in)      :: InputFile                           ! Name of the file containing the primary input data

      ! Local variables:
   integer(IntKi)                :: I                                         ! loop counter
   integer(IntKi)                :: UnIn,UnIn2                                ! Unit number for reading file
   integer(IntKi)                :: loop1                                     ! loop counter
   character(1024)               :: FileName                              ! name of the files containing obesever location
   integer(IntKi)                :: ErrStat2, IOS,cou                             ! Temporary Error status
   logical                       :: Echo                                      ! Determines if an echo file should be written
   character(ErrMsgLen)          :: ErrMsg2                                   ! Temporary Error message
   character(1024)               :: PriPath                                   ! Path name of the primary file
   character(1024)               :: FTitle                                    ! "File Title": the 2nd line of the input file, which contains a description of its contents
   character(200)                :: Line                                      ! Temporary storage of a line from the input file (to compare with "default")
   character(*), parameter       :: RoutineName = 'readxfoiltable'
   integer(IntKi)                :: sizeRe                                     ! 
   integer(IntKi)                :: sizeaoa                                    !    
   integer(IntKi)                :: cou1,UnEc                                  ! loop counter  
   real(DbKi),dimension(:,:),ALLOCATABLE      :: temp1
      ! Initialize some variables:
   ErrStat = ErrID_None
   ErrMsg  = ""
   

   CALL GetPath( InputFile, PriPath )     ! Input files will be relative to the path where the primary input file is located.

	DO I=1,BldNodes
    IF (InputFileData%ITRIP.eq.0) THEN
	FileName = TRIM(PriPath)//'AirfoilsModified/BL/AF'//TRIM(Num2LStr(I))//'.txt'
    ELSE
	FileName = TRIM(PriPath)//'AirfoilsModified/BL_TRIPPED/AF'//TRIM(Num2LStr(I))//'.txt'
    ENDIF


 
   CALL GetNewUnit( UnIn, ErrStat2, ErrMsg2 )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

   CALL OpenFInpFile ( UnIn, FileName, ErrStat2, ErrMsg2 )
!      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

      IF ( ErrStat2 >= AbortErrLev ) THEN
         print*, 'File Not Found ', FileName
         print*, 'Aborting due to missing file AeroAcoustics require if TNO is on and Xfoil need tabulated data '
 	 call abort
         RETURN
      END IF


      CALL ReadCom( UnIn, FileName, 'File header: Module Version (line 1)', ErrStat2, ErrMsg2, UnEc )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   
   
      CALL ReadVar( UnIn, FileName, sizere, 'sizere',   'Echo flag', ErrStat2, ErrMsg2, UnEc )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

      CALL AllocAry( InputFileData%ReListXfoil,sizere, 'InputFileData%ReListXfoil', ErrStat2, ErrMsg2)
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

      DO cou=1,sizere
      CALL ReadVar( UnIn, FileName, InputFileData%ReListXfoil(cou), 'InputFileData%ReListXfoil','Echo flag', ErrStat2, ErrMsg2, UnEc )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )		
      ENDDO

     CALL ReadCom( UnIn, FileName, 'File header: Module Version (line 1)', ErrStat2, ErrMsg2, UnEc )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   
   
      CALL ReadVar( UnIn, FileName, sizeaoa, 'sizeaoa',   'Echo flag', ErrStat2, ErrMsg2, UnEc )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      CALL AllocAry( InputFileData%AoAListXfoil,sizeaoa, 'InputFileData%AoAListXfoil', ErrStat2, ErrMsg2)
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )

      DO cou=1,sizeaoa
      CALL ReadVar( UnIn, FileName, InputFileData%AoAListXfoil(cou), 'InputFileData%AoAListXfoil','Echo flag', ErrStat2, ErrMsg2, UnEc )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )		
      ENDDO


     IF (I .eq. 1) THEN
         CALL AllocAry( InputFileData%Pres_DispThick,sizeaoa,sizere, BldNodes,'InputFileData%Pres_DispThick', ErrStat2, ErrMsg2)
        CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         CALL AllocAry( InputFileData%Suct_DispThick,sizeaoa,sizere, BldNodes,'InputFileData%Suct_DispThick', ErrStat2, ErrMsg2)
        CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         CALL AllocAry( InputFileData%Pres_BLThick,sizeaoa,sizere, BldNodes,'InputFileData%Pres_BLThick', ErrStat2, ErrMsg2)
        CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         CALL AllocAry( InputFileData%Suct_BLThick,sizeaoa,sizere, BldNodes,'InputFileData%Suct_BLThick', ErrStat2, ErrMsg2)
        CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         CALL AllocAry( InputFileData%Pres_Cf,sizeaoa,sizere, BldNodes,'InputFileData%Pres_Cf', ErrStat2, ErrMsg2)
        CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         CALL AllocAry( InputFileData%Suct_Cf,sizeaoa,sizere, BldNodes,'InputFileData%Suct_Cf', ErrStat2, ErrMsg2)
        CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         CALL AllocAry( InputFileData%Pres_EdgeVelRat,sizeaoa,sizere, BldNodes,'InputFileData%Pres_EdgeVelRat', ErrStat2, ErrMsg2)
        CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         CALL AllocAry( InputFileData%Suct_EdgeVelRat,sizeaoa,sizere, BldNodes,'InputFileData%Suct_EdgeVelRat', ErrStat2, ErrMsg2)
        CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )


         CALL AllocAry( temp1,8,sizeaoa*sizere, 'InputFileData%Suct_Cf', ErrStat2, ErrMsg2)
        CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
     ENDIF

     DO cou1=1,6
	    CALL ReadCom( UnIn, FileName, 'File header: Module Version (line 1)', ErrStat2, ErrMsg2, UnEc )
     ENDDO


     DO cou1=1,size(temp1,1)
   	read(UnIn,*)  temp1(cou1,:)
     ENDDO

	loop1=0
      DO cou1=1,sizeaoa
	      DO cou=1,sizere
		loop1=loop1+1
		InputFileData%Pres_BLThick(cou1,cou,I)    = temp1(1,loop1)
		InputFileData%Pres_DispThick(cou1,cou,I)  = temp1(2,loop1)
		InputFileData%Pres_Cf(cou1,cou,I)         = temp1(3,loop1)
		InputFileData%Pres_EdgeVelRat(cou1,cou,I) = temp1(4,loop1)
		InputFileData%Suct_BLThick(cou1,cou,I)    = temp1(5,loop1)
		InputFileData%Suct_DispThick(cou1,cou,I)  = temp1(6,loop1)
		InputFileData%Suct_Cf(cou1,cou,I)         = temp1(7,loop1)
		InputFileData%Suct_EdgeVelRat(cou1,cou,I) = temp1(8,loop1)

              ENDDO
      ENDDO	

     !---------------------- END OF FILE -----------------------------------------
    ENDDO 
   CALL Cleanup( )
   RETURN


CONTAINS
   !...............................................................................................................................
   SUBROUTINE Cleanup()
   ! This subroutine cleans up any local variables and closes input files
   !...............................................................................................................................

   IF (UnIn > 0) CLOSE ( UnIn )

   END SUBROUTINE Cleanup
   !...............................................................................................................................
END SUBROUTINE ReadXfoilTables
!----------------------------------------------------------------------------------------------------------------------------------
!----------------------------------------------------------------------------------------------------------------------------------
!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE REadTICalcTables( InputFile,InputFileData,  ErrStat, ErrMsg )
    ! Passed variables
    integer(IntKi),     intent(out)     :: ErrStat                             ! Error status
    character(*),       intent(out)     :: ErrMsg                              ! Error message
    type(AA_InputFile), intent(inout)   :: InputFileData                       ! All the data in the Noise input file
    character(*),       intent(in)      :: InputFile                           ! Name of the file containing the primary input data
    ! Local variables:
    integer(IntKi)                :: I                                         ! loop counter
    integer(IntKi)                :: UnIn,UnIn2                                ! Unit number for reading file
    integer(IntKi)                :: loop1                                     ! loop counter
    character(1024)               :: FileName                              ! name of the files containing obesever location
    integer(IntKi)                :: ErrStat2, IOS,cou                             ! Temporary Error status
    logical                       :: Echo                                      ! Determines if an echo file should be written
    character(ErrMsgLen)          :: ErrMsg2                                   ! Temporary Error message
    character(1024)               :: PriPath                                   ! Path name of the primary file
    character(1024)               :: FTitle                                    ! "File Title": the 2nd line of the input file, which contains a description of its contents
    character(200)                :: Line                                      ! Temporary storage of a line from the input file (to compare with "default")
    character(*), parameter       :: RoutineName = 'REadTICalcTables'
    integer(IntKi)                :: GridY                                     ! 
    integer(IntKi)                :: GridZ                                    !    
    integer(IntKi)                :: cou1,UnEc                                  ! loop counter  
    ! Initialize some variables:
    ErrStat = ErrID_None
    ErrMsg  = ""

    CALL GetPath( InputFile, PriPath )     ! Input files will be relative to the path where the primary input file is located.

    FileName = TRIM(PriPath)//'TIGrid_In.txt'

    CALL GetNewUnit( UnIn, ErrStat2, ErrMsg2); call check()
    CALL OpenFInpFile ( UnIn, FileName, ErrStat2, ErrMsg2 ); if(Failed()) return

    CALL ReadCom(UnIn, FileName, 'Text Line', ErrStat2, ErrMsg2, UnEc); call check
    CALL ReadVar(UnIn, FileName, GridY, 'GridY',   'Echo flag', ErrStat2, ErrMsg2, UnEc); call check
    CALL ReadCom(UnIn, FileName, 'Text Line', ErrStat2, ErrMsg2, UnEc );call check
    CALL ReadVar(UnIn, FileName, GridZ, 'GridZ',   'Echo flag', ErrStat2, ErrMsg2, UnEc); call check
    CALL ReadCom(UnIn, FileName, 'Text Line', ErrStat2, ErrMsg2, UnEc); call check
    CALL ReadVar(UnIn, FileName, InputFileData%dy_turb_in, 'InputFileData%dy_turb_in',   'Echo flag', ErrStat2, ErrMsg2, UnEc); call check
    CALL ReadCom(UnIn, FileName, 'Text Line', ErrStat2, ErrMsg2, UnEc); call check
    CALL ReadVar(UnIn, FileName, InputFileData%dz_turb_in, 'InputFileData%dz_turb_in',   'Echo flag', ErrStat2, ErrMsg2, UnEc); call check
    if(Failed()) return

    CALL AllocAry( InputFileData%TI_Grid_In,GridZ,GridY,'InputFileData%TI_Grid_In', ErrStat2, ErrMsg2); 
    if(Failed()) return
    DO cou1=1,size(InputFileData%TI_Grid_In,1)
        read(UnIn,*)  InputFileData%TI_Grid_In(cou1,:)
    ENDDO		 
    !---------------------- END OF FILE -----------------------------------------
    CALL Cleanup( )

CONTAINS
    logical function Failed()
        call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName) 
        Failed =  ErrStat >= AbortErrLev
        if(Failed) call cleanup()
    end function Failed
   SUBROUTINE Check()
       CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
   END SUBROUTINE Check
   SUBROUTINE Cleanup()
       IF (UnIn > 0) CLOSE ( UnIn )
   END SUBROUTINE Cleanup
END SUBROUTINE REadTICalcTables

!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE AA_PrintSum( InputFileData, p, u, y, ErrStat, ErrMsg )
    ! This routine generates the summary file, which contains a summary of input file options.
    ! passed variables
    TYPE(AA_InputFile),        INTENT(IN)  :: InputFileData                        ! Input-file data
    TYPE(AA_ParameterType),    INTENT(IN)  :: p                                    ! Parameters
    TYPE(AA_InputType),        INTENT(IN)  :: u                                    ! inputs 
    TYPE(AA_OutputType),       INTENT(IN)  :: y                                    ! outputs
    INTEGER(IntKi),            INTENT(OUT) :: ErrStat
    CHARACTER(*),              INTENT(OUT) :: ErrMsg
    ! Local variables.
    INTEGER(IntKi)               :: I                                               ! Index for the nodes.
    INTEGER(IntKi)               :: UnSu                                            ! I/O unit number for the summary output file
    CHARACTER(*), PARAMETER      :: FmtDat    = '(A,T35,1(:,F13.3))'                ! Format for outputting mass and modal data.
    CHARACTER(*), PARAMETER      :: FmtDatT   = '(A,T35,1(:,F13.8))'                ! Format for outputting time steps.
    CHARACTER(30)                :: OutPFmt                                         ! Format to print list of selected output channels to summary file
    CHARACTER(100)               :: Msg                                             ! temporary string for writing appropriate text to summary file
    ! Open the summary file and give it a heading.
    RETURN
END SUBROUTINE AA_PrintSum

!----------------------------------------------------------------------------------------------------------------------------------
SUBROUTINE Calc_WriteOutput( p, u, m, y, ErrStat, ErrMsg )
   TYPE(AA_ParameterType),    INTENT(IN   )  :: p                                 ! The module parameters
   TYPE(AA_InputType),        INTENT(IN   )  :: u                                 ! inputs
   TYPE(AA_MiscVarType),      INTENT(INOUT)  :: m                                 ! misc variables
   TYPE(AA_OutputType),       INTENT(INOUT)  :: y                                 ! outputs
   INTEGER(IntKi),            INTENT(  OUT)  :: ErrStat                           ! The error status code
   CHARACTER(*),              INTENT(  OUT)  :: ErrMsg                            ! The error message, if an error occurred
   ! local variables
   CHARACTER(*), PARAMETER                   :: RoutineName = 'Calc_WriteOutput'
   INTEGER(intKi)                            :: ErrStat2
   CHARACTER(ErrMsgLen)                      :: ErrMsg2
   INTEGER(IntKi)                            :: j,k,counter,i,oi
   ! start routine:
   ErrStat = ErrID_None
   ErrMsg  = ""
   ! FOR THE FIRST OUTPUT FILE
   IF  (p%NrOutFile .gt. 0) THEN 
       ! This loop order has to be kept even though not the most efficient unless OASPL size and loop is changed in subtoutine CalcOutput  in AeroAcousitcs.f90 
       y%WriteOutput(1:p%NrObsLoc)=y%DirectiviOutput

       counter=p%NrObsLoc
       do k=1,p%NrObsLoc
           do i=1,p%NumBlades
               do j=1,p%NumBlNds
                   counter=counter+1
                   y%WriteOutput(counter) = y%OASPL(k,j,i)                        
                   !  InitOut%WriteOutputHdr(i) = "Bl "//trim(num2lstr(m))//" Nd "//trim(num2lstr(k))//" Obs "//trim(num2lstr(j))
                   !  InitOut%WriteOutputUnt(i) = "SPL"
               enddo
           enddo	
       enddo
   endif
   ! FOR THE SECOND OUTPUT FILE
   IF  (p%NrOutFile .gt. 1) THEN 
       counter=0
       DO J = 1, size(p%FreqList)
           DO K = 1,p%NrObsLoc
               DO I = 1,p%NumBlades
                   counter=counter+1
                   y%WriteOutputforPE(counter) = y%SumSpecNoise(J,K,I)                        
                   DO oi = 1,3
                       counter=counter+1
                       y%WriteOutputforPE(counter) = y%OutLECoords(oi,J,K,I)  
                   ENDDO                      
               END DO ! 
           END DO ! 
       ENDDO
   ENDIF
   ! FOR THE THIRD OUTPUT FILE
   IF  (p%NrOutFile .gt. 2) THEN 
       counter=0
       do k=1,p%NrObsLoc
           do i=1,p%NumBlades
               do j=1,p%NumBlNds
                   do oi=1,size(y%OASPL_Mech,1)
                       counter=counter+1
                       y%WriteOutputSep(counter) = y%OASPL_Mech(oi,k,j,i)                        
                   enddo
               enddo
           enddo	
       enddo
   ENDIF
   ! FOR THE FOURTH OUTPUT FILE
   IF  (p%NrOutFile .gt. 3) THEN 
       counter=0
       DO J = 1, size(p%FreqList)
           DO K = 1,p%NrObsLoc
               do oi=1,size(y%OASPL_Mech,1)
                   counter=counter+1
                   y%WriteOutputSepFreq(counter) = y%SumSpecNoiseSep(oi,K,J)                        
               END DO ! 
           END DO ! 
       ENDDO
   ENDIF            
END SUBROUTINE Calc_WriteOutput
!----------------------------------------------------------------------------------------------------------------------------------
END MODULE AeroAcoustics_IO
