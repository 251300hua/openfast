!STARTOFREGISTRYGENERATEDFILE 'FVW_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! FVW_Types
!.................................................................................................................................
! This file is part of FVW.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in FVW. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE FVW_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE IfW_UniformWind_Types
USE IfW_TSFFWind_Types
USE IfW_BladedFFWind_Types
USE IfW_HAWCWind_Types
USE IfW_UserWind_Types
USE IfW_4Dext_Types
USE Lidar_Types
USE InflowWind_Types
USE AD14AeroConf_Types
USE NWTC_Library
IMPLICIT NONE
! =========  FVW_ParameterType  =======
  TYPE, PUBLIC :: FVW_ParameterType
    INTEGER(IntKi)  :: nWings      !< Number of Wings [-]
    INTEGER(IntKi)  :: nSpan      !< TODO, should be defined per wing. Number of spanwise element [-]
    INTEGER(IntKi)  :: nNWMax      !< Maximum number of nw panels [-]
    INTEGER(IntKi)  :: nFWMax      !< Maximum number of fw panels [-]
    INTEGER(IntKi)  :: nFWFree      !< Number of fw panels that are free [-]
    INTEGER(IntKi)  :: IntMethod      !< Integration Method (1=RK4, 2=AB4, 3=ABM4, 5=Euler1) [-]
    REAL(ReKi)  :: FreeWakeStart      !< Time when wake starts convecting (rolling up) [s]
    REAL(ReKi)  :: FullCirculationStart      !< Time when the circulation is full [s]
    INTEGER(IntKi)  :: CirculationMethod      !< Method to determine the circulation [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: PrescribedCirculation      !< Prescribed circulation on all lifting lines [m/s]
    INTEGER(IntKi)  :: CircSolvMaxIter      !< Maximum number of iterations for circulation solving [-]
    REAL(ReKi)  :: CircSolvConvCrit      !< Convergence criterion for circulation solving [-]
    REAL(ReKi)  :: CircSolvRelaxation      !< Relaxation factor for circulation solving [-]
    INTEGER(IntKi)  :: PrescribedPolar      !< (0=Use AD polars, 1=2PiAlpha, 2=sin(2pialpha) [-]
    INTEGER(IntKi)  :: RegFunction      !< Type of regularizaion function (LambOseen, Vatistas, see FVW_BiotSavart) [-]
    INTEGER(IntKi)  :: WakeRegMethod      !< Method for regularization (constant, stretching, age, etc.) [-]
    REAL(ReKi)  :: WakeRegFactor      !< Factor used in the regularization  [-]
  END TYPE FVW_ParameterType
! =======================
! =========  FVW_OtherStateType  =======
  TYPE, PUBLIC :: FVW_OtherStateType
    INTEGER(IntKi)  :: NULL      !< Number of active near wake panels [-]
  END TYPE FVW_OtherStateType
! =======================
! =========  FVW_MiscVarType  =======
  TYPE, PUBLIC :: FVW_MiscVarType
    LOGICAL  :: FirstCall      !< True if this is the first call to update state (used in CalcOutput) [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: LE      !< Leading edge points [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: TE      !< Trailing edge points [-]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: r_LL      !< Position    of the Lifting line panels [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: s_LL      !< Spanwise coordinate of LL elements [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: chord_LL      !< chord on LL cp  [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: s_CP_LL      !< Spanwise coordinate of LL CP [m]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: chord_CP_LL      !< chord on LL cp  [m]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: CP_LL      !< Coordinates of LL CP [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Tang      !< Unit Tangential vector on LL CP [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Norm      !< Unit Normal vector on LL CP     [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Orth      !< Unit Orthogonal vector on LL CP [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: dl      !< Vector of elementary length along the LL [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Area      !< Area of each LL panel [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Gamma_LL      !< Circulation on the wing lifting line (COPY of Constraint State) [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Vind_LL      !< Induced velocity on lifting line control points [m/s]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Vtot_LL      !< Total velocity on lifting line control points [m/s]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Vstr_LL      !< Structural velocity on LL CP [m/s]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Vwnd_LL      !< Wind on lifting line control points [m/s]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: Vwnd_NW      !< Wind on near wake panels [m/s]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: Vwnd_FW      !< Wind on far  wake panels [m/s]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: Vind_NW      !< Induced velocity on near wake panels [m/s]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: Vind_FW      !< Induced velocity on far  wake panels [m/s]
    INTEGER(IntKi)  :: nNW      !< Number of active near wake panels [-]
    INTEGER(IntKi)  :: nFW      !< Number of active far  wake panels [-]
  END TYPE FVW_MiscVarType
! =======================
! =========  FVW_InputType  =======
  TYPE, PUBLIC :: FVW_InputType
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: WingsMesh      !< - [Input Mesh defining position and orientation of wings]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: V_wind      !< Wind at requested points (r_wind) [-]
  END TYPE FVW_InputType
! =======================
! =========  FVW_OutputType  =======
  TYPE, PUBLIC :: FVW_OutputType
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Vind      !< TODO mesh  - Induced velocity vector.  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: r_wind      !< List of points where wind is requested for next time step [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Cl_KJ      !< Lift coefficient from circulation (Kutta-Joukowski) [-]
  END TYPE FVW_OutputType
! =======================
! =========  FVW_ContinuousStateType  =======
  TYPE, PUBLIC :: FVW_ContinuousStateType
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Gamma_NW      !< Circulation of the near wake panels [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: Gamma_FW      !< Circulation of the far  wake panels [-]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: r_NW      !< Position    of the near wake panels [-]
    REAL(ReKi) , DIMENSION(:,:,:,:), ALLOCATABLE  :: r_FW      !< Position    of the far  wake panels [-]
  END TYPE FVW_ContinuousStateType
! =======================
! =========  FVW_DiscreteStateType  =======
  TYPE, PUBLIC :: FVW_DiscreteStateType
    INTEGER(IntKi)  :: Null      !< Empty to satisfy framework [-]
  END TYPE FVW_DiscreteStateType
! =======================
! =========  FVW_ConstraintStateType  =======
  TYPE, PUBLIC :: FVW_ConstraintStateType
    REAL(ReKi)  :: residual 
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: Gamma_LL      !< Circulation on the wing lifting line [-]
  END TYPE FVW_ConstraintStateType
! =======================
! =========  FVW_InitInputType  =======
  TYPE, PUBLIC :: FVW_InitInputType
    CHARACTER(1024)  :: FVWFileName      !< Main FVW input file name [-]
    TYPE(MeshType) , DIMENSION(:), ALLOCATABLE  :: WingsMesh      !< Input Mesh defining position and orientation of wings (nSpan+1)  [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Chord      !< Chord of each blade element from input file [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: RElm      !< radius of center of each element [-]
    INTEGER(IntKi)  :: NumBl      !< Number of blades [-]
  END TYPE FVW_InitInputType
! =======================
! =========  FVW_InputFile  =======
  TYPE, PUBLIC :: FVW_InputFile
    INTEGER(IntKi)  :: CirculationMethod      !< Method to determine the circulation [-]
    CHARACTER(1024)  :: CirculationFile      !< Prescribed circulation file [-]
    INTEGER(IntKi)  :: CircSolvMaxIter      !< Maximum number of iterations for circulation solving [-]
    REAL(ReKi)  :: CircSolvConvCrit      !< Convergence criterion for circulation solving [-]
    REAL(ReKi)  :: CircSolvRelaxation      !< Relaxation factor for circulation solving [-]
    INTEGER(IntKi)  :: IntMethod      !< Integration Method (1=RK4, 2=AB4, 3=ABM4, 5=Euler1, 7=Corrector/Predictor) [-]
    LOGICAL  :: FreeWake      !< Disable roll up, wake convects with wind only (flag) [-]
    REAL(ReKi)  :: FreeWakeStart      !< Time when wake starts convecting (rolling up) [s]
    REAL(ReKi)  :: FullCirculationStart      !< Time when the circulation is full [s]
    INTEGER(IntKi)  :: PrescribedPolar      !< (0=Use AD polars, 1=2PiAlpha, 2=sin(2pialpha) [-]
    INTEGER(IntKi)  :: nNWPanels      !< Number of nw panels [-]
    INTEGER(IntKi)  :: nFWPanels      !< Number of fw panels [-]
    INTEGER(IntKi)  :: nFWPanelsFree      !< Number of fw panels that are free [-]
    INTEGER(IntKi)  :: RegFunction      !< Type of regularizaion function (LambOseen, Vatistas, see FVW_BiotSavart) [-]
    INTEGER(IntKi)  :: WakeRegMethod      !< Method for regularization (constant, stretching, age, etc.) [-]
    REAL(ReKi)  :: WakeRegFactor      !< Factor used in the regularization  [-]
  END TYPE FVW_InputFile
! =======================
! =========  FVW_InitOutputType  =======
  TYPE, PUBLIC :: FVW_InitOutputType
    INTEGER(IntKi)  :: Null      !< Empty parameter to satisfy framework [-]
  END TYPE FVW_InitOutputType
! =======================
CONTAINS
 SUBROUTINE FVW_CopyParam( SrcParamData, DstParamData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_ParameterType), INTENT(IN) :: SrcParamData
   TYPE(FVW_ParameterType), INTENT(INOUT) :: DstParamData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyParam'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstParamData%nWings = SrcParamData%nWings
    DstParamData%nSpan = SrcParamData%nSpan
    DstParamData%nNWMax = SrcParamData%nNWMax
    DstParamData%nFWMax = SrcParamData%nFWMax
    DstParamData%nFWFree = SrcParamData%nFWFree
    DstParamData%IntMethod = SrcParamData%IntMethod
    DstParamData%FreeWakeStart = SrcParamData%FreeWakeStart
    DstParamData%FullCirculationStart = SrcParamData%FullCirculationStart
    DstParamData%CirculationMethod = SrcParamData%CirculationMethod
IF (ALLOCATED(SrcParamData%PrescribedCirculation)) THEN
  i1_l = LBOUND(SrcParamData%PrescribedCirculation,1)
  i1_u = UBOUND(SrcParamData%PrescribedCirculation,1)
  IF (.NOT. ALLOCATED(DstParamData%PrescribedCirculation)) THEN 
    ALLOCATE(DstParamData%PrescribedCirculation(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstParamData%PrescribedCirculation.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstParamData%PrescribedCirculation = SrcParamData%PrescribedCirculation
ENDIF
    DstParamData%CircSolvMaxIter = SrcParamData%CircSolvMaxIter
    DstParamData%CircSolvConvCrit = SrcParamData%CircSolvConvCrit
    DstParamData%CircSolvRelaxation = SrcParamData%CircSolvRelaxation
    DstParamData%PrescribedPolar = SrcParamData%PrescribedPolar
    DstParamData%RegFunction = SrcParamData%RegFunction
    DstParamData%WakeRegMethod = SrcParamData%WakeRegMethod
    DstParamData%WakeRegFactor = SrcParamData%WakeRegFactor
 END SUBROUTINE FVW_CopyParam

 SUBROUTINE FVW_DestroyParam( ParamData, ErrStat, ErrMsg )
  TYPE(FVW_ParameterType), INTENT(INOUT) :: ParamData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyParam'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ParamData%PrescribedCirculation)) THEN
  DEALLOCATE(ParamData%PrescribedCirculation)
ENDIF
 END SUBROUTINE FVW_DestroyParam

 SUBROUTINE FVW_PackParam( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FVW_ParameterType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_PackParam'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! nWings
      Int_BufSz  = Int_BufSz  + 1  ! nSpan
      Int_BufSz  = Int_BufSz  + 1  ! nNWMax
      Int_BufSz  = Int_BufSz  + 1  ! nFWMax
      Int_BufSz  = Int_BufSz  + 1  ! nFWFree
      Int_BufSz  = Int_BufSz  + 1  ! IntMethod
      Re_BufSz   = Re_BufSz   + 1  ! FreeWakeStart
      Re_BufSz   = Re_BufSz   + 1  ! FullCirculationStart
      Int_BufSz  = Int_BufSz  + 1  ! CirculationMethod
  Int_BufSz   = Int_BufSz   + 1     ! PrescribedCirculation allocated yes/no
  IF ( ALLOCATED(InData%PrescribedCirculation) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! PrescribedCirculation upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%PrescribedCirculation)  ! PrescribedCirculation
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! CircSolvMaxIter
      Re_BufSz   = Re_BufSz   + 1  ! CircSolvConvCrit
      Re_BufSz   = Re_BufSz   + 1  ! CircSolvRelaxation
      Int_BufSz  = Int_BufSz  + 1  ! PrescribedPolar
      Int_BufSz  = Int_BufSz  + 1  ! RegFunction
      Int_BufSz  = Int_BufSz  + 1  ! WakeRegMethod
      Re_BufSz   = Re_BufSz   + 1  ! WakeRegFactor
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%nWings
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%nSpan
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%nNWMax
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%nFWMax
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%nFWFree
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%IntMethod
      Int_Xferred   = Int_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%FreeWakeStart
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%FullCirculationStart
      Re_Xferred   = Re_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%CirculationMethod
      Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. ALLOCATED(InData%PrescribedCirculation) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%PrescribedCirculation,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%PrescribedCirculation,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%PrescribedCirculation)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%PrescribedCirculation))-1 ) = PACK(InData%PrescribedCirculation,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%PrescribedCirculation)
  END IF
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%CircSolvMaxIter
      Int_Xferred   = Int_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%CircSolvConvCrit
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%CircSolvRelaxation
      Re_Xferred   = Re_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%PrescribedPolar
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%RegFunction
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%WakeRegMethod
      Int_Xferred   = Int_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%WakeRegFactor
      Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE FVW_PackParam

 SUBROUTINE FVW_UnPackParam( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FVW_ParameterType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
  INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_UnPackParam'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      OutData%nWings = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      OutData%nSpan = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      OutData%nNWMax = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      OutData%nFWMax = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      OutData%nFWFree = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      OutData%IntMethod = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      OutData%FreeWakeStart = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%FullCirculationStart = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%CirculationMethod = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! PrescribedCirculation not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%PrescribedCirculation)) DEALLOCATE(OutData%PrescribedCirculation)
    ALLOCATE(OutData%PrescribedCirculation(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%PrescribedCirculation.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%PrescribedCirculation)>0) OutData%PrescribedCirculation = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%PrescribedCirculation))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%PrescribedCirculation)
    DEALLOCATE(mask1)
  END IF
      OutData%CircSolvMaxIter = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      OutData%CircSolvConvCrit = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%CircSolvRelaxation = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%PrescribedPolar = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      OutData%RegFunction = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      OutData%WakeRegMethod = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      OutData%WakeRegFactor = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
 END SUBROUTINE FVW_UnPackParam

 SUBROUTINE FVW_CopyOtherState( SrcOtherStateData, DstOtherStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_OtherStateType), INTENT(IN) :: SrcOtherStateData
   TYPE(FVW_OtherStateType), INTENT(INOUT) :: DstOtherStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyOtherState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstOtherStateData%NULL = SrcOtherStateData%NULL
 END SUBROUTINE FVW_CopyOtherState

 SUBROUTINE FVW_DestroyOtherState( OtherStateData, ErrStat, ErrMsg )
  TYPE(FVW_OtherStateType), INTENT(INOUT) :: OtherStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyOtherState'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE FVW_DestroyOtherState

 SUBROUTINE FVW_PackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FVW_OtherStateType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_PackOtherState'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! NULL
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%NULL
      Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE FVW_PackOtherState

 SUBROUTINE FVW_UnPackOtherState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FVW_OtherStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_UnPackOtherState'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      OutData%NULL = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
 END SUBROUTINE FVW_UnPackOtherState

 SUBROUTINE FVW_CopyMisc( SrcMiscData, DstMiscData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_MiscVarType), INTENT(IN) :: SrcMiscData
   TYPE(FVW_MiscVarType), INTENT(INOUT) :: DstMiscData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyMisc'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstMiscData%FirstCall = SrcMiscData%FirstCall
IF (ALLOCATED(SrcMiscData%LE)) THEN
  i1_l = LBOUND(SrcMiscData%LE,1)
  i1_u = UBOUND(SrcMiscData%LE,1)
  i2_l = LBOUND(SrcMiscData%LE,2)
  i2_u = UBOUND(SrcMiscData%LE,2)
  i3_l = LBOUND(SrcMiscData%LE,3)
  i3_u = UBOUND(SrcMiscData%LE,3)
  IF (.NOT. ALLOCATED(DstMiscData%LE)) THEN 
    ALLOCATE(DstMiscData%LE(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%LE.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%LE = SrcMiscData%LE
ENDIF
IF (ALLOCATED(SrcMiscData%TE)) THEN
  i1_l = LBOUND(SrcMiscData%TE,1)
  i1_u = UBOUND(SrcMiscData%TE,1)
  i2_l = LBOUND(SrcMiscData%TE,2)
  i2_u = UBOUND(SrcMiscData%TE,2)
  i3_l = LBOUND(SrcMiscData%TE,3)
  i3_u = UBOUND(SrcMiscData%TE,3)
  IF (.NOT. ALLOCATED(DstMiscData%TE)) THEN 
    ALLOCATE(DstMiscData%TE(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%TE.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%TE = SrcMiscData%TE
ENDIF
IF (ALLOCATED(SrcMiscData%r_LL)) THEN
  i1_l = LBOUND(SrcMiscData%r_LL,1)
  i1_u = UBOUND(SrcMiscData%r_LL,1)
  i2_l = LBOUND(SrcMiscData%r_LL,2)
  i2_u = UBOUND(SrcMiscData%r_LL,2)
  i3_l = LBOUND(SrcMiscData%r_LL,3)
  i3_u = UBOUND(SrcMiscData%r_LL,3)
  i4_l = LBOUND(SrcMiscData%r_LL,4)
  i4_u = UBOUND(SrcMiscData%r_LL,4)
  IF (.NOT. ALLOCATED(DstMiscData%r_LL)) THEN 
    ALLOCATE(DstMiscData%r_LL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%r_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%r_LL = SrcMiscData%r_LL
ENDIF
IF (ALLOCATED(SrcMiscData%s_LL)) THEN
  i1_l = LBOUND(SrcMiscData%s_LL,1)
  i1_u = UBOUND(SrcMiscData%s_LL,1)
  i2_l = LBOUND(SrcMiscData%s_LL,2)
  i2_u = UBOUND(SrcMiscData%s_LL,2)
  IF (.NOT. ALLOCATED(DstMiscData%s_LL)) THEN 
    ALLOCATE(DstMiscData%s_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%s_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%s_LL = SrcMiscData%s_LL
ENDIF
IF (ALLOCATED(SrcMiscData%chord_LL)) THEN
  i1_l = LBOUND(SrcMiscData%chord_LL,1)
  i1_u = UBOUND(SrcMiscData%chord_LL,1)
  i2_l = LBOUND(SrcMiscData%chord_LL,2)
  i2_u = UBOUND(SrcMiscData%chord_LL,2)
  IF (.NOT. ALLOCATED(DstMiscData%chord_LL)) THEN 
    ALLOCATE(DstMiscData%chord_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%chord_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%chord_LL = SrcMiscData%chord_LL
ENDIF
IF (ALLOCATED(SrcMiscData%s_CP_LL)) THEN
  i1_l = LBOUND(SrcMiscData%s_CP_LL,1)
  i1_u = UBOUND(SrcMiscData%s_CP_LL,1)
  i2_l = LBOUND(SrcMiscData%s_CP_LL,2)
  i2_u = UBOUND(SrcMiscData%s_CP_LL,2)
  IF (.NOT. ALLOCATED(DstMiscData%s_CP_LL)) THEN 
    ALLOCATE(DstMiscData%s_CP_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%s_CP_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%s_CP_LL = SrcMiscData%s_CP_LL
ENDIF
IF (ALLOCATED(SrcMiscData%chord_CP_LL)) THEN
  i1_l = LBOUND(SrcMiscData%chord_CP_LL,1)
  i1_u = UBOUND(SrcMiscData%chord_CP_LL,1)
  i2_l = LBOUND(SrcMiscData%chord_CP_LL,2)
  i2_u = UBOUND(SrcMiscData%chord_CP_LL,2)
  IF (.NOT. ALLOCATED(DstMiscData%chord_CP_LL)) THEN 
    ALLOCATE(DstMiscData%chord_CP_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%chord_CP_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%chord_CP_LL = SrcMiscData%chord_CP_LL
ENDIF
IF (ALLOCATED(SrcMiscData%CP_LL)) THEN
  i1_l = LBOUND(SrcMiscData%CP_LL,1)
  i1_u = UBOUND(SrcMiscData%CP_LL,1)
  i2_l = LBOUND(SrcMiscData%CP_LL,2)
  i2_u = UBOUND(SrcMiscData%CP_LL,2)
  i3_l = LBOUND(SrcMiscData%CP_LL,3)
  i3_u = UBOUND(SrcMiscData%CP_LL,3)
  IF (.NOT. ALLOCATED(DstMiscData%CP_LL)) THEN 
    ALLOCATE(DstMiscData%CP_LL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%CP_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%CP_LL = SrcMiscData%CP_LL
ENDIF
IF (ALLOCATED(SrcMiscData%Tang)) THEN
  i1_l = LBOUND(SrcMiscData%Tang,1)
  i1_u = UBOUND(SrcMiscData%Tang,1)
  i2_l = LBOUND(SrcMiscData%Tang,2)
  i2_u = UBOUND(SrcMiscData%Tang,2)
  i3_l = LBOUND(SrcMiscData%Tang,3)
  i3_u = UBOUND(SrcMiscData%Tang,3)
  IF (.NOT. ALLOCATED(DstMiscData%Tang)) THEN 
    ALLOCATE(DstMiscData%Tang(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Tang.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Tang = SrcMiscData%Tang
ENDIF
IF (ALLOCATED(SrcMiscData%Norm)) THEN
  i1_l = LBOUND(SrcMiscData%Norm,1)
  i1_u = UBOUND(SrcMiscData%Norm,1)
  i2_l = LBOUND(SrcMiscData%Norm,2)
  i2_u = UBOUND(SrcMiscData%Norm,2)
  i3_l = LBOUND(SrcMiscData%Norm,3)
  i3_u = UBOUND(SrcMiscData%Norm,3)
  IF (.NOT. ALLOCATED(DstMiscData%Norm)) THEN 
    ALLOCATE(DstMiscData%Norm(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Norm.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Norm = SrcMiscData%Norm
ENDIF
IF (ALLOCATED(SrcMiscData%Orth)) THEN
  i1_l = LBOUND(SrcMiscData%Orth,1)
  i1_u = UBOUND(SrcMiscData%Orth,1)
  i2_l = LBOUND(SrcMiscData%Orth,2)
  i2_u = UBOUND(SrcMiscData%Orth,2)
  i3_l = LBOUND(SrcMiscData%Orth,3)
  i3_u = UBOUND(SrcMiscData%Orth,3)
  IF (.NOT. ALLOCATED(DstMiscData%Orth)) THEN 
    ALLOCATE(DstMiscData%Orth(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Orth.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Orth = SrcMiscData%Orth
ENDIF
IF (ALLOCATED(SrcMiscData%dl)) THEN
  i1_l = LBOUND(SrcMiscData%dl,1)
  i1_u = UBOUND(SrcMiscData%dl,1)
  i2_l = LBOUND(SrcMiscData%dl,2)
  i2_u = UBOUND(SrcMiscData%dl,2)
  i3_l = LBOUND(SrcMiscData%dl,3)
  i3_u = UBOUND(SrcMiscData%dl,3)
  IF (.NOT. ALLOCATED(DstMiscData%dl)) THEN 
    ALLOCATE(DstMiscData%dl(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%dl.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%dl = SrcMiscData%dl
ENDIF
IF (ALLOCATED(SrcMiscData%Area)) THEN
  i1_l = LBOUND(SrcMiscData%Area,1)
  i1_u = UBOUND(SrcMiscData%Area,1)
  i2_l = LBOUND(SrcMiscData%Area,2)
  i2_u = UBOUND(SrcMiscData%Area,2)
  IF (.NOT. ALLOCATED(DstMiscData%Area)) THEN 
    ALLOCATE(DstMiscData%Area(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Area.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Area = SrcMiscData%Area
ENDIF
IF (ALLOCATED(SrcMiscData%Gamma_LL)) THEN
  i1_l = LBOUND(SrcMiscData%Gamma_LL,1)
  i1_u = UBOUND(SrcMiscData%Gamma_LL,1)
  i2_l = LBOUND(SrcMiscData%Gamma_LL,2)
  i2_u = UBOUND(SrcMiscData%Gamma_LL,2)
  IF (.NOT. ALLOCATED(DstMiscData%Gamma_LL)) THEN 
    ALLOCATE(DstMiscData%Gamma_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Gamma_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Gamma_LL = SrcMiscData%Gamma_LL
ENDIF
IF (ALLOCATED(SrcMiscData%Vind_LL)) THEN
  i1_l = LBOUND(SrcMiscData%Vind_LL,1)
  i1_u = UBOUND(SrcMiscData%Vind_LL,1)
  i2_l = LBOUND(SrcMiscData%Vind_LL,2)
  i2_u = UBOUND(SrcMiscData%Vind_LL,2)
  i3_l = LBOUND(SrcMiscData%Vind_LL,3)
  i3_u = UBOUND(SrcMiscData%Vind_LL,3)
  IF (.NOT. ALLOCATED(DstMiscData%Vind_LL)) THEN 
    ALLOCATE(DstMiscData%Vind_LL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Vind_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Vind_LL = SrcMiscData%Vind_LL
ENDIF
IF (ALLOCATED(SrcMiscData%Vtot_LL)) THEN
  i1_l = LBOUND(SrcMiscData%Vtot_LL,1)
  i1_u = UBOUND(SrcMiscData%Vtot_LL,1)
  i2_l = LBOUND(SrcMiscData%Vtot_LL,2)
  i2_u = UBOUND(SrcMiscData%Vtot_LL,2)
  i3_l = LBOUND(SrcMiscData%Vtot_LL,3)
  i3_u = UBOUND(SrcMiscData%Vtot_LL,3)
  IF (.NOT. ALLOCATED(DstMiscData%Vtot_LL)) THEN 
    ALLOCATE(DstMiscData%Vtot_LL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Vtot_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Vtot_LL = SrcMiscData%Vtot_LL
ENDIF
IF (ALLOCATED(SrcMiscData%Vstr_LL)) THEN
  i1_l = LBOUND(SrcMiscData%Vstr_LL,1)
  i1_u = UBOUND(SrcMiscData%Vstr_LL,1)
  i2_l = LBOUND(SrcMiscData%Vstr_LL,2)
  i2_u = UBOUND(SrcMiscData%Vstr_LL,2)
  i3_l = LBOUND(SrcMiscData%Vstr_LL,3)
  i3_u = UBOUND(SrcMiscData%Vstr_LL,3)
  IF (.NOT. ALLOCATED(DstMiscData%Vstr_LL)) THEN 
    ALLOCATE(DstMiscData%Vstr_LL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Vstr_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Vstr_LL = SrcMiscData%Vstr_LL
ENDIF
IF (ALLOCATED(SrcMiscData%Vwnd_LL)) THEN
  i1_l = LBOUND(SrcMiscData%Vwnd_LL,1)
  i1_u = UBOUND(SrcMiscData%Vwnd_LL,1)
  i2_l = LBOUND(SrcMiscData%Vwnd_LL,2)
  i2_u = UBOUND(SrcMiscData%Vwnd_LL,2)
  i3_l = LBOUND(SrcMiscData%Vwnd_LL,3)
  i3_u = UBOUND(SrcMiscData%Vwnd_LL,3)
  IF (.NOT. ALLOCATED(DstMiscData%Vwnd_LL)) THEN 
    ALLOCATE(DstMiscData%Vwnd_LL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Vwnd_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Vwnd_LL = SrcMiscData%Vwnd_LL
ENDIF
IF (ALLOCATED(SrcMiscData%Vwnd_NW)) THEN
  i1_l = LBOUND(SrcMiscData%Vwnd_NW,1)
  i1_u = UBOUND(SrcMiscData%Vwnd_NW,1)
  i2_l = LBOUND(SrcMiscData%Vwnd_NW,2)
  i2_u = UBOUND(SrcMiscData%Vwnd_NW,2)
  i3_l = LBOUND(SrcMiscData%Vwnd_NW,3)
  i3_u = UBOUND(SrcMiscData%Vwnd_NW,3)
  i4_l = LBOUND(SrcMiscData%Vwnd_NW,4)
  i4_u = UBOUND(SrcMiscData%Vwnd_NW,4)
  IF (.NOT. ALLOCATED(DstMiscData%Vwnd_NW)) THEN 
    ALLOCATE(DstMiscData%Vwnd_NW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Vwnd_NW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Vwnd_NW = SrcMiscData%Vwnd_NW
ENDIF
IF (ALLOCATED(SrcMiscData%Vwnd_FW)) THEN
  i1_l = LBOUND(SrcMiscData%Vwnd_FW,1)
  i1_u = UBOUND(SrcMiscData%Vwnd_FW,1)
  i2_l = LBOUND(SrcMiscData%Vwnd_FW,2)
  i2_u = UBOUND(SrcMiscData%Vwnd_FW,2)
  i3_l = LBOUND(SrcMiscData%Vwnd_FW,3)
  i3_u = UBOUND(SrcMiscData%Vwnd_FW,3)
  i4_l = LBOUND(SrcMiscData%Vwnd_FW,4)
  i4_u = UBOUND(SrcMiscData%Vwnd_FW,4)
  IF (.NOT. ALLOCATED(DstMiscData%Vwnd_FW)) THEN 
    ALLOCATE(DstMiscData%Vwnd_FW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Vwnd_FW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Vwnd_FW = SrcMiscData%Vwnd_FW
ENDIF
IF (ALLOCATED(SrcMiscData%Vind_NW)) THEN
  i1_l = LBOUND(SrcMiscData%Vind_NW,1)
  i1_u = UBOUND(SrcMiscData%Vind_NW,1)
  i2_l = LBOUND(SrcMiscData%Vind_NW,2)
  i2_u = UBOUND(SrcMiscData%Vind_NW,2)
  i3_l = LBOUND(SrcMiscData%Vind_NW,3)
  i3_u = UBOUND(SrcMiscData%Vind_NW,3)
  i4_l = LBOUND(SrcMiscData%Vind_NW,4)
  i4_u = UBOUND(SrcMiscData%Vind_NW,4)
  IF (.NOT. ALLOCATED(DstMiscData%Vind_NW)) THEN 
    ALLOCATE(DstMiscData%Vind_NW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Vind_NW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Vind_NW = SrcMiscData%Vind_NW
ENDIF
IF (ALLOCATED(SrcMiscData%Vind_FW)) THEN
  i1_l = LBOUND(SrcMiscData%Vind_FW,1)
  i1_u = UBOUND(SrcMiscData%Vind_FW,1)
  i2_l = LBOUND(SrcMiscData%Vind_FW,2)
  i2_u = UBOUND(SrcMiscData%Vind_FW,2)
  i3_l = LBOUND(SrcMiscData%Vind_FW,3)
  i3_u = UBOUND(SrcMiscData%Vind_FW,3)
  i4_l = LBOUND(SrcMiscData%Vind_FW,4)
  i4_u = UBOUND(SrcMiscData%Vind_FW,4)
  IF (.NOT. ALLOCATED(DstMiscData%Vind_FW)) THEN 
    ALLOCATE(DstMiscData%Vind_FW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstMiscData%Vind_FW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstMiscData%Vind_FW = SrcMiscData%Vind_FW
ENDIF
    DstMiscData%nNW = SrcMiscData%nNW
    DstMiscData%nFW = SrcMiscData%nFW
 END SUBROUTINE FVW_CopyMisc

 SUBROUTINE FVW_DestroyMisc( MiscData, ErrStat, ErrMsg )
  TYPE(FVW_MiscVarType), INTENT(INOUT) :: MiscData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyMisc'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(MiscData%LE)) THEN
  DEALLOCATE(MiscData%LE)
ENDIF
IF (ALLOCATED(MiscData%TE)) THEN
  DEALLOCATE(MiscData%TE)
ENDIF
IF (ALLOCATED(MiscData%r_LL)) THEN
  DEALLOCATE(MiscData%r_LL)
ENDIF
IF (ALLOCATED(MiscData%s_LL)) THEN
  DEALLOCATE(MiscData%s_LL)
ENDIF
IF (ALLOCATED(MiscData%chord_LL)) THEN
  DEALLOCATE(MiscData%chord_LL)
ENDIF
IF (ALLOCATED(MiscData%s_CP_LL)) THEN
  DEALLOCATE(MiscData%s_CP_LL)
ENDIF
IF (ALLOCATED(MiscData%chord_CP_LL)) THEN
  DEALLOCATE(MiscData%chord_CP_LL)
ENDIF
IF (ALLOCATED(MiscData%CP_LL)) THEN
  DEALLOCATE(MiscData%CP_LL)
ENDIF
IF (ALLOCATED(MiscData%Tang)) THEN
  DEALLOCATE(MiscData%Tang)
ENDIF
IF (ALLOCATED(MiscData%Norm)) THEN
  DEALLOCATE(MiscData%Norm)
ENDIF
IF (ALLOCATED(MiscData%Orth)) THEN
  DEALLOCATE(MiscData%Orth)
ENDIF
IF (ALLOCATED(MiscData%dl)) THEN
  DEALLOCATE(MiscData%dl)
ENDIF
IF (ALLOCATED(MiscData%Area)) THEN
  DEALLOCATE(MiscData%Area)
ENDIF
IF (ALLOCATED(MiscData%Gamma_LL)) THEN
  DEALLOCATE(MiscData%Gamma_LL)
ENDIF
IF (ALLOCATED(MiscData%Vind_LL)) THEN
  DEALLOCATE(MiscData%Vind_LL)
ENDIF
IF (ALLOCATED(MiscData%Vtot_LL)) THEN
  DEALLOCATE(MiscData%Vtot_LL)
ENDIF
IF (ALLOCATED(MiscData%Vstr_LL)) THEN
  DEALLOCATE(MiscData%Vstr_LL)
ENDIF
IF (ALLOCATED(MiscData%Vwnd_LL)) THEN
  DEALLOCATE(MiscData%Vwnd_LL)
ENDIF
IF (ALLOCATED(MiscData%Vwnd_NW)) THEN
  DEALLOCATE(MiscData%Vwnd_NW)
ENDIF
IF (ALLOCATED(MiscData%Vwnd_FW)) THEN
  DEALLOCATE(MiscData%Vwnd_FW)
ENDIF
IF (ALLOCATED(MiscData%Vind_NW)) THEN
  DEALLOCATE(MiscData%Vind_NW)
ENDIF
IF (ALLOCATED(MiscData%Vind_FW)) THEN
  DEALLOCATE(MiscData%Vind_FW)
ENDIF
 END SUBROUTINE FVW_DestroyMisc

 SUBROUTINE FVW_PackMisc( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FVW_MiscVarType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_PackMisc'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! FirstCall
  Int_BufSz   = Int_BufSz   + 1     ! LE allocated yes/no
  IF ( ALLOCATED(InData%LE) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! LE upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%LE)  ! LE
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! TE allocated yes/no
  IF ( ALLOCATED(InData%TE) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! TE upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%TE)  ! TE
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! r_LL allocated yes/no
  IF ( ALLOCATED(InData%r_LL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*4  ! r_LL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%r_LL)  ! r_LL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! s_LL allocated yes/no
  IF ( ALLOCATED(InData%s_LL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! s_LL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%s_LL)  ! s_LL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! chord_LL allocated yes/no
  IF ( ALLOCATED(InData%chord_LL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! chord_LL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%chord_LL)  ! chord_LL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! s_CP_LL allocated yes/no
  IF ( ALLOCATED(InData%s_CP_LL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! s_CP_LL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%s_CP_LL)  ! s_CP_LL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! chord_CP_LL allocated yes/no
  IF ( ALLOCATED(InData%chord_CP_LL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! chord_CP_LL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%chord_CP_LL)  ! chord_CP_LL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! CP_LL allocated yes/no
  IF ( ALLOCATED(InData%CP_LL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! CP_LL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%CP_LL)  ! CP_LL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Tang allocated yes/no
  IF ( ALLOCATED(InData%Tang) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! Tang upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Tang)  ! Tang
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Norm allocated yes/no
  IF ( ALLOCATED(InData%Norm) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! Norm upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Norm)  ! Norm
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Orth allocated yes/no
  IF ( ALLOCATED(InData%Orth) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! Orth upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Orth)  ! Orth
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! dl allocated yes/no
  IF ( ALLOCATED(InData%dl) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! dl upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%dl)  ! dl
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Area allocated yes/no
  IF ( ALLOCATED(InData%Area) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Area upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Area)  ! Area
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Gamma_LL allocated yes/no
  IF ( ALLOCATED(InData%Gamma_LL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Gamma_LL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Gamma_LL)  ! Gamma_LL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Vind_LL allocated yes/no
  IF ( ALLOCATED(InData%Vind_LL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! Vind_LL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Vind_LL)  ! Vind_LL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Vtot_LL allocated yes/no
  IF ( ALLOCATED(InData%Vtot_LL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! Vtot_LL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Vtot_LL)  ! Vtot_LL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Vstr_LL allocated yes/no
  IF ( ALLOCATED(InData%Vstr_LL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! Vstr_LL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Vstr_LL)  ! Vstr_LL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Vwnd_LL allocated yes/no
  IF ( ALLOCATED(InData%Vwnd_LL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! Vwnd_LL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Vwnd_LL)  ! Vwnd_LL
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Vwnd_NW allocated yes/no
  IF ( ALLOCATED(InData%Vwnd_NW) ) THEN
    Int_BufSz   = Int_BufSz   + 2*4  ! Vwnd_NW upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Vwnd_NW)  ! Vwnd_NW
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Vwnd_FW allocated yes/no
  IF ( ALLOCATED(InData%Vwnd_FW) ) THEN
    Int_BufSz   = Int_BufSz   + 2*4  ! Vwnd_FW upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Vwnd_FW)  ! Vwnd_FW
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Vind_NW allocated yes/no
  IF ( ALLOCATED(InData%Vind_NW) ) THEN
    Int_BufSz   = Int_BufSz   + 2*4  ! Vind_NW upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Vind_NW)  ! Vind_NW
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Vind_FW allocated yes/no
  IF ( ALLOCATED(InData%Vind_FW) ) THEN
    Int_BufSz   = Int_BufSz   + 2*4  ! Vind_FW upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Vind_FW)  ! Vind_FW
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! nNW
      Int_BufSz  = Int_BufSz  + 1  ! nFW
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%FirstCall , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
  IF ( .NOT. ALLOCATED(InData%LE) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%LE,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%LE,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%LE,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%LE,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%LE,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%LE,3)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%LE)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%LE))-1 ) = PACK(InData%LE,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%LE)
  END IF
  IF ( .NOT. ALLOCATED(InData%TE) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TE,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TE,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TE,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TE,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%TE,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%TE,3)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%TE)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%TE))-1 ) = PACK(InData%TE,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%TE)
  END IF
  IF ( .NOT. ALLOCATED(InData%r_LL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r_LL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r_LL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r_LL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r_LL,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r_LL,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r_LL,3)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r_LL,4)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r_LL,4)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%r_LL)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%r_LL))-1 ) = PACK(InData%r_LL,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%r_LL)
  END IF
  IF ( .NOT. ALLOCATED(InData%s_LL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%s_LL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%s_LL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%s_LL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%s_LL,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%s_LL)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%s_LL))-1 ) = PACK(InData%s_LL,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%s_LL)
  END IF
  IF ( .NOT. ALLOCATED(InData%chord_LL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%chord_LL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%chord_LL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%chord_LL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%chord_LL,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%chord_LL)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%chord_LL))-1 ) = PACK(InData%chord_LL,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%chord_LL)
  END IF
  IF ( .NOT. ALLOCATED(InData%s_CP_LL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%s_CP_LL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%s_CP_LL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%s_CP_LL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%s_CP_LL,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%s_CP_LL)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%s_CP_LL))-1 ) = PACK(InData%s_CP_LL,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%s_CP_LL)
  END IF
  IF ( .NOT. ALLOCATED(InData%chord_CP_LL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%chord_CP_LL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%chord_CP_LL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%chord_CP_LL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%chord_CP_LL,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%chord_CP_LL)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%chord_CP_LL))-1 ) = PACK(InData%chord_CP_LL,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%chord_CP_LL)
  END IF
  IF ( .NOT. ALLOCATED(InData%CP_LL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CP_LL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CP_LL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CP_LL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CP_LL,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%CP_LL,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%CP_LL,3)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%CP_LL)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%CP_LL))-1 ) = PACK(InData%CP_LL,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%CP_LL)
  END IF
  IF ( .NOT. ALLOCATED(InData%Tang) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Tang,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Tang,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Tang,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Tang,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Tang,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Tang,3)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%Tang)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Tang))-1 ) = PACK(InData%Tang,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%Tang)
  END IF
  IF ( .NOT. ALLOCATED(InData%Norm) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Norm,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Norm,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Norm,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Norm,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Norm,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Norm,3)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%Norm)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Norm))-1 ) = PACK(InData%Norm,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%Norm)
  END IF
  IF ( .NOT. ALLOCATED(InData%Orth) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Orth,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Orth,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Orth,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Orth,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Orth,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Orth,3)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%Orth)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Orth))-1 ) = PACK(InData%Orth,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%Orth)
  END IF
  IF ( .NOT. ALLOCATED(InData%dl) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%dl,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%dl,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%dl,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%dl,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%dl,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%dl,3)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%dl)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%dl))-1 ) = PACK(InData%dl,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%dl)
  END IF
  IF ( .NOT. ALLOCATED(InData%Area) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Area,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Area,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Area,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Area,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%Area)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Area))-1 ) = PACK(InData%Area,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%Area)
  END IF
  IF ( .NOT. ALLOCATED(InData%Gamma_LL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Gamma_LL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Gamma_LL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Gamma_LL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Gamma_LL,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%Gamma_LL)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Gamma_LL))-1 ) = PACK(InData%Gamma_LL,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%Gamma_LL)
  END IF
  IF ( .NOT. ALLOCATED(InData%Vind_LL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vind_LL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vind_LL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vind_LL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vind_LL,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vind_LL,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vind_LL,3)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%Vind_LL)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Vind_LL))-1 ) = PACK(InData%Vind_LL,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%Vind_LL)
  END IF
  IF ( .NOT. ALLOCATED(InData%Vtot_LL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vtot_LL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vtot_LL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vtot_LL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vtot_LL,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vtot_LL,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vtot_LL,3)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%Vtot_LL)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Vtot_LL))-1 ) = PACK(InData%Vtot_LL,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%Vtot_LL)
  END IF
  IF ( .NOT. ALLOCATED(InData%Vstr_LL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vstr_LL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vstr_LL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vstr_LL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vstr_LL,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vstr_LL,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vstr_LL,3)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%Vstr_LL)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Vstr_LL))-1 ) = PACK(InData%Vstr_LL,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%Vstr_LL)
  END IF
  IF ( .NOT. ALLOCATED(InData%Vwnd_LL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vwnd_LL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vwnd_LL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vwnd_LL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vwnd_LL,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vwnd_LL,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vwnd_LL,3)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%Vwnd_LL)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Vwnd_LL))-1 ) = PACK(InData%Vwnd_LL,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%Vwnd_LL)
  END IF
  IF ( .NOT. ALLOCATED(InData%Vwnd_NW) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vwnd_NW,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vwnd_NW,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vwnd_NW,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vwnd_NW,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vwnd_NW,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vwnd_NW,3)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vwnd_NW,4)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vwnd_NW,4)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%Vwnd_NW)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Vwnd_NW))-1 ) = PACK(InData%Vwnd_NW,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%Vwnd_NW)
  END IF
  IF ( .NOT. ALLOCATED(InData%Vwnd_FW) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vwnd_FW,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vwnd_FW,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vwnd_FW,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vwnd_FW,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vwnd_FW,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vwnd_FW,3)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vwnd_FW,4)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vwnd_FW,4)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%Vwnd_FW)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Vwnd_FW))-1 ) = PACK(InData%Vwnd_FW,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%Vwnd_FW)
  END IF
  IF ( .NOT. ALLOCATED(InData%Vind_NW) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vind_NW,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vind_NW,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vind_NW,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vind_NW,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vind_NW,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vind_NW,3)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vind_NW,4)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vind_NW,4)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%Vind_NW)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Vind_NW))-1 ) = PACK(InData%Vind_NW,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%Vind_NW)
  END IF
  IF ( .NOT. ALLOCATED(InData%Vind_FW) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vind_FW,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vind_FW,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vind_FW,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vind_FW,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vind_FW,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vind_FW,3)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vind_FW,4)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vind_FW,4)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%Vind_FW)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Vind_FW))-1 ) = PACK(InData%Vind_FW,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%Vind_FW)
  END IF
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%nNW
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%nFW
      Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE FVW_PackMisc

 SUBROUTINE FVW_UnPackMisc( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FVW_MiscVarType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
  INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_UnPackMisc'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      OutData%FirstCall = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! LE not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%LE)) DEALLOCATE(OutData%LE)
    ALLOCATE(OutData%LE(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%LE.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask3(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask3.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask3 = .TRUE. 
      IF (SIZE(OutData%LE)>0) OutData%LE = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%LE))-1 ), mask3, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%LE)
    DEALLOCATE(mask3)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! TE not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%TE)) DEALLOCATE(OutData%TE)
    ALLOCATE(OutData%TE(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%TE.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask3(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask3.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask3 = .TRUE. 
      IF (SIZE(OutData%TE)>0) OutData%TE = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%TE))-1 ), mask3, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%TE)
    DEALLOCATE(mask3)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! r_LL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i4_l = IntKiBuf( Int_Xferred    )
    i4_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%r_LL)) DEALLOCATE(OutData%r_LL)
    ALLOCATE(OutData%r_LL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%r_LL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask4(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask4.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask4 = .TRUE. 
      IF (SIZE(OutData%r_LL)>0) OutData%r_LL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%r_LL))-1 ), mask4, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%r_LL)
    DEALLOCATE(mask4)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! s_LL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%s_LL)) DEALLOCATE(OutData%s_LL)
    ALLOCATE(OutData%s_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%s_LL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%s_LL)>0) OutData%s_LL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%s_LL))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%s_LL)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! chord_LL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%chord_LL)) DEALLOCATE(OutData%chord_LL)
    ALLOCATE(OutData%chord_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%chord_LL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%chord_LL)>0) OutData%chord_LL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%chord_LL))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%chord_LL)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! s_CP_LL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%s_CP_LL)) DEALLOCATE(OutData%s_CP_LL)
    ALLOCATE(OutData%s_CP_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%s_CP_LL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%s_CP_LL)>0) OutData%s_CP_LL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%s_CP_LL))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%s_CP_LL)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! chord_CP_LL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%chord_CP_LL)) DEALLOCATE(OutData%chord_CP_LL)
    ALLOCATE(OutData%chord_CP_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%chord_CP_LL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%chord_CP_LL)>0) OutData%chord_CP_LL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%chord_CP_LL))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%chord_CP_LL)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! CP_LL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%CP_LL)) DEALLOCATE(OutData%CP_LL)
    ALLOCATE(OutData%CP_LL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%CP_LL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask3(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask3.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask3 = .TRUE. 
      IF (SIZE(OutData%CP_LL)>0) OutData%CP_LL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%CP_LL))-1 ), mask3, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%CP_LL)
    DEALLOCATE(mask3)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Tang not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Tang)) DEALLOCATE(OutData%Tang)
    ALLOCATE(OutData%Tang(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Tang.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask3(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask3.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask3 = .TRUE. 
      IF (SIZE(OutData%Tang)>0) OutData%Tang = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Tang))-1 ), mask3, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%Tang)
    DEALLOCATE(mask3)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Norm not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Norm)) DEALLOCATE(OutData%Norm)
    ALLOCATE(OutData%Norm(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Norm.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask3(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask3.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask3 = .TRUE. 
      IF (SIZE(OutData%Norm)>0) OutData%Norm = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Norm))-1 ), mask3, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%Norm)
    DEALLOCATE(mask3)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Orth not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Orth)) DEALLOCATE(OutData%Orth)
    ALLOCATE(OutData%Orth(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Orth.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask3(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask3.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask3 = .TRUE. 
      IF (SIZE(OutData%Orth)>0) OutData%Orth = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Orth))-1 ), mask3, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%Orth)
    DEALLOCATE(mask3)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! dl not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%dl)) DEALLOCATE(OutData%dl)
    ALLOCATE(OutData%dl(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%dl.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask3(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask3.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask3 = .TRUE. 
      IF (SIZE(OutData%dl)>0) OutData%dl = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%dl))-1 ), mask3, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%dl)
    DEALLOCATE(mask3)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Area not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Area)) DEALLOCATE(OutData%Area)
    ALLOCATE(OutData%Area(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Area.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%Area)>0) OutData%Area = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Area))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%Area)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Gamma_LL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Gamma_LL)) DEALLOCATE(OutData%Gamma_LL)
    ALLOCATE(OutData%Gamma_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Gamma_LL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%Gamma_LL)>0) OutData%Gamma_LL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Gamma_LL))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%Gamma_LL)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Vind_LL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Vind_LL)) DEALLOCATE(OutData%Vind_LL)
    ALLOCATE(OutData%Vind_LL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vind_LL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask3(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask3.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask3 = .TRUE. 
      IF (SIZE(OutData%Vind_LL)>0) OutData%Vind_LL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Vind_LL))-1 ), mask3, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%Vind_LL)
    DEALLOCATE(mask3)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Vtot_LL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Vtot_LL)) DEALLOCATE(OutData%Vtot_LL)
    ALLOCATE(OutData%Vtot_LL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vtot_LL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask3(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask3.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask3 = .TRUE. 
      IF (SIZE(OutData%Vtot_LL)>0) OutData%Vtot_LL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Vtot_LL))-1 ), mask3, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%Vtot_LL)
    DEALLOCATE(mask3)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Vstr_LL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Vstr_LL)) DEALLOCATE(OutData%Vstr_LL)
    ALLOCATE(OutData%Vstr_LL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vstr_LL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask3(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask3.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask3 = .TRUE. 
      IF (SIZE(OutData%Vstr_LL)>0) OutData%Vstr_LL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Vstr_LL))-1 ), mask3, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%Vstr_LL)
    DEALLOCATE(mask3)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Vwnd_LL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Vwnd_LL)) DEALLOCATE(OutData%Vwnd_LL)
    ALLOCATE(OutData%Vwnd_LL(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vwnd_LL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask3(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask3.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask3 = .TRUE. 
      IF (SIZE(OutData%Vwnd_LL)>0) OutData%Vwnd_LL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Vwnd_LL))-1 ), mask3, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%Vwnd_LL)
    DEALLOCATE(mask3)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Vwnd_NW not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i4_l = IntKiBuf( Int_Xferred    )
    i4_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Vwnd_NW)) DEALLOCATE(OutData%Vwnd_NW)
    ALLOCATE(OutData%Vwnd_NW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vwnd_NW.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask4(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask4.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask4 = .TRUE. 
      IF (SIZE(OutData%Vwnd_NW)>0) OutData%Vwnd_NW = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Vwnd_NW))-1 ), mask4, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%Vwnd_NW)
    DEALLOCATE(mask4)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Vwnd_FW not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i4_l = IntKiBuf( Int_Xferred    )
    i4_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Vwnd_FW)) DEALLOCATE(OutData%Vwnd_FW)
    ALLOCATE(OutData%Vwnd_FW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vwnd_FW.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask4(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask4.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask4 = .TRUE. 
      IF (SIZE(OutData%Vwnd_FW)>0) OutData%Vwnd_FW = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Vwnd_FW))-1 ), mask4, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%Vwnd_FW)
    DEALLOCATE(mask4)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Vind_NW not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i4_l = IntKiBuf( Int_Xferred    )
    i4_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Vind_NW)) DEALLOCATE(OutData%Vind_NW)
    ALLOCATE(OutData%Vind_NW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vind_NW.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask4(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask4.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask4 = .TRUE. 
      IF (SIZE(OutData%Vind_NW)>0) OutData%Vind_NW = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Vind_NW))-1 ), mask4, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%Vind_NW)
    DEALLOCATE(mask4)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Vind_FW not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i4_l = IntKiBuf( Int_Xferred    )
    i4_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Vind_FW)) DEALLOCATE(OutData%Vind_FW)
    ALLOCATE(OutData%Vind_FW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vind_FW.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask4(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask4.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask4 = .TRUE. 
      IF (SIZE(OutData%Vind_FW)>0) OutData%Vind_FW = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Vind_FW))-1 ), mask4, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%Vind_FW)
    DEALLOCATE(mask4)
  END IF
      OutData%nNW = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      OutData%nFW = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
 END SUBROUTINE FVW_UnPackMisc

 SUBROUTINE FVW_CopyInput( SrcInputData, DstInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_InputType), INTENT(INOUT) :: SrcInputData
   TYPE(FVW_InputType), INTENT(INOUT) :: DstInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcInputData%WingsMesh)) THEN
  i1_l = LBOUND(SrcInputData%WingsMesh,1)
  i1_u = UBOUND(SrcInputData%WingsMesh,1)
  IF (.NOT. ALLOCATED(DstInputData%WingsMesh)) THEN 
    ALLOCATE(DstInputData%WingsMesh(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%WingsMesh.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInputData%WingsMesh,1), UBOUND(SrcInputData%WingsMesh,1)
      CALL MeshCopy( SrcInputData%WingsMesh(i1), DstInputData%WingsMesh(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcInputData%V_wind)) THEN
  i1_l = LBOUND(SrcInputData%V_wind,1)
  i1_u = UBOUND(SrcInputData%V_wind,1)
  i2_l = LBOUND(SrcInputData%V_wind,2)
  i2_u = UBOUND(SrcInputData%V_wind,2)
  IF (.NOT. ALLOCATED(DstInputData%V_wind)) THEN 
    ALLOCATE(DstInputData%V_wind(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInputData%V_wind.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInputData%V_wind = SrcInputData%V_wind
ENDIF
 END SUBROUTINE FVW_CopyInput

 SUBROUTINE FVW_DestroyInput( InputData, ErrStat, ErrMsg )
  TYPE(FVW_InputType), INTENT(INOUT) :: InputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyInput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InputData%WingsMesh)) THEN
DO i1 = LBOUND(InputData%WingsMesh,1), UBOUND(InputData%WingsMesh,1)
  CALL MeshDestroy( InputData%WingsMesh(i1), ErrStat, ErrMsg )
ENDDO
  DEALLOCATE(InputData%WingsMesh)
ENDIF
IF (ALLOCATED(InputData%V_wind)) THEN
  DEALLOCATE(InputData%V_wind)
ENDIF
 END SUBROUTINE FVW_DestroyInput

 SUBROUTINE FVW_PackInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FVW_InputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_PackInput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz   = Int_BufSz   + 1     ! WingsMesh allocated yes/no
  IF ( ALLOCATED(InData%WingsMesh) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! WingsMesh upper/lower bounds for each dimension
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
    DO i1 = LBOUND(InData%WingsMesh,1), UBOUND(InData%WingsMesh,1)
      Int_BufSz   = Int_BufSz + 3  ! WingsMesh: size of buffers for each call to pack subtype
      CALL MeshPack( InData%WingsMesh(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, .TRUE. ) ! WingsMesh 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! WingsMesh
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! WingsMesh
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! WingsMesh
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! V_wind allocated yes/no
  IF ( ALLOCATED(InData%V_wind) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! V_wind upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%V_wind)  ! V_wind
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

  IF ( .NOT. ALLOCATED(InData%WingsMesh) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WingsMesh,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WingsMesh,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%WingsMesh,1), UBOUND(InData%WingsMesh,1)
      CALL MeshPack( InData%WingsMesh(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, OnlySize ) ! WingsMesh 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%V_wind) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%V_wind,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%V_wind,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%V_wind,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%V_wind,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%V_wind)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%V_wind))-1 ) = PACK(InData%V_wind,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%V_wind)
  END IF
 END SUBROUTINE FVW_PackInput

 SUBROUTINE FVW_UnPackInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FVW_InputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_UnPackInput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WingsMesh not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WingsMesh)) DEALLOCATE(OutData%WingsMesh)
    ALLOCATE(OutData%WingsMesh(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WingsMesh.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%WingsMesh,1), UBOUND(OutData%WingsMesh,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MeshUnpack( OutData%WingsMesh(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2 ) ! WingsMesh 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! V_wind not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%V_wind)) DEALLOCATE(OutData%V_wind)
    ALLOCATE(OutData%V_wind(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%V_wind.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%V_wind)>0) OutData%V_wind = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%V_wind))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%V_wind)
    DEALLOCATE(mask2)
  END IF
 END SUBROUTINE FVW_UnPackInput

 SUBROUTINE FVW_CopyOutput( SrcOutputData, DstOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_OutputType), INTENT(IN) :: SrcOutputData
   TYPE(FVW_OutputType), INTENT(INOUT) :: DstOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcOutputData%Vind)) THEN
  i1_l = LBOUND(SrcOutputData%Vind,1)
  i1_u = UBOUND(SrcOutputData%Vind,1)
  i2_l = LBOUND(SrcOutputData%Vind,2)
  i2_u = UBOUND(SrcOutputData%Vind,2)
  i3_l = LBOUND(SrcOutputData%Vind,3)
  i3_u = UBOUND(SrcOutputData%Vind,3)
  IF (.NOT. ALLOCATED(DstOutputData%Vind)) THEN 
    ALLOCATE(DstOutputData%Vind(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Vind.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%Vind = SrcOutputData%Vind
ENDIF
IF (ALLOCATED(SrcOutputData%r_wind)) THEN
  i1_l = LBOUND(SrcOutputData%r_wind,1)
  i1_u = UBOUND(SrcOutputData%r_wind,1)
  i2_l = LBOUND(SrcOutputData%r_wind,2)
  i2_u = UBOUND(SrcOutputData%r_wind,2)
  IF (.NOT. ALLOCATED(DstOutputData%r_wind)) THEN 
    ALLOCATE(DstOutputData%r_wind(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%r_wind.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%r_wind = SrcOutputData%r_wind
ENDIF
IF (ALLOCATED(SrcOutputData%Cl_KJ)) THEN
  i1_l = LBOUND(SrcOutputData%Cl_KJ,1)
  i1_u = UBOUND(SrcOutputData%Cl_KJ,1)
  i2_l = LBOUND(SrcOutputData%Cl_KJ,2)
  i2_u = UBOUND(SrcOutputData%Cl_KJ,2)
  IF (.NOT. ALLOCATED(DstOutputData%Cl_KJ)) THEN 
    ALLOCATE(DstOutputData%Cl_KJ(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstOutputData%Cl_KJ.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstOutputData%Cl_KJ = SrcOutputData%Cl_KJ
ENDIF
 END SUBROUTINE FVW_CopyOutput

 SUBROUTINE FVW_DestroyOutput( OutputData, ErrStat, ErrMsg )
  TYPE(FVW_OutputType), INTENT(INOUT) :: OutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyOutput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(OutputData%Vind)) THEN
  DEALLOCATE(OutputData%Vind)
ENDIF
IF (ALLOCATED(OutputData%r_wind)) THEN
  DEALLOCATE(OutputData%r_wind)
ENDIF
IF (ALLOCATED(OutputData%Cl_KJ)) THEN
  DEALLOCATE(OutputData%Cl_KJ)
ENDIF
 END SUBROUTINE FVW_DestroyOutput

 SUBROUTINE FVW_PackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FVW_OutputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_PackOutput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz   = Int_BufSz   + 1     ! Vind allocated yes/no
  IF ( ALLOCATED(InData%Vind) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! Vind upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Vind)  ! Vind
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! r_wind allocated yes/no
  IF ( ALLOCATED(InData%r_wind) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! r_wind upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%r_wind)  ! r_wind
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Cl_KJ allocated yes/no
  IF ( ALLOCATED(InData%Cl_KJ) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Cl_KJ upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Cl_KJ)  ! Cl_KJ
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

  IF ( .NOT. ALLOCATED(InData%Vind) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vind,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vind,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vind,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vind,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Vind,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Vind,3)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%Vind)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Vind))-1 ) = PACK(InData%Vind,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%Vind)
  END IF
  IF ( .NOT. ALLOCATED(InData%r_wind) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r_wind,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r_wind,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r_wind,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r_wind,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%r_wind)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%r_wind))-1 ) = PACK(InData%r_wind,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%r_wind)
  END IF
  IF ( .NOT. ALLOCATED(InData%Cl_KJ) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Cl_KJ,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Cl_KJ,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Cl_KJ,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Cl_KJ,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%Cl_KJ)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Cl_KJ))-1 ) = PACK(InData%Cl_KJ,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%Cl_KJ)
  END IF
 END SUBROUTINE FVW_PackOutput

 SUBROUTINE FVW_UnPackOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FVW_OutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_UnPackOutput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Vind not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Vind)) DEALLOCATE(OutData%Vind)
    ALLOCATE(OutData%Vind(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Vind.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask3(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask3.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask3 = .TRUE. 
      IF (SIZE(OutData%Vind)>0) OutData%Vind = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Vind))-1 ), mask3, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%Vind)
    DEALLOCATE(mask3)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! r_wind not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%r_wind)) DEALLOCATE(OutData%r_wind)
    ALLOCATE(OutData%r_wind(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%r_wind.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%r_wind)>0) OutData%r_wind = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%r_wind))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%r_wind)
    DEALLOCATE(mask2)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Cl_KJ not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Cl_KJ)) DEALLOCATE(OutData%Cl_KJ)
    ALLOCATE(OutData%Cl_KJ(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Cl_KJ.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%Cl_KJ)>0) OutData%Cl_KJ = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Cl_KJ))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%Cl_KJ)
    DEALLOCATE(mask2)
  END IF
 END SUBROUTINE FVW_UnPackOutput

 SUBROUTINE FVW_CopyContState( SrcContStateData, DstContStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_ContinuousStateType), INTENT(IN) :: SrcContStateData
   TYPE(FVW_ContinuousStateType), INTENT(INOUT) :: DstContStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyContState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcContStateData%Gamma_NW)) THEN
  i1_l = LBOUND(SrcContStateData%Gamma_NW,1)
  i1_u = UBOUND(SrcContStateData%Gamma_NW,1)
  i2_l = LBOUND(SrcContStateData%Gamma_NW,2)
  i2_u = UBOUND(SrcContStateData%Gamma_NW,2)
  i3_l = LBOUND(SrcContStateData%Gamma_NW,3)
  i3_u = UBOUND(SrcContStateData%Gamma_NW,3)
  IF (.NOT. ALLOCATED(DstContStateData%Gamma_NW)) THEN 
    ALLOCATE(DstContStateData%Gamma_NW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%Gamma_NW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstContStateData%Gamma_NW = SrcContStateData%Gamma_NW
ENDIF
IF (ALLOCATED(SrcContStateData%Gamma_FW)) THEN
  i1_l = LBOUND(SrcContStateData%Gamma_FW,1)
  i1_u = UBOUND(SrcContStateData%Gamma_FW,1)
  i2_l = LBOUND(SrcContStateData%Gamma_FW,2)
  i2_u = UBOUND(SrcContStateData%Gamma_FW,2)
  i3_l = LBOUND(SrcContStateData%Gamma_FW,3)
  i3_u = UBOUND(SrcContStateData%Gamma_FW,3)
  IF (.NOT. ALLOCATED(DstContStateData%Gamma_FW)) THEN 
    ALLOCATE(DstContStateData%Gamma_FW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%Gamma_FW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstContStateData%Gamma_FW = SrcContStateData%Gamma_FW
ENDIF
IF (ALLOCATED(SrcContStateData%r_NW)) THEN
  i1_l = LBOUND(SrcContStateData%r_NW,1)
  i1_u = UBOUND(SrcContStateData%r_NW,1)
  i2_l = LBOUND(SrcContStateData%r_NW,2)
  i2_u = UBOUND(SrcContStateData%r_NW,2)
  i3_l = LBOUND(SrcContStateData%r_NW,3)
  i3_u = UBOUND(SrcContStateData%r_NW,3)
  i4_l = LBOUND(SrcContStateData%r_NW,4)
  i4_u = UBOUND(SrcContStateData%r_NW,4)
  IF (.NOT. ALLOCATED(DstContStateData%r_NW)) THEN 
    ALLOCATE(DstContStateData%r_NW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%r_NW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstContStateData%r_NW = SrcContStateData%r_NW
ENDIF
IF (ALLOCATED(SrcContStateData%r_FW)) THEN
  i1_l = LBOUND(SrcContStateData%r_FW,1)
  i1_u = UBOUND(SrcContStateData%r_FW,1)
  i2_l = LBOUND(SrcContStateData%r_FW,2)
  i2_u = UBOUND(SrcContStateData%r_FW,2)
  i3_l = LBOUND(SrcContStateData%r_FW,3)
  i3_u = UBOUND(SrcContStateData%r_FW,3)
  i4_l = LBOUND(SrcContStateData%r_FW,4)
  i4_u = UBOUND(SrcContStateData%r_FW,4)
  IF (.NOT. ALLOCATED(DstContStateData%r_FW)) THEN 
    ALLOCATE(DstContStateData%r_FW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstContStateData%r_FW.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstContStateData%r_FW = SrcContStateData%r_FW
ENDIF
 END SUBROUTINE FVW_CopyContState

 SUBROUTINE FVW_DestroyContState( ContStateData, ErrStat, ErrMsg )
  TYPE(FVW_ContinuousStateType), INTENT(INOUT) :: ContStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyContState'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ContStateData%Gamma_NW)) THEN
  DEALLOCATE(ContStateData%Gamma_NW)
ENDIF
IF (ALLOCATED(ContStateData%Gamma_FW)) THEN
  DEALLOCATE(ContStateData%Gamma_FW)
ENDIF
IF (ALLOCATED(ContStateData%r_NW)) THEN
  DEALLOCATE(ContStateData%r_NW)
ENDIF
IF (ALLOCATED(ContStateData%r_FW)) THEN
  DEALLOCATE(ContStateData%r_FW)
ENDIF
 END SUBROUTINE FVW_DestroyContState

 SUBROUTINE FVW_PackContState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FVW_ContinuousStateType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_PackContState'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz   = Int_BufSz   + 1     ! Gamma_NW allocated yes/no
  IF ( ALLOCATED(InData%Gamma_NW) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! Gamma_NW upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Gamma_NW)  ! Gamma_NW
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Gamma_FW allocated yes/no
  IF ( ALLOCATED(InData%Gamma_FW) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! Gamma_FW upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Gamma_FW)  ! Gamma_FW
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! r_NW allocated yes/no
  IF ( ALLOCATED(InData%r_NW) ) THEN
    Int_BufSz   = Int_BufSz   + 2*4  ! r_NW upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%r_NW)  ! r_NW
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! r_FW allocated yes/no
  IF ( ALLOCATED(InData%r_FW) ) THEN
    Int_BufSz   = Int_BufSz   + 2*4  ! r_FW upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%r_FW)  ! r_FW
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

  IF ( .NOT. ALLOCATED(InData%Gamma_NW) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Gamma_NW,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Gamma_NW,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Gamma_NW,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Gamma_NW,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Gamma_NW,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Gamma_NW,3)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%Gamma_NW)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Gamma_NW))-1 ) = PACK(InData%Gamma_NW,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%Gamma_NW)
  END IF
  IF ( .NOT. ALLOCATED(InData%Gamma_FW) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Gamma_FW,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Gamma_FW,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Gamma_FW,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Gamma_FW,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Gamma_FW,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Gamma_FW,3)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%Gamma_FW)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Gamma_FW))-1 ) = PACK(InData%Gamma_FW,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%Gamma_FW)
  END IF
  IF ( .NOT. ALLOCATED(InData%r_NW) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r_NW,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r_NW,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r_NW,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r_NW,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r_NW,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r_NW,3)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r_NW,4)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r_NW,4)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%r_NW)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%r_NW))-1 ) = PACK(InData%r_NW,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%r_NW)
  END IF
  IF ( .NOT. ALLOCATED(InData%r_FW) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r_FW,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r_FW,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r_FW,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r_FW,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r_FW,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r_FW,3)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r_FW,4)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r_FW,4)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%r_FW)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%r_FW))-1 ) = PACK(InData%r_FW,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%r_FW)
  END IF
 END SUBROUTINE FVW_PackContState

 SUBROUTINE FVW_UnPackContState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FVW_ContinuousStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
  INTEGER(IntKi)                 :: i4, i4_l, i4_u  !  bounds (upper/lower) for an array dimension 4
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_UnPackContState'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Gamma_NW not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Gamma_NW)) DEALLOCATE(OutData%Gamma_NW)
    ALLOCATE(OutData%Gamma_NW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Gamma_NW.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask3(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask3.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask3 = .TRUE. 
      IF (SIZE(OutData%Gamma_NW)>0) OutData%Gamma_NW = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Gamma_NW))-1 ), mask3, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%Gamma_NW)
    DEALLOCATE(mask3)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Gamma_FW not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Gamma_FW)) DEALLOCATE(OutData%Gamma_FW)
    ALLOCATE(OutData%Gamma_FW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Gamma_FW.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask3(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask3.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask3 = .TRUE. 
      IF (SIZE(OutData%Gamma_FW)>0) OutData%Gamma_FW = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Gamma_FW))-1 ), mask3, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%Gamma_FW)
    DEALLOCATE(mask3)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! r_NW not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i4_l = IntKiBuf( Int_Xferred    )
    i4_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%r_NW)) DEALLOCATE(OutData%r_NW)
    ALLOCATE(OutData%r_NW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%r_NW.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask4(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask4.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask4 = .TRUE. 
      IF (SIZE(OutData%r_NW)>0) OutData%r_NW = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%r_NW))-1 ), mask4, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%r_NW)
    DEALLOCATE(mask4)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! r_FW not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i4_l = IntKiBuf( Int_Xferred    )
    i4_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%r_FW)) DEALLOCATE(OutData%r_FW)
    ALLOCATE(OutData%r_FW(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%r_FW.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask4(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u,i4_l:i4_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask4.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask4 = .TRUE. 
      IF (SIZE(OutData%r_FW)>0) OutData%r_FW = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%r_FW))-1 ), mask4, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%r_FW)
    DEALLOCATE(mask4)
  END IF
 END SUBROUTINE FVW_UnPackContState

 SUBROUTINE FVW_CopyDiscState( SrcDiscStateData, DstDiscStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_DiscreteStateType), INTENT(IN) :: SrcDiscStateData
   TYPE(FVW_DiscreteStateType), INTENT(INOUT) :: DstDiscStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyDiscState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstDiscStateData%Null = SrcDiscStateData%Null
 END SUBROUTINE FVW_CopyDiscState

 SUBROUTINE FVW_DestroyDiscState( DiscStateData, ErrStat, ErrMsg )
  TYPE(FVW_DiscreteStateType), INTENT(INOUT) :: DiscStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyDiscState'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE FVW_DestroyDiscState

 SUBROUTINE FVW_PackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FVW_DiscreteStateType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_PackDiscState'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! Null
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%Null
      Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE FVW_PackDiscState

 SUBROUTINE FVW_UnPackDiscState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FVW_DiscreteStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_UnPackDiscState'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      OutData%Null = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
 END SUBROUTINE FVW_UnPackDiscState

 SUBROUTINE FVW_CopyConstrState( SrcConstrStateData, DstConstrStateData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_ConstraintStateType), INTENT(IN) :: SrcConstrStateData
   TYPE(FVW_ConstraintStateType), INTENT(INOUT) :: DstConstrStateData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyConstrState'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstConstrStateData%residual = SrcConstrStateData%residual
IF (ALLOCATED(SrcConstrStateData%Gamma_LL)) THEN
  i1_l = LBOUND(SrcConstrStateData%Gamma_LL,1)
  i1_u = UBOUND(SrcConstrStateData%Gamma_LL,1)
  i2_l = LBOUND(SrcConstrStateData%Gamma_LL,2)
  i2_u = UBOUND(SrcConstrStateData%Gamma_LL,2)
  IF (.NOT. ALLOCATED(DstConstrStateData%Gamma_LL)) THEN 
    ALLOCATE(DstConstrStateData%Gamma_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstConstrStateData%Gamma_LL.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstConstrStateData%Gamma_LL = SrcConstrStateData%Gamma_LL
ENDIF
 END SUBROUTINE FVW_CopyConstrState

 SUBROUTINE FVW_DestroyConstrState( ConstrStateData, ErrStat, ErrMsg )
  TYPE(FVW_ConstraintStateType), INTENT(INOUT) :: ConstrStateData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyConstrState'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ConstrStateData%Gamma_LL)) THEN
  DEALLOCATE(ConstrStateData%Gamma_LL)
ENDIF
 END SUBROUTINE FVW_DestroyConstrState

 SUBROUTINE FVW_PackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FVW_ConstraintStateType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_PackConstrState'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! residual
  Int_BufSz   = Int_BufSz   + 1     ! Gamma_LL allocated yes/no
  IF ( ALLOCATED(InData%Gamma_LL) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Gamma_LL upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Gamma_LL)  ! Gamma_LL
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%residual
      Re_Xferred   = Re_Xferred   + 1
  IF ( .NOT. ALLOCATED(InData%Gamma_LL) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Gamma_LL,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Gamma_LL,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Gamma_LL,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Gamma_LL,2)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%Gamma_LL)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Gamma_LL))-1 ) = PACK(InData%Gamma_LL,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%Gamma_LL)
  END IF
 END SUBROUTINE FVW_PackConstrState

 SUBROUTINE FVW_UnPackConstrState( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FVW_ConstraintStateType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_UnPackConstrState'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      OutData%residual = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Gamma_LL not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Gamma_LL)) DEALLOCATE(OutData%Gamma_LL)
    ALLOCATE(OutData%Gamma_LL(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Gamma_LL.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask2(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask2.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask2 = .TRUE. 
      IF (SIZE(OutData%Gamma_LL)>0) OutData%Gamma_LL = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Gamma_LL))-1 ), mask2, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%Gamma_LL)
    DEALLOCATE(mask2)
  END IF
 END SUBROUTINE FVW_UnPackConstrState

 SUBROUTINE FVW_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_InitInputType), INTENT(INOUT) :: SrcInitInputData
   TYPE(FVW_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyInitInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitInputData%FVWFileName = SrcInitInputData%FVWFileName
IF (ALLOCATED(SrcInitInputData%WingsMesh)) THEN
  i1_l = LBOUND(SrcInitInputData%WingsMesh,1)
  i1_u = UBOUND(SrcInitInputData%WingsMesh,1)
  IF (.NOT. ALLOCATED(DstInitInputData%WingsMesh)) THEN 
    ALLOCATE(DstInitInputData%WingsMesh(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WingsMesh.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DO i1 = LBOUND(SrcInitInputData%WingsMesh,1), UBOUND(SrcInitInputData%WingsMesh,1)
      CALL MeshCopy( SrcInitInputData%WingsMesh(i1), DstInitInputData%WingsMesh(i1), CtrlCode, ErrStat2, ErrMsg2 )
         CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
         IF (ErrStat>=AbortErrLev) RETURN
    ENDDO
ENDIF
IF (ALLOCATED(SrcInitInputData%Chord)) THEN
  i1_l = LBOUND(SrcInitInputData%Chord,1)
  i1_u = UBOUND(SrcInitInputData%Chord,1)
  IF (.NOT. ALLOCATED(DstInitInputData%Chord)) THEN 
    ALLOCATE(DstInitInputData%Chord(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%Chord.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%Chord = SrcInitInputData%Chord
ENDIF
IF (ALLOCATED(SrcInitInputData%RElm)) THEN
  i1_l = LBOUND(SrcInitInputData%RElm,1)
  i1_u = UBOUND(SrcInitInputData%RElm,1)
  IF (.NOT. ALLOCATED(DstInitInputData%RElm)) THEN 
    ALLOCATE(DstInitInputData%RElm(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%RElm.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%RElm = SrcInitInputData%RElm
ENDIF
    DstInitInputData%NumBl = SrcInitInputData%NumBl
 END SUBROUTINE FVW_CopyInitInput

 SUBROUTINE FVW_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(FVW_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyInitInput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitInputData%WingsMesh)) THEN
DO i1 = LBOUND(InitInputData%WingsMesh,1), UBOUND(InitInputData%WingsMesh,1)
  CALL MeshDestroy( InitInputData%WingsMesh(i1), ErrStat, ErrMsg )
ENDDO
  DEALLOCATE(InitInputData%WingsMesh)
ENDIF
IF (ALLOCATED(InitInputData%Chord)) THEN
  DEALLOCATE(InitInputData%Chord)
ENDIF
IF (ALLOCATED(InitInputData%RElm)) THEN
  DEALLOCATE(InitInputData%RElm)
ENDIF
 END SUBROUTINE FVW_DestroyInitInput

 SUBROUTINE FVW_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FVW_InitInputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_PackInitInput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%FVWFileName)  ! FVWFileName
  Int_BufSz   = Int_BufSz   + 1     ! WingsMesh allocated yes/no
  IF ( ALLOCATED(InData%WingsMesh) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! WingsMesh upper/lower bounds for each dimension
   ! Allocate buffers for subtypes, if any (we'll get sizes from these) 
    DO i1 = LBOUND(InData%WingsMesh,1), UBOUND(InData%WingsMesh,1)
      Int_BufSz   = Int_BufSz + 3  ! WingsMesh: size of buffers for each call to pack subtype
      CALL MeshPack( InData%WingsMesh(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, .TRUE. ) ! WingsMesh 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN ! WingsMesh
         Re_BufSz  = Re_BufSz  + SIZE( Re_Buf  )
         DEALLOCATE(Re_Buf)
      END IF
      IF(ALLOCATED(Db_Buf)) THEN ! WingsMesh
         Db_BufSz  = Db_BufSz  + SIZE( Db_Buf  )
         DEALLOCATE(Db_Buf)
      END IF
      IF(ALLOCATED(Int_Buf)) THEN ! WingsMesh
         Int_BufSz = Int_BufSz + SIZE( Int_Buf )
         DEALLOCATE(Int_Buf)
      END IF
    END DO
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Chord allocated yes/no
  IF ( ALLOCATED(InData%Chord) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! Chord upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Chord)  ! Chord
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! RElm allocated yes/no
  IF ( ALLOCATED(InData%RElm) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! RElm upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%RElm)  ! RElm
  END IF
      Int_BufSz  = Int_BufSz  + 1  ! NumBl
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

        DO I = 1, LEN(InData%FVWFileName)
          IntKiBuf(Int_Xferred) = ICHAR(InData%FVWFileName(I:I), IntKi)
          Int_Xferred = Int_Xferred   + 1
        END DO ! I
  IF ( .NOT. ALLOCATED(InData%WingsMesh) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WingsMesh,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WingsMesh,1)
    Int_Xferred = Int_Xferred + 2

    DO i1 = LBOUND(InData%WingsMesh,1), UBOUND(InData%WingsMesh,1)
      CALL MeshPack( InData%WingsMesh(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2, OnlySize ) ! WingsMesh 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Re_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Re_Buf) > 0) ReKiBuf( Re_Xferred:Re_Xferred+SIZE(Re_Buf)-1 ) = Re_Buf
        Re_Xferred = Re_Xferred + SIZE(Re_Buf)
        DEALLOCATE(Re_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Db_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Db_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Db_Buf) > 0) DbKiBuf( Db_Xferred:Db_Xferred+SIZE(Db_Buf)-1 ) = Db_Buf
        Db_Xferred = Db_Xferred + SIZE(Db_Buf)
        DEALLOCATE(Db_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
      IF(ALLOCATED(Int_Buf)) THEN
        IntKiBuf( Int_Xferred ) = SIZE(Int_Buf); Int_Xferred = Int_Xferred + 1
        IF (SIZE(Int_Buf) > 0) IntKiBuf( Int_Xferred:Int_Xferred+SIZE(Int_Buf)-1 ) = Int_Buf
        Int_Xferred = Int_Xferred + SIZE(Int_Buf)
        DEALLOCATE(Int_Buf)
      ELSE
        IntKiBuf( Int_Xferred ) = 0; Int_Xferred = Int_Xferred + 1
      ENDIF
    END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Chord) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Chord,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Chord,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%Chord)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%Chord))-1 ) = PACK(InData%Chord,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%Chord)
  END IF
  IF ( .NOT. ALLOCATED(InData%RElm) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%RElm,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%RElm,1)
    Int_Xferred = Int_Xferred + 2

      IF (SIZE(InData%RElm)>0) ReKiBuf ( Re_Xferred:Re_Xferred+(SIZE(InData%RElm))-1 ) = PACK(InData%RElm,.TRUE.)
      Re_Xferred   = Re_Xferred   + SIZE(InData%RElm)
  END IF
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%NumBl
      Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE FVW_PackInitInput

 SUBROUTINE FVW_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FVW_InitInputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_UnPackInitInput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      DO I = 1, LEN(OutData%FVWFileName)
        OutData%FVWFileName(I:I) = CHAR(IntKiBuf(Int_Xferred))
        Int_Xferred = Int_Xferred   + 1
      END DO ! I
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WingsMesh not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WingsMesh)) DEALLOCATE(OutData%WingsMesh)
    ALLOCATE(OutData%WingsMesh(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WingsMesh.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    DO i1 = LBOUND(OutData%WingsMesh,1), UBOUND(OutData%WingsMesh,1)
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Re_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Re_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Re_Buf = ReKiBuf( Re_Xferred:Re_Xferred+Buf_size-1 )
        Re_Xferred = Re_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Db_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Db_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Db_Buf = DbKiBuf( Db_Xferred:Db_Xferred+Buf_size-1 )
        Db_Xferred = Db_Xferred + Buf_size
      END IF
      Buf_size=IntKiBuf( Int_Xferred )
      Int_Xferred = Int_Xferred + 1
      IF(Buf_size > 0) THEN
        ALLOCATE(Int_Buf(Buf_size),STAT=ErrStat2)
        IF (ErrStat2 /= 0) THEN 
           CALL SetErrStat(ErrID_Fatal, 'Error allocating Int_Buf.', ErrStat, ErrMsg,RoutineName)
           RETURN
        END IF
        Int_Buf = IntKiBuf( Int_Xferred:Int_Xferred+Buf_size-1 )
        Int_Xferred = Int_Xferred + Buf_size
      END IF
      CALL MeshUnpack( OutData%WingsMesh(i1), Re_Buf, Db_Buf, Int_Buf, ErrStat2, ErrMsg2 ) ! WingsMesh 
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
        IF (ErrStat >= AbortErrLev) RETURN

      IF(ALLOCATED(Re_Buf )) DEALLOCATE(Re_Buf )
      IF(ALLOCATED(Db_Buf )) DEALLOCATE(Db_Buf )
      IF(ALLOCATED(Int_Buf)) DEALLOCATE(Int_Buf)
    END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Chord not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Chord)) DEALLOCATE(OutData%Chord)
    ALLOCATE(OutData%Chord(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Chord.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%Chord)>0) OutData%Chord = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%Chord))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%Chord)
    DEALLOCATE(mask1)
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! RElm not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%RElm)) DEALLOCATE(OutData%RElm)
    ALLOCATE(OutData%RElm(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%RElm.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    ALLOCATE(mask1(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating mask1.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
    mask1 = .TRUE. 
      IF (SIZE(OutData%RElm)>0) OutData%RElm = UNPACK(ReKiBuf( Re_Xferred:Re_Xferred+(SIZE(OutData%RElm))-1 ), mask1, 0.0_ReKi )
      Re_Xferred   = Re_Xferred   + SIZE(OutData%RElm)
    DEALLOCATE(mask1)
  END IF
      OutData%NumBl = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
 END SUBROUTINE FVW_UnPackInitInput

 SUBROUTINE FVW_CopyInputFile( SrcInputFileData, DstInputFileData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_InputFile), INTENT(IN) :: SrcInputFileData
   TYPE(FVW_InputFile), INTENT(INOUT) :: DstInputFileData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyInputFile'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInputFileData%CirculationMethod = SrcInputFileData%CirculationMethod
    DstInputFileData%CirculationFile = SrcInputFileData%CirculationFile
    DstInputFileData%CircSolvMaxIter = SrcInputFileData%CircSolvMaxIter
    DstInputFileData%CircSolvConvCrit = SrcInputFileData%CircSolvConvCrit
    DstInputFileData%CircSolvRelaxation = SrcInputFileData%CircSolvRelaxation
    DstInputFileData%IntMethod = SrcInputFileData%IntMethod
    DstInputFileData%FreeWake = SrcInputFileData%FreeWake
    DstInputFileData%FreeWakeStart = SrcInputFileData%FreeWakeStart
    DstInputFileData%FullCirculationStart = SrcInputFileData%FullCirculationStart
    DstInputFileData%PrescribedPolar = SrcInputFileData%PrescribedPolar
    DstInputFileData%nNWPanels = SrcInputFileData%nNWPanels
    DstInputFileData%nFWPanels = SrcInputFileData%nFWPanels
    DstInputFileData%nFWPanelsFree = SrcInputFileData%nFWPanelsFree
    DstInputFileData%RegFunction = SrcInputFileData%RegFunction
    DstInputFileData%WakeRegMethod = SrcInputFileData%WakeRegMethod
    DstInputFileData%WakeRegFactor = SrcInputFileData%WakeRegFactor
 END SUBROUTINE FVW_CopyInputFile

 SUBROUTINE FVW_DestroyInputFile( InputFileData, ErrStat, ErrMsg )
  TYPE(FVW_InputFile), INTENT(INOUT) :: InputFileData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyInputFile'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE FVW_DestroyInputFile

 SUBROUTINE FVW_PackInputFile( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FVW_InputFile),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_PackInputFile'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! CirculationMethod
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%CirculationFile)  ! CirculationFile
      Int_BufSz  = Int_BufSz  + 1  ! CircSolvMaxIter
      Re_BufSz   = Re_BufSz   + 1  ! CircSolvConvCrit
      Re_BufSz   = Re_BufSz   + 1  ! CircSolvRelaxation
      Int_BufSz  = Int_BufSz  + 1  ! IntMethod
      Int_BufSz  = Int_BufSz  + 1  ! FreeWake
      Re_BufSz   = Re_BufSz   + 1  ! FreeWakeStart
      Re_BufSz   = Re_BufSz   + 1  ! FullCirculationStart
      Int_BufSz  = Int_BufSz  + 1  ! PrescribedPolar
      Int_BufSz  = Int_BufSz  + 1  ! nNWPanels
      Int_BufSz  = Int_BufSz  + 1  ! nFWPanels
      Int_BufSz  = Int_BufSz  + 1  ! nFWPanelsFree
      Int_BufSz  = Int_BufSz  + 1  ! RegFunction
      Int_BufSz  = Int_BufSz  + 1  ! WakeRegMethod
      Re_BufSz   = Re_BufSz   + 1  ! WakeRegFactor
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%CirculationMethod
      Int_Xferred   = Int_Xferred   + 1
        DO I = 1, LEN(InData%CirculationFile)
          IntKiBuf(Int_Xferred) = ICHAR(InData%CirculationFile(I:I), IntKi)
          Int_Xferred = Int_Xferred   + 1
        END DO ! I
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%CircSolvMaxIter
      Int_Xferred   = Int_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%CircSolvConvCrit
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%CircSolvRelaxation
      Re_Xferred   = Re_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%IntMethod
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+1-1 ) = TRANSFER( InData%FreeWake , IntKiBuf(1), 1)
      Int_Xferred   = Int_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%FreeWakeStart
      Re_Xferred   = Re_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%FullCirculationStart
      Re_Xferred   = Re_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%PrescribedPolar
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%nNWPanels
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%nFWPanels
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%nFWPanelsFree
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%RegFunction
      Int_Xferred   = Int_Xferred   + 1
      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%WakeRegMethod
      Int_Xferred   = Int_Xferred   + 1
      ReKiBuf ( Re_Xferred:Re_Xferred+(1)-1 ) = InData%WakeRegFactor
      Re_Xferred   = Re_Xferred   + 1
 END SUBROUTINE FVW_PackInputFile

 SUBROUTINE FVW_UnPackInputFile( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FVW_InputFile), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_UnPackInputFile'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      OutData%CirculationMethod = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      DO I = 1, LEN(OutData%CirculationFile)
        OutData%CirculationFile(I:I) = CHAR(IntKiBuf(Int_Xferred))
        Int_Xferred = Int_Xferred   + 1
      END DO ! I
      OutData%CircSolvMaxIter = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      OutData%CircSolvConvCrit = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%CircSolvRelaxation = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%IntMethod = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      OutData%FreeWake = TRANSFER( IntKiBuf( Int_Xferred ), mask0 )
      Int_Xferred   = Int_Xferred + 1
      OutData%FreeWakeStart = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%FullCirculationStart = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
      OutData%PrescribedPolar = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      OutData%nNWPanels = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      OutData%nFWPanels = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      OutData%nFWPanelsFree = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      OutData%RegFunction = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      OutData%WakeRegMethod = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
      OutData%WakeRegFactor = ReKiBuf( Re_Xferred )
      Re_Xferred   = Re_Xferred + 1
 END SUBROUTINE FVW_UnPackInputFile

 SUBROUTINE FVW_CopyInitOutput( SrcInitOutputData, DstInitOutputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(FVW_InitOutputType), INTENT(IN) :: SrcInitOutputData
   TYPE(FVW_InitOutputType), INTENT(INOUT) :: DstInitOutputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_CopyInitOutput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitOutputData%Null = SrcInitOutputData%Null
 END SUBROUTINE FVW_CopyInitOutput

 SUBROUTINE FVW_DestroyInitOutput( InitOutputData, ErrStat, ErrMsg )
  TYPE(FVW_InitOutputType), INTENT(INOUT) :: InitOutputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'FVW_DestroyInitOutput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE FVW_DestroyInitOutput

 SUBROUTINE FVW_PackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(FVW_InitOutputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_PackInitOutput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! Null
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

      IntKiBuf ( Int_Xferred:Int_Xferred+(1)-1 ) = InData%Null
      Int_Xferred   = Int_Xferred   + 1
 END SUBROUTINE FVW_PackInitOutput

 SUBROUTINE FVW_UnPackInitOutput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(FVW_InitOutputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  LOGICAL                        :: mask0
  LOGICAL, ALLOCATABLE           :: mask1(:)
  LOGICAL, ALLOCATABLE           :: mask2(:,:)
  LOGICAL, ALLOCATABLE           :: mask3(:,:,:)
  LOGICAL, ALLOCATABLE           :: mask4(:,:,:,:)
  LOGICAL, ALLOCATABLE           :: mask5(:,:,:,:,:)
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'FVW_UnPackInitOutput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
      OutData%Null = IntKiBuf( Int_Xferred ) 
      Int_Xferred   = Int_Xferred + 1
 END SUBROUTINE FVW_UnPackInitOutput


 SUBROUTINE FVW_Input_ExtrapInterp(u, t, u_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is given by the size of u
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3  (as appropriate)
!
!..................................................................................................................................

 TYPE(FVW_InputType), INTENT(INOUT)  :: u(:) ! Input at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Inputs
 TYPE(FVW_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'FVW_Input_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(u)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(u)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(u) - 1
 IF ( order .eq. 0 ) THEN
   CALL FVW_CopyInput(u(1), u_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL FVW_Input_ExtrapInterp1(u(1), u(2), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL FVW_Input_ExtrapInterp2(u(1), u(2), u(3), t, u_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(u) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE FVW_Input_ExtrapInterp


 SUBROUTINE FVW_Input_ExtrapInterp1(u1, u2, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = u1, f(t2) = u2
!
!..................................................................................................................................

 TYPE(FVW_InputType), INTENT(INOUT)  :: u1    ! Input at t1 > t2
 TYPE(FVW_InputType), INTENT(INOUT)  :: u2    ! Input at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Inputs
 TYPE(FVW_InputType), INTENT(INOUT)  :: u_out ! Input at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'FVW_Input_ExtrapInterp1'
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF
IF (ALLOCATED(u_out%WingsMesh) .AND. ALLOCATED(u1%WingsMesh)) THEN
  DO i01 = LBOUND(u_out%WingsMesh,1),UBOUND(u_out%WingsMesh,1)
      CALL MeshExtrapInterp1(u1%WingsMesh(i01), u2%WingsMesh(i01), tin, u_out%WingsMesh(i01), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(u_out%V_wind) .AND. ALLOCATED(u1%V_wind)) THEN
  ALLOCATE(b2(SIZE(u_out%V_wind,1),SIZE(u_out%V_wind,2) ))
  ALLOCATE(c2(SIZE(u_out%V_wind,1),SIZE(u_out%V_wind,2) ))
  b2 = -(u1%V_wind - u2%V_wind)/t(2)
  u_out%V_wind = u1%V_wind + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
 END SUBROUTINE FVW_Input_ExtrapInterp1


 SUBROUTINE FVW_Input_ExtrapInterp2(u1, u2, u3, tin, u_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Input u_out at time t_out, from previous/future time
! values of u (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = u1, f(t2) = u2, f(t3) = u3
!
!..................................................................................................................................

 TYPE(FVW_InputType), INTENT(INOUT)  :: u1      ! Input at t1 > t2 > t3
 TYPE(FVW_InputType), INTENT(INOUT)  :: u2      ! Input at t2 > t3
 TYPE(FVW_InputType), INTENT(INOUT)  :: u3      ! Input at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Inputs
 TYPE(FVW_InputType), INTENT(INOUT)  :: u_out     ! Input at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Inputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'FVW_Input_ExtrapInterp2'
 INTEGER                                    :: i01    ! dim1 level 0 counter variable for arrays of ddts
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF
IF (ALLOCATED(u_out%WingsMesh) .AND. ALLOCATED(u1%WingsMesh)) THEN
  DO i01 = LBOUND(u_out%WingsMesh,1),UBOUND(u_out%WingsMesh,1)
      CALL MeshExtrapInterp2(u1%WingsMesh(i01), u2%WingsMesh(i01), u3%WingsMesh(i01), tin, u_out%WingsMesh(i01), tin_out, ErrStat2, ErrMsg2 )
        CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
   ENDDO
END IF ! check if allocated
IF (ALLOCATED(u_out%V_wind) .AND. ALLOCATED(u1%V_wind)) THEN
  ALLOCATE(b2(SIZE(u_out%V_wind,1),SIZE(u_out%V_wind,2) ))
  ALLOCATE(c2(SIZE(u_out%V_wind,1),SIZE(u_out%V_wind,2) ))
  b2 = (t(3)**2*(u1%V_wind - u2%V_wind) + t(2)**2*(-u1%V_wind + u3%V_wind))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*u1%V_wind + t(3)*u2%V_wind - t(2)*u3%V_wind ) / (t(2)*t(3)*(t(2) - t(3)))
  u_out%V_wind = u1%V_wind + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
 END SUBROUTINE FVW_Input_ExtrapInterp2


 SUBROUTINE FVW_Output_ExtrapInterp(y, t, y_out, t_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is given by the size of y
!
!  expressions below based on either
!
!  f(t) = a
!  f(t) = a + b * t, or
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3  (as appropriate)
!
!..................................................................................................................................

 TYPE(FVW_OutputType), INTENT(INOUT)  :: y(:) ! Output at t1 > t2 > t3
 REAL(DbKi),                 INTENT(IN   )  :: t(:)           ! Times associated with the Outputs
 TYPE(FVW_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: t_out           ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat         ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg          ! Error message if ErrStat /= ErrID_None
   ! local variables
 INTEGER(IntKi)                             :: order           ! order of polynomial fit (max 2)
 INTEGER(IntKi)                             :: ErrStat2        ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2         ! local errors
 CHARACTER(*),    PARAMETER                 :: RoutineName = 'FVW_Output_ExtrapInterp'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
 if ( size(t) .ne. size(y)) then
    CALL SetErrStat(ErrID_Fatal,'size(t) must equal size(y)',ErrStat,ErrMsg,RoutineName)
    RETURN
 endif
 order = SIZE(y) - 1
 IF ( order .eq. 0 ) THEN
   CALL FVW_CopyOutput(y(1), y_out, MESH_UPDATECOPY, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 1 ) THEN
   CALL FVW_Output_ExtrapInterp1(y(1), y(2), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE IF ( order .eq. 2 ) THEN
   CALL FVW_Output_ExtrapInterp2(y(1), y(2), y(3), t, y_out, t_out, ErrStat2, ErrMsg2 )
     CALL SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg,RoutineName)
 ELSE 
   CALL SetErrStat(ErrID_Fatal,'size(y) must be less than 4 (order must be less than 3).',ErrStat,ErrMsg,RoutineName)
   RETURN
 ENDIF 
 END SUBROUTINE FVW_Output_ExtrapInterp


 SUBROUTINE FVW_Output_ExtrapInterp1(y1, y2, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 1.
!
!  f(t) = a + b * t, or
!
!  where a and b are determined as the solution to
!  f(t1) = y1, f(t2) = y2
!
!..................................................................................................................................

 TYPE(FVW_OutputType), INTENT(INOUT)  :: y1    ! Output at t1 > t2
 TYPE(FVW_OutputType), INTENT(INOUT)  :: y2    ! Output at t2 
 REAL(DbKi),         INTENT(IN   )          :: tin(2)   ! Times associated with the Outputs
 TYPE(FVW_OutputType), INTENT(INOUT)  :: y_out ! Output at tin_out
 REAL(DbKi),         INTENT(IN   )          :: tin_out  ! time to be extrap/interp'd to
 INTEGER(IntKi),     INTENT(  OUT)          :: ErrStat  ! Error status of the operation
 CHARACTER(*),       INTENT(  OUT)          :: ErrMsg   ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(2)     ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out    ! Time to which to be extrap/interpd
 CHARACTER(*),                    PARAMETER :: RoutineName = 'FVW_Output_ExtrapInterp1'
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: b3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: c3       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF
IF (ALLOCATED(y_out%Vind) .AND. ALLOCATED(y1%Vind)) THEN
  ALLOCATE(b3(SIZE(y_out%Vind,1),SIZE(y_out%Vind,2), &
              SIZE(y_out%Vind,3)                     ))
  ALLOCATE(c3(SIZE(y_out%Vind,1),SIZE(y_out%Vind,2), &
              SIZE(y_out%Vind,3)                     ))
  b3 = -(y1%Vind - y2%Vind)/t(2)
  y_out%Vind = y1%Vind + b3 * t_out
  DEALLOCATE(b3)
  DEALLOCATE(c3)
END IF ! check if allocated
IF (ALLOCATED(y_out%r_wind) .AND. ALLOCATED(y1%r_wind)) THEN
  ALLOCATE(b2(SIZE(y_out%r_wind,1),SIZE(y_out%r_wind,2) ))
  ALLOCATE(c2(SIZE(y_out%r_wind,1),SIZE(y_out%r_wind,2) ))
  b2 = -(y1%r_wind - y2%r_wind)/t(2)
  y_out%r_wind = y1%r_wind + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(y_out%Cl_KJ) .AND. ALLOCATED(y1%Cl_KJ)) THEN
  ALLOCATE(b2(SIZE(y_out%Cl_KJ,1),SIZE(y_out%Cl_KJ,2) ))
  ALLOCATE(c2(SIZE(y_out%Cl_KJ,1),SIZE(y_out%Cl_KJ,2) ))
  b2 = -(y1%Cl_KJ - y2%Cl_KJ)/t(2)
  y_out%Cl_KJ = y1%Cl_KJ + b2 * t_out
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
 END SUBROUTINE FVW_Output_ExtrapInterp1


 SUBROUTINE FVW_Output_ExtrapInterp2(y1, y2, y3, tin, y_out, tin_out, ErrStat, ErrMsg )
!
! This subroutine calculates a extrapolated (or interpolated) Output y_out at time t_out, from previous/future time
! values of y (which has values associated with times in t).  Order of the interpolation is 2.
!
!  expressions below based on either
!
!  f(t) = a + b * t + c * t**2
!
!  where a, b and c are determined as the solution to
!  f(t1) = y1, f(t2) = y2, f(t3) = y3
!
!..................................................................................................................................

 TYPE(FVW_OutputType), INTENT(INOUT)  :: y1      ! Output at t1 > t2 > t3
 TYPE(FVW_OutputType), INTENT(INOUT)  :: y2      ! Output at t2 > t3
 TYPE(FVW_OutputType), INTENT(INOUT)  :: y3      ! Output at t3
 REAL(DbKi),                 INTENT(IN   )  :: tin(3)    ! Times associated with the Outputs
 TYPE(FVW_OutputType), INTENT(INOUT)  :: y_out     ! Output at tin_out
 REAL(DbKi),                 INTENT(IN   )  :: tin_out   ! time to be extrap/interp'd to
 INTEGER(IntKi),             INTENT(  OUT)  :: ErrStat   ! Error status of the operation
 CHARACTER(*),               INTENT(  OUT)  :: ErrMsg    ! Error message if ErrStat /= ErrID_None
   ! local variables
 REAL(DbKi)                                 :: t(3)      ! Times associated with the Outputs
 REAL(DbKi)                                 :: t_out     ! Time to which to be extrap/interpd
 INTEGER(IntKi)                             :: order     ! order of polynomial fit (max 2)
 REAL(DbKi)                                 :: b0       ! temporary for extrapolation/interpolation
 REAL(DbKi)                                 :: c0       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: b1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:)        :: c1       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: b2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:)      :: c2       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: b3       ! temporary for extrapolation/interpolation
 REAL(DbKi),ALLOCATABLE,DIMENSION(:,:,:)    :: c3       ! temporary for extrapolation/interpolation
 INTEGER(IntKi)                             :: ErrStat2 ! local errors
 CHARACTER(ErrMsgLen)                       :: ErrMsg2  ! local errors
 CHARACTER(*),            PARAMETER         :: RoutineName = 'FVW_Output_ExtrapInterp2'
    ! Initialize ErrStat
 ErrStat = ErrID_None
 ErrMsg  = ""
    ! we'll subtract a constant from the times to resolve some 
    ! numerical issues when t gets large (and to simplify the equations)
 t = tin - tin(1)
 t_out = tin_out - tin(1)

   IF ( EqualRealNos( t(1), t(2) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(2) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(2), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(2) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   ELSE IF ( EqualRealNos( t(1), t(3) ) ) THEN
     CALL SetErrStat(ErrID_Fatal, 't(1) must not equal t(3) to avoid a division-by-zero error.', ErrStat, ErrMsg,RoutineName)
     RETURN
   END IF
IF (ALLOCATED(y_out%Vind) .AND. ALLOCATED(y1%Vind)) THEN
  ALLOCATE(b3(SIZE(y_out%Vind,1),SIZE(y_out%Vind,2), &
              SIZE(y_out%Vind,3)                     ))
  ALLOCATE(c3(SIZE(y_out%Vind,1),SIZE(y_out%Vind,2), &
              SIZE(y_out%Vind,3)                     ))
  b3 = (t(3)**2*(y1%Vind - y2%Vind) + t(2)**2*(-y1%Vind + y3%Vind))/(t(2)*t(3)*(t(2) - t(3)))
  c3 = ( (t(2)-t(3))*y1%Vind + t(3)*y2%Vind - t(2)*y3%Vind ) / (t(2)*t(3)*(t(2) - t(3)))
  y_out%Vind = y1%Vind + b3 * t_out + c3 * t_out**2
  DEALLOCATE(b3)
  DEALLOCATE(c3)
END IF ! check if allocated
IF (ALLOCATED(y_out%r_wind) .AND. ALLOCATED(y1%r_wind)) THEN
  ALLOCATE(b2(SIZE(y_out%r_wind,1),SIZE(y_out%r_wind,2) ))
  ALLOCATE(c2(SIZE(y_out%r_wind,1),SIZE(y_out%r_wind,2) ))
  b2 = (t(3)**2*(y1%r_wind - y2%r_wind) + t(2)**2*(-y1%r_wind + y3%r_wind))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*y1%r_wind + t(3)*y2%r_wind - t(2)*y3%r_wind ) / (t(2)*t(3)*(t(2) - t(3)))
  y_out%r_wind = y1%r_wind + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
IF (ALLOCATED(y_out%Cl_KJ) .AND. ALLOCATED(y1%Cl_KJ)) THEN
  ALLOCATE(b2(SIZE(y_out%Cl_KJ,1),SIZE(y_out%Cl_KJ,2) ))
  ALLOCATE(c2(SIZE(y_out%Cl_KJ,1),SIZE(y_out%Cl_KJ,2) ))
  b2 = (t(3)**2*(y1%Cl_KJ - y2%Cl_KJ) + t(2)**2*(-y1%Cl_KJ + y3%Cl_KJ))/(t(2)*t(3)*(t(2) - t(3)))
  c2 = ( (t(2)-t(3))*y1%Cl_KJ + t(3)*y2%Cl_KJ - t(2)*y3%Cl_KJ ) / (t(2)*t(3)*(t(2) - t(3)))
  y_out%Cl_KJ = y1%Cl_KJ + b2 * t_out + c2 * t_out**2
  DEALLOCATE(b2)
  DEALLOCATE(c2)
END IF ! check if allocated
 END SUBROUTINE FVW_Output_ExtrapInterp2

END MODULE FVW_Types
!ENDOFREGISTRYGENERATEDFILE
