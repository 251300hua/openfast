!**********************************************************************************************************************************
! LICENSING
! Copyright (C) 2013-2016  National Renewable Energy Laboratory
!
!    This file is part of FAST's Controls and Electrical Drive Module, "ServoDyn".
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!**********************************************************************************************************************************
!> Control and electrical drive dynamics module for FAST   
MODULE ServoDyn

   USE ServoDyn_Types
   USE NWTC_Library
   USE BladedInterface
   USE StrucCtrl
   
   USE UserVSCont_KP    ! <- module not in the FAST Framework!
   USE PitchCntrl_ACH   ! <- module not in the FAST Framework!
   USE UserSubs         ! <- module not in the FAST Framework!

   IMPLICIT NONE

   PRIVATE

   TYPE(ProgDesc), PARAMETER            :: SrvD_Ver = ProgDesc( 'ServoDyn', '', '' )
   
#ifdef COMPILE_SIMULINK
   LOGICAL, PARAMETER, PUBLIC           :: Cmpl4SFun  = .TRUE.                            ! Is the module being compiled as an S-Function for Simulink?
#else
   LOGICAL, PARAMETER, PUBLIC           :: Cmpl4SFun  = .FALSE.                           ! Is the module being compiled as an S-Function for Simulink?
#endif

#ifdef COMPILE_LABVIEW
   LOGICAL, PARAMETER, PUBLIC           :: Cmpl4LV    = .TRUE.                            ! Is the module being compiled for Labview?
#else
   LOGICAL, PARAMETER, PUBLIC           :: Cmpl4LV    = .FALSE.                           ! Is the module being compiled for Labview?
#endif

      ! indices into linearization arrays
   INTEGER, PARAMETER :: Indx_u_Yaw     = 1
   INTEGER, PARAMETER :: Indx_u_YawRate = 2
   INTEGER, PARAMETER :: Indx_u_HSS_Spd = 3
   
   INTEGER, PARAMETER, PUBLIC :: SrvD_Indx_Y_BlPitchCom(3)  = (/1,2,3/)
   INTEGER, PARAMETER, PUBLIC :: SrvD_Indx_Y_YawMom  = 4
   INTEGER, PARAMETER, PUBLIC :: SrvD_Indx_Y_GenTrq  = 5
   INTEGER, PARAMETER, PUBLIC :: SrvD_Indx_Y_ElecPwr = 6
   INTEGER, PARAMETER, PUBLIC :: SrvD_Indx_Y_WrOutput = 6 ! last non-writeoutput variable

! ===================================================================================================
! NOTE: The following lines of code were generated by a Matlab script called "Write_ChckOutLst.m"
!      using the parameters listed in the "OutListParameters.xlsx" Excel file. Any changes to these
!      lines should be modified in the Matlab script and/or Excel worksheet as necessary.
! ===================================================================================================
! This code was generated by Write_ChckOutLst.m at 05-Dec-2020 09:46:03.


     ! Parameters related to output length (number of characters allowed in the output data headers):

   INTEGER(IntKi), PARAMETER      :: OutStrLenM1 = ChanLen - 1


     ! Indices for computing output channels:
     ! NOTES:
     !    (1) These parameters are in the order stored in "OutListParameters.xlsx"
     !    (2) Array AllOuts() must be dimensioned to the value of the largest output parameter

     !  Time:

   INTEGER(IntKi), PARAMETER      :: Time         =   0


     ! Airfoil control:

   INTEGER(IntKi), PARAMETER      :: BlAirFlC1    =   1
   INTEGER(IntKi), PARAMETER      :: BlAirFlC2    =   2
   INTEGER(IntKi), PARAMETER      :: BlAirFlC3    =   3


     ! Pitch Control:

   INTEGER(IntKi), PARAMETER      :: BlPitchC1    =   4
   INTEGER(IntKi), PARAMETER      :: BlPitchC2    =   5
   INTEGER(IntKi), PARAMETER      :: BlPitchC3    =   6


     ! Generator and Torque Control:

   INTEGER(IntKi), PARAMETER      :: GenTq        =   7
   INTEGER(IntKi), PARAMETER      :: GenPwr       =   8


     ! High Speed Shaft Brake:

   INTEGER(IntKi), PARAMETER      :: HSSBrTqC     =   9


     ! Nacelle Yaw Control:

   INTEGER(IntKi), PARAMETER      :: YawMomCom    =  10


     ! Nacelle Structural Control  (StC):

   INTEGER(IntKi), PARAMETER      :: NStC1_XQ     =  11
   INTEGER(IntKi), PARAMETER      :: NStC1_XQD    =  12
   INTEGER(IntKi), PARAMETER      :: NStC1_YQ     =  13
   INTEGER(IntKi), PARAMETER      :: NStC1_YQD    =  14
   INTEGER(IntKi), PARAMETER      :: NStC1_ZQ     =  15
   INTEGER(IntKi), PARAMETER      :: NStC1_ZQD    =  16
   INTEGER(IntKi), PARAMETER      :: NStC1_Fxi    =  17
   INTEGER(IntKi), PARAMETER      :: NStC1_Fyi    =  18
   INTEGER(IntKi), PARAMETER      :: NStC1_Fzi    =  19
   INTEGER(IntKi), PARAMETER      :: NStC1_Mxi    =  20
   INTEGER(IntKi), PARAMETER      :: NStC1_Myi    =  21
   INTEGER(IntKi), PARAMETER      :: NStC1_Mzi    =  22
   INTEGER(IntKi), PARAMETER      :: NStC1_Fxn    =  23
   INTEGER(IntKi), PARAMETER      :: NStC1_Fyn    =  24
   INTEGER(IntKi), PARAMETER      :: NStC1_Fzn    =  25
   INTEGER(IntKi), PARAMETER      :: NStC1_Mxn    =  26
   INTEGER(IntKi), PARAMETER      :: NStC1_Myn    =  27
   INTEGER(IntKi), PARAMETER      :: NStC1_Mzn    =  28
   INTEGER(IntKi), PARAMETER      :: NStC2_XQ     =  29
   INTEGER(IntKi), PARAMETER      :: NStC2_XQD    =  30
   INTEGER(IntKi), PARAMETER      :: NStC2_YQ     =  31
   INTEGER(IntKi), PARAMETER      :: NStC2_YQD    =  32
   INTEGER(IntKi), PARAMETER      :: NStC2_ZQ     =  33
   INTEGER(IntKi), PARAMETER      :: NStC2_ZQD    =  34
   INTEGER(IntKi), PARAMETER      :: NStC2_Fxi    =  35
   INTEGER(IntKi), PARAMETER      :: NStC2_Fyi    =  36
   INTEGER(IntKi), PARAMETER      :: NStC2_Fzi    =  37
   INTEGER(IntKi), PARAMETER      :: NStC2_Mxi    =  38
   INTEGER(IntKi), PARAMETER      :: NStC2_Myi    =  39
   INTEGER(IntKi), PARAMETER      :: NStC2_Mzi    =  40
   INTEGER(IntKi), PARAMETER      :: NStC2_Fxn    =  41
   INTEGER(IntKi), PARAMETER      :: NStC2_Fyn    =  42
   INTEGER(IntKi), PARAMETER      :: NStC2_Fzn    =  43
   INTEGER(IntKi), PARAMETER      :: NStC2_Mxn    =  44
   INTEGER(IntKi), PARAMETER      :: NStC2_Myn    =  45
   INTEGER(IntKi), PARAMETER      :: NStC2_Mzn    =  46
   INTEGER(IntKi), PARAMETER      :: NStC3_XQ     =  47
   INTEGER(IntKi), PARAMETER      :: NStC3_XQD    =  48
   INTEGER(IntKi), PARAMETER      :: NStC3_YQ     =  49
   INTEGER(IntKi), PARAMETER      :: NStC3_YQD    =  50
   INTEGER(IntKi), PARAMETER      :: NStC3_ZQ     =  51
   INTEGER(IntKi), PARAMETER      :: NStC3_ZQD    =  52
   INTEGER(IntKi), PARAMETER      :: NStC3_Fxi    =  53
   INTEGER(IntKi), PARAMETER      :: NStC3_Fyi    =  54
   INTEGER(IntKi), PARAMETER      :: NStC3_Fzi    =  55
   INTEGER(IntKi), PARAMETER      :: NStC3_Mxi    =  56
   INTEGER(IntKi), PARAMETER      :: NStC3_Myi    =  57
   INTEGER(IntKi), PARAMETER      :: NStC3_Mzi    =  58
   INTEGER(IntKi), PARAMETER      :: NStC3_Fxn    =  59
   INTEGER(IntKi), PARAMETER      :: NStC3_Fyn    =  60
   INTEGER(IntKi), PARAMETER      :: NStC3_Fzn    =  61
   INTEGER(IntKi), PARAMETER      :: NStC3_Mxn    =  62
   INTEGER(IntKi), PARAMETER      :: NStC3_Myn    =  63
   INTEGER(IntKi), PARAMETER      :: NStC3_Mzn    =  64
   INTEGER(IntKi), PARAMETER      :: NStC4_XQ     =  65
   INTEGER(IntKi), PARAMETER      :: NStC4_XQD    =  66
   INTEGER(IntKi), PARAMETER      :: NStC4_YQ     =  67
   INTEGER(IntKi), PARAMETER      :: NStC4_YQD    =  68
   INTEGER(IntKi), PARAMETER      :: NStC4_ZQ     =  69
   INTEGER(IntKi), PARAMETER      :: NStC4_ZQD    =  70
   INTEGER(IntKi), PARAMETER      :: NStC4_Fxi    =  71
   INTEGER(IntKi), PARAMETER      :: NStC4_Fyi    =  72
   INTEGER(IntKi), PARAMETER      :: NStC4_Fzi    =  73
   INTEGER(IntKi), PARAMETER      :: NStC4_Mxi    =  74
   INTEGER(IntKi), PARAMETER      :: NStC4_Myi    =  75
   INTEGER(IntKi), PARAMETER      :: NStC4_Mzi    =  76
   INTEGER(IntKi), PARAMETER      :: NStC4_Fxn    =  77
   INTEGER(IntKi), PARAMETER      :: NStC4_Fyn    =  78
   INTEGER(IntKi), PARAMETER      :: NStC4_Fzn    =  79
   INTEGER(IntKi), PARAMETER      :: NStC4_Mxn    =  80
   INTEGER(IntKi), PARAMETER      :: NStC4_Myn    =  81
   INTEGER(IntKi), PARAMETER      :: NStC4_Mzn    =  82


     ! Tower Structural Control  (StC):

   INTEGER(IntKi), PARAMETER      :: TStC1_XQ     =  83
   INTEGER(IntKi), PARAMETER      :: TStC1_XQD    =  84
   INTEGER(IntKi), PARAMETER      :: TStC1_YQ     =  85
   INTEGER(IntKi), PARAMETER      :: TStC1_YQD    =  86
   INTEGER(IntKi), PARAMETER      :: TStC1_ZQ     =  87
   INTEGER(IntKi), PARAMETER      :: TStC1_ZQD    =  88
   INTEGER(IntKi), PARAMETER      :: TStC1_Fxi    =  89
   INTEGER(IntKi), PARAMETER      :: TStC1_Fyi    =  90
   INTEGER(IntKi), PARAMETER      :: TStC1_Fzi    =  91
   INTEGER(IntKi), PARAMETER      :: TStC1_Mxi    =  92
   INTEGER(IntKi), PARAMETER      :: TStC1_Myi    =  93
   INTEGER(IntKi), PARAMETER      :: TStC1_Mzi    =  94
   INTEGER(IntKi), PARAMETER      :: TStC1_Fxn    =  95
   INTEGER(IntKi), PARAMETER      :: TStC1_Fyn    =  96
   INTEGER(IntKi), PARAMETER      :: TStC1_Fzn    =  97
   INTEGER(IntKi), PARAMETER      :: TStC1_Mxn    =  98
   INTEGER(IntKi), PARAMETER      :: TStC1_Myn    =  99
   INTEGER(IntKi), PARAMETER      :: TStC1_Mzn    = 100
   INTEGER(IntKi), PARAMETER      :: TStC2_XQ     = 101
   INTEGER(IntKi), PARAMETER      :: TStC2_XQD    = 102
   INTEGER(IntKi), PARAMETER      :: TStC2_YQ     = 103
   INTEGER(IntKi), PARAMETER      :: TStC2_YQD    = 104
   INTEGER(IntKi), PARAMETER      :: TStC2_ZQ     = 105
   INTEGER(IntKi), PARAMETER      :: TStC2_ZQD    = 106
   INTEGER(IntKi), PARAMETER      :: TStC2_Fxi    = 107
   INTEGER(IntKi), PARAMETER      :: TStC2_Fyi    = 108
   INTEGER(IntKi), PARAMETER      :: TStC2_Fzi    = 109
   INTEGER(IntKi), PARAMETER      :: TStC2_Mxi    = 110
   INTEGER(IntKi), PARAMETER      :: TStC2_Myi    = 111
   INTEGER(IntKi), PARAMETER      :: TStC2_Mzi    = 112
   INTEGER(IntKi), PARAMETER      :: TStC2_Fxn    = 113
   INTEGER(IntKi), PARAMETER      :: TStC2_Fyn    = 114
   INTEGER(IntKi), PARAMETER      :: TStC2_Fzn    = 115
   INTEGER(IntKi), PARAMETER      :: TStC2_Mxn    = 116
   INTEGER(IntKi), PARAMETER      :: TStC2_Myn    = 117
   INTEGER(IntKi), PARAMETER      :: TStC2_Mzn    = 118
   INTEGER(IntKi), PARAMETER      :: TStC3_XQ     = 119
   INTEGER(IntKi), PARAMETER      :: TStC3_XQD    = 120
   INTEGER(IntKi), PARAMETER      :: TStC3_YQ     = 121
   INTEGER(IntKi), PARAMETER      :: TStC3_YQD    = 122
   INTEGER(IntKi), PARAMETER      :: TStC3_ZQ     = 123
   INTEGER(IntKi), PARAMETER      :: TStC3_ZQD    = 124
   INTEGER(IntKi), PARAMETER      :: TStC3_Fxi    = 125
   INTEGER(IntKi), PARAMETER      :: TStC3_Fyi    = 126
   INTEGER(IntKi), PARAMETER      :: TStC3_Fzi    = 127
   INTEGER(IntKi), PARAMETER      :: TStC3_Mxi    = 128
   INTEGER(IntKi), PARAMETER      :: TStC3_Myi    = 129
   INTEGER(IntKi), PARAMETER      :: TStC3_Mzi    = 130
   INTEGER(IntKi), PARAMETER      :: TStC3_Fxn    = 131
   INTEGER(IntKi), PARAMETER      :: TStC3_Fyn    = 132
   INTEGER(IntKi), PARAMETER      :: TStC3_Fzn    = 133
   INTEGER(IntKi), PARAMETER      :: TStC3_Mxn    = 134
   INTEGER(IntKi), PARAMETER      :: TStC3_Myn    = 135
   INTEGER(IntKi), PARAMETER      :: TStC3_Mzn    = 136
   INTEGER(IntKi), PARAMETER      :: TStC4_XQ     = 137
   INTEGER(IntKi), PARAMETER      :: TStC4_XQD    = 138
   INTEGER(IntKi), PARAMETER      :: TStC4_YQ     = 139
   INTEGER(IntKi), PARAMETER      :: TStC4_YQD    = 140
   INTEGER(IntKi), PARAMETER      :: TStC4_ZQ     = 141
   INTEGER(IntKi), PARAMETER      :: TStC4_ZQD    = 142
   INTEGER(IntKi), PARAMETER      :: TStC4_Fxi    = 143
   INTEGER(IntKi), PARAMETER      :: TStC4_Fyi    = 144
   INTEGER(IntKi), PARAMETER      :: TStC4_Fzi    = 145
   INTEGER(IntKi), PARAMETER      :: TStC4_Mxi    = 146
   INTEGER(IntKi), PARAMETER      :: TStC4_Myi    = 147
   INTEGER(IntKi), PARAMETER      :: TStC4_Mzi    = 148
   INTEGER(IntKi), PARAMETER      :: TStC4_Fxn    = 149
   INTEGER(IntKi), PARAMETER      :: TStC4_Fyn    = 150
   INTEGER(IntKi), PARAMETER      :: TStC4_Fzn    = 151
   INTEGER(IntKi), PARAMETER      :: TStC4_Mxn    = 152
   INTEGER(IntKi), PARAMETER      :: TStC4_Myn    = 153
   INTEGER(IntKi), PARAMETER      :: TStC4_Mzn    = 154


     ! Blade  Structural Control  (StC):

   INTEGER(IntKi), PARAMETER      :: BStC1_B1_XQ  = 155
   INTEGER(IntKi), PARAMETER      :: BStC1_B1_XQD = 156
   INTEGER(IntKi), PARAMETER      :: BStC1_B1_YQ  = 157
   INTEGER(IntKi), PARAMETER      :: BStC1_B1_YQD = 158
   INTEGER(IntKi), PARAMETER      :: BStC1_B1_ZQ  = 159
   INTEGER(IntKi), PARAMETER      :: BStC1_B1_ZQD = 160
   INTEGER(IntKi), PARAMETER      :: BStC1_B1_Fxi = 161
   INTEGER(IntKi), PARAMETER      :: BStC1_B1_Fyi = 162
   INTEGER(IntKi), PARAMETER      :: BStC1_B1_Fzi = 163
   INTEGER(IntKi), PARAMETER      :: BStC1_B1_Mxi = 164
   INTEGER(IntKi), PARAMETER      :: BStC1_B1_Myi = 165
   INTEGER(IntKi), PARAMETER      :: BStC1_B1_Mzi = 166
   INTEGER(IntKi), PARAMETER      :: BStC1_B1_Fxn = 167
   INTEGER(IntKi), PARAMETER      :: BStC1_B1_Fyn = 168
   INTEGER(IntKi), PARAMETER      :: BStC1_B1_Fzn = 169
   INTEGER(IntKi), PARAMETER      :: BStC1_B1_Mxn = 170
   INTEGER(IntKi), PARAMETER      :: BStC1_B1_Myn = 171
   INTEGER(IntKi), PARAMETER      :: BStC1_B1_Mzn = 172
   INTEGER(IntKi), PARAMETER      :: BStC2_B1_XQ  = 173
   INTEGER(IntKi), PARAMETER      :: BStC2_B1_XQD = 174
   INTEGER(IntKi), PARAMETER      :: BStC2_B1_YQ  = 175
   INTEGER(IntKi), PARAMETER      :: BStC2_B1_YQD = 176
   INTEGER(IntKi), PARAMETER      :: BStC2_B1_ZQ  = 177
   INTEGER(IntKi), PARAMETER      :: BStC2_B1_ZQD = 178
   INTEGER(IntKi), PARAMETER      :: BStC2_B1_Fxi = 179
   INTEGER(IntKi), PARAMETER      :: BStC2_B1_Fyi = 180
   INTEGER(IntKi), PARAMETER      :: BStC2_B1_Fzi = 181
   INTEGER(IntKi), PARAMETER      :: BStC2_B1_Mxi = 182
   INTEGER(IntKi), PARAMETER      :: BStC2_B1_Myi = 183
   INTEGER(IntKi), PARAMETER      :: BStC2_B1_Mzi = 184
   INTEGER(IntKi), PARAMETER      :: BStC2_B1_Fxn = 185
   INTEGER(IntKi), PARAMETER      :: BStC2_B1_Fyn = 186
   INTEGER(IntKi), PARAMETER      :: BStC2_B1_Fzn = 187
   INTEGER(IntKi), PARAMETER      :: BStC2_B1_Mxn = 188
   INTEGER(IntKi), PARAMETER      :: BStC2_B1_Myn = 189
   INTEGER(IntKi), PARAMETER      :: BStC2_B1_Mzn = 190
   INTEGER(IntKi), PARAMETER      :: BStC3_B1_XQ  = 191
   INTEGER(IntKi), PARAMETER      :: BStC3_B1_XQD = 192
   INTEGER(IntKi), PARAMETER      :: BStC3_B1_YQ  = 193
   INTEGER(IntKi), PARAMETER      :: BStC3_B1_YQD = 194
   INTEGER(IntKi), PARAMETER      :: BStC3_B1_ZQ  = 195
   INTEGER(IntKi), PARAMETER      :: BStC3_B1_ZQD = 196
   INTEGER(IntKi), PARAMETER      :: BStC3_B1_Fxi = 197
   INTEGER(IntKi), PARAMETER      :: BStC3_B1_Fyi = 198
   INTEGER(IntKi), PARAMETER      :: BStC3_B1_Fzi = 199
   INTEGER(IntKi), PARAMETER      :: BStC3_B1_Mxi = 200
   INTEGER(IntKi), PARAMETER      :: BStC3_B1_Myi = 201
   INTEGER(IntKi), PARAMETER      :: BStC3_B1_Mzi = 202
   INTEGER(IntKi), PARAMETER      :: BStC3_B1_Fxn = 203
   INTEGER(IntKi), PARAMETER      :: BStC3_B1_Fyn = 204
   INTEGER(IntKi), PARAMETER      :: BStC3_B1_Fzn = 205
   INTEGER(IntKi), PARAMETER      :: BStC3_B1_Mxn = 206
   INTEGER(IntKi), PARAMETER      :: BStC3_B1_Myn = 207
   INTEGER(IntKi), PARAMETER      :: BStC3_B1_Mzn = 208
   INTEGER(IntKi), PARAMETER      :: BStC4_B1_XQ  = 209
   INTEGER(IntKi), PARAMETER      :: BStC4_B1_XQD = 210
   INTEGER(IntKi), PARAMETER      :: BStC4_B1_YQ  = 211
   INTEGER(IntKi), PARAMETER      :: BStC4_B1_YQD = 212
   INTEGER(IntKi), PARAMETER      :: BStC4_B1_ZQ  = 213
   INTEGER(IntKi), PARAMETER      :: BStC4_B1_ZQD = 214
   INTEGER(IntKi), PARAMETER      :: BStC4_B1_Fxi = 215
   INTEGER(IntKi), PARAMETER      :: BStC4_B1_Fyi = 216
   INTEGER(IntKi), PARAMETER      :: BStC4_B1_Fzi = 217
   INTEGER(IntKi), PARAMETER      :: BStC4_B1_Mxi = 218
   INTEGER(IntKi), PARAMETER      :: BStC4_B1_Myi = 219
   INTEGER(IntKi), PARAMETER      :: BStC4_B1_Mzi = 220
   INTEGER(IntKi), PARAMETER      :: BStC4_B1_Fxn = 221
   INTEGER(IntKi), PARAMETER      :: BStC4_B1_Fyn = 222
   INTEGER(IntKi), PARAMETER      :: BStC4_B1_Fzn = 223
   INTEGER(IntKi), PARAMETER      :: BStC4_B1_Mxn = 224
   INTEGER(IntKi), PARAMETER      :: BStC4_B1_Myn = 225
   INTEGER(IntKi), PARAMETER      :: BStC4_B1_Mzn = 226
   INTEGER(IntKi), PARAMETER      :: BStC1_B2_XQ  = 227
   INTEGER(IntKi), PARAMETER      :: BStC1_B2_XQD = 228
   INTEGER(IntKi), PARAMETER      :: BStC1_B2_YQ  = 229
   INTEGER(IntKi), PARAMETER      :: BStC1_B2_YQD = 230
   INTEGER(IntKi), PARAMETER      :: BStC1_B2_ZQ  = 231
   INTEGER(IntKi), PARAMETER      :: BStC1_B2_ZQD = 232
   INTEGER(IntKi), PARAMETER      :: BStC1_B2_Fxi = 233
   INTEGER(IntKi), PARAMETER      :: BStC1_B2_Fyi = 234
   INTEGER(IntKi), PARAMETER      :: BStC1_B2_Fzi = 235
   INTEGER(IntKi), PARAMETER      :: BStC1_B2_Mxi = 236
   INTEGER(IntKi), PARAMETER      :: BStC1_B2_Myi = 237
   INTEGER(IntKi), PARAMETER      :: BStC1_B2_Mzi = 238
   INTEGER(IntKi), PARAMETER      :: BStC1_B2_Fxn = 239
   INTEGER(IntKi), PARAMETER      :: BStC1_B2_Fyn = 240
   INTEGER(IntKi), PARAMETER      :: BStC1_B2_Fzn = 241
   INTEGER(IntKi), PARAMETER      :: BStC1_B2_Mxn = 242
   INTEGER(IntKi), PARAMETER      :: BStC1_B2_Myn = 243
   INTEGER(IntKi), PARAMETER      :: BStC1_B2_Mzn = 244
   INTEGER(IntKi), PARAMETER      :: BStC2_B2_XQ  = 245
   INTEGER(IntKi), PARAMETER      :: BStC2_B2_XQD = 246
   INTEGER(IntKi), PARAMETER      :: BStC2_B2_YQ  = 247
   INTEGER(IntKi), PARAMETER      :: BStC2_B2_YQD = 248
   INTEGER(IntKi), PARAMETER      :: BStC2_B2_ZQ  = 249
   INTEGER(IntKi), PARAMETER      :: BStC2_B2_ZQD = 250
   INTEGER(IntKi), PARAMETER      :: BStC2_B2_Fxi = 251
   INTEGER(IntKi), PARAMETER      :: BStC2_B2_Fyi = 252
   INTEGER(IntKi), PARAMETER      :: BStC2_B2_Fzi = 253
   INTEGER(IntKi), PARAMETER      :: BStC2_B2_Mxi = 254
   INTEGER(IntKi), PARAMETER      :: BStC2_B2_Myi = 255
   INTEGER(IntKi), PARAMETER      :: BStC2_B2_Mzi = 256
   INTEGER(IntKi), PARAMETER      :: BStC2_B2_Fxn = 257
   INTEGER(IntKi), PARAMETER      :: BStC2_B2_Fyn = 258
   INTEGER(IntKi), PARAMETER      :: BStC2_B2_Fzn = 259
   INTEGER(IntKi), PARAMETER      :: BStC2_B2_Mxn = 260
   INTEGER(IntKi), PARAMETER      :: BStC2_B2_Myn = 261
   INTEGER(IntKi), PARAMETER      :: BStC2_B2_Mzn = 262
   INTEGER(IntKi), PARAMETER      :: BStC3_B2_XQ  = 263
   INTEGER(IntKi), PARAMETER      :: BStC3_B2_XQD = 264
   INTEGER(IntKi), PARAMETER      :: BStC3_B2_YQ  = 265
   INTEGER(IntKi), PARAMETER      :: BStC3_B2_YQD = 266
   INTEGER(IntKi), PARAMETER      :: BStC3_B2_ZQ  = 267
   INTEGER(IntKi), PARAMETER      :: BStC3_B2_ZQD = 268
   INTEGER(IntKi), PARAMETER      :: BStC3_B2_Fxi = 269
   INTEGER(IntKi), PARAMETER      :: BStC3_B2_Fyi = 270
   INTEGER(IntKi), PARAMETER      :: BStC3_B2_Fzi = 271
   INTEGER(IntKi), PARAMETER      :: BStC3_B2_Mxi = 272
   INTEGER(IntKi), PARAMETER      :: BStC3_B2_Myi = 273
   INTEGER(IntKi), PARAMETER      :: BStC3_B2_Mzi = 274
   INTEGER(IntKi), PARAMETER      :: BStC3_B2_Fxn = 275
   INTEGER(IntKi), PARAMETER      :: BStC3_B2_Fyn = 276
   INTEGER(IntKi), PARAMETER      :: BStC3_B2_Fzn = 277
   INTEGER(IntKi), PARAMETER      :: BStC3_B2_Mxn = 278
   INTEGER(IntKi), PARAMETER      :: BStC3_B2_Myn = 279
   INTEGER(IntKi), PARAMETER      :: BStC3_B2_Mzn = 280
   INTEGER(IntKi), PARAMETER      :: BStC4_B2_XQ  = 281
   INTEGER(IntKi), PARAMETER      :: BStC4_B2_XQD = 282
   INTEGER(IntKi), PARAMETER      :: BStC4_B2_YQ  = 283
   INTEGER(IntKi), PARAMETER      :: BStC4_B2_YQD = 284
   INTEGER(IntKi), PARAMETER      :: BStC4_B2_ZQ  = 285
   INTEGER(IntKi), PARAMETER      :: BStC4_B2_ZQD = 286
   INTEGER(IntKi), PARAMETER      :: BStC4_B2_Fxi = 287
   INTEGER(IntKi), PARAMETER      :: BStC4_B2_Fyi = 288
   INTEGER(IntKi), PARAMETER      :: BStC4_B2_Fzi = 289
   INTEGER(IntKi), PARAMETER      :: BStC4_B2_Mxi = 290
   INTEGER(IntKi), PARAMETER      :: BStC4_B2_Myi = 291
   INTEGER(IntKi), PARAMETER      :: BStC4_B2_Mzi = 292
   INTEGER(IntKi), PARAMETER      :: BStC4_B2_Fxn = 293
   INTEGER(IntKi), PARAMETER      :: BStC4_B2_Fyn = 294
   INTEGER(IntKi), PARAMETER      :: BStC4_B2_Fzn = 295
   INTEGER(IntKi), PARAMETER      :: BStC4_B2_Mxn = 296
   INTEGER(IntKi), PARAMETER      :: BStC4_B2_Myn = 297
   INTEGER(IntKi), PARAMETER      :: BStC4_B2_Mzn = 298
   INTEGER(IntKi), PARAMETER      :: BStC1_B3_XQ  = 299
   INTEGER(IntKi), PARAMETER      :: BStC1_B3_XQD = 300
   INTEGER(IntKi), PARAMETER      :: BStC1_B3_YQ  = 301
   INTEGER(IntKi), PARAMETER      :: BStC1_B3_YQD = 302
   INTEGER(IntKi), PARAMETER      :: BStC1_B3_ZQ  = 303
   INTEGER(IntKi), PARAMETER      :: BStC1_B3_ZQD = 304
   INTEGER(IntKi), PARAMETER      :: BStC1_B3_Fxi = 305
   INTEGER(IntKi), PARAMETER      :: BStC1_B3_Fyi = 306
   INTEGER(IntKi), PARAMETER      :: BStC1_B3_Fzi = 307
   INTEGER(IntKi), PARAMETER      :: BStC1_B3_Mxi = 308
   INTEGER(IntKi), PARAMETER      :: BStC1_B3_Myi = 309
   INTEGER(IntKi), PARAMETER      :: BStC1_B3_Mzi = 310
   INTEGER(IntKi), PARAMETER      :: BStC1_B3_Fxn = 311
   INTEGER(IntKi), PARAMETER      :: BStC1_B3_Fyn = 312
   INTEGER(IntKi), PARAMETER      :: BStC1_B3_Fzn = 313
   INTEGER(IntKi), PARAMETER      :: BStC1_B3_Mxn = 314
   INTEGER(IntKi), PARAMETER      :: BStC1_B3_Myn = 315
   INTEGER(IntKi), PARAMETER      :: BStC1_B3_Mzn = 316
   INTEGER(IntKi), PARAMETER      :: BStC2_B3_XQ  = 317
   INTEGER(IntKi), PARAMETER      :: BStC2_B3_XQD = 318
   INTEGER(IntKi), PARAMETER      :: BStC2_B3_YQ  = 319
   INTEGER(IntKi), PARAMETER      :: BStC2_B3_YQD = 320
   INTEGER(IntKi), PARAMETER      :: BStC2_B3_ZQ  = 321
   INTEGER(IntKi), PARAMETER      :: BStC2_B3_ZQD = 322
   INTEGER(IntKi), PARAMETER      :: BStC2_B3_Fxi = 323
   INTEGER(IntKi), PARAMETER      :: BStC2_B3_Fyi = 324
   INTEGER(IntKi), PARAMETER      :: BStC2_B3_Fzi = 325
   INTEGER(IntKi), PARAMETER      :: BStC2_B3_Mxi = 326
   INTEGER(IntKi), PARAMETER      :: BStC2_B3_Myi = 327
   INTEGER(IntKi), PARAMETER      :: BStC2_B3_Mzi = 328
   INTEGER(IntKi), PARAMETER      :: BStC2_B3_Fxn = 329
   INTEGER(IntKi), PARAMETER      :: BStC2_B3_Fyn = 330
   INTEGER(IntKi), PARAMETER      :: BStC2_B3_Fzn = 331
   INTEGER(IntKi), PARAMETER      :: BStC2_B3_Mxn = 332
   INTEGER(IntKi), PARAMETER      :: BStC2_B3_Myn = 333
   INTEGER(IntKi), PARAMETER      :: BStC2_B3_Mzn = 334
   INTEGER(IntKi), PARAMETER      :: BStC3_B3_XQ  = 335
   INTEGER(IntKi), PARAMETER      :: BStC3_B3_XQD = 336
   INTEGER(IntKi), PARAMETER      :: BStC3_B3_YQ  = 337
   INTEGER(IntKi), PARAMETER      :: BStC3_B3_YQD = 338
   INTEGER(IntKi), PARAMETER      :: BStC3_B3_ZQ  = 339
   INTEGER(IntKi), PARAMETER      :: BStC3_B3_ZQD = 340
   INTEGER(IntKi), PARAMETER      :: BStC3_B3_Fxi = 341
   INTEGER(IntKi), PARAMETER      :: BStC3_B3_Fyi = 342
   INTEGER(IntKi), PARAMETER      :: BStC3_B3_Fzi = 343
   INTEGER(IntKi), PARAMETER      :: BStC3_B3_Mxi = 344
   INTEGER(IntKi), PARAMETER      :: BStC3_B3_Myi = 345
   INTEGER(IntKi), PARAMETER      :: BStC3_B3_Mzi = 346
   INTEGER(IntKi), PARAMETER      :: BStC3_B3_Fxn = 347
   INTEGER(IntKi), PARAMETER      :: BStC3_B3_Fyn = 348
   INTEGER(IntKi), PARAMETER      :: BStC3_B3_Fzn = 349
   INTEGER(IntKi), PARAMETER      :: BStC3_B3_Mxn = 350
   INTEGER(IntKi), PARAMETER      :: BStC3_B3_Myn = 351
   INTEGER(IntKi), PARAMETER      :: BStC3_B3_Mzn = 352
   INTEGER(IntKi), PARAMETER      :: BStC4_B3_XQ  = 353
   INTEGER(IntKi), PARAMETER      :: BStC4_B3_XQD = 354
   INTEGER(IntKi), PARAMETER      :: BStC4_B3_YQ  = 355
   INTEGER(IntKi), PARAMETER      :: BStC4_B3_YQD = 356
   INTEGER(IntKi), PARAMETER      :: BStC4_B3_ZQ  = 357
   INTEGER(IntKi), PARAMETER      :: BStC4_B3_ZQD = 358
   INTEGER(IntKi), PARAMETER      :: BStC4_B3_Fxi = 359
   INTEGER(IntKi), PARAMETER      :: BStC4_B3_Fyi = 360
   INTEGER(IntKi), PARAMETER      :: BStC4_B3_Fzi = 361
   INTEGER(IntKi), PARAMETER      :: BStC4_B3_Mxi = 362
   INTEGER(IntKi), PARAMETER      :: BStC4_B3_Myi = 363
   INTEGER(IntKi), PARAMETER      :: BStC4_B3_Mzi = 364
   INTEGER(IntKi), PARAMETER      :: BStC4_B3_Fxn = 365
   INTEGER(IntKi), PARAMETER      :: BStC4_B3_Fyn = 366
   INTEGER(IntKi), PARAMETER      :: BStC4_B3_Fzn = 367
   INTEGER(IntKi), PARAMETER      :: BStC4_B3_Mxn = 368
   INTEGER(IntKi), PARAMETER      :: BStC4_B3_Myn = 369
   INTEGER(IntKi), PARAMETER      :: BStC4_B3_Mzn = 370
   INTEGER(IntKi), PARAMETER      :: BStC1_B4_XQ  = 371
   INTEGER(IntKi), PARAMETER      :: BStC1_B4_XQD = 372
   INTEGER(IntKi), PARAMETER      :: BStC1_B4_YQ  = 373
   INTEGER(IntKi), PARAMETER      :: BStC1_B4_YQD = 374
   INTEGER(IntKi), PARAMETER      :: BStC1_B4_ZQ  = 375
   INTEGER(IntKi), PARAMETER      :: BStC1_B4_ZQD = 376
   INTEGER(IntKi), PARAMETER      :: BStC1_B4_Fxi = 377
   INTEGER(IntKi), PARAMETER      :: BStC1_B4_Fyi = 378
   INTEGER(IntKi), PARAMETER      :: BStC1_B4_Fzi = 379
   INTEGER(IntKi), PARAMETER      :: BStC1_B4_Mxi = 380
   INTEGER(IntKi), PARAMETER      :: BStC1_B4_Myi = 381
   INTEGER(IntKi), PARAMETER      :: BStC1_B4_Mzi = 382
   INTEGER(IntKi), PARAMETER      :: BStC1_B4_Fxn = 383
   INTEGER(IntKi), PARAMETER      :: BStC1_B4_Fyn = 384
   INTEGER(IntKi), PARAMETER      :: BStC1_B4_Fzn = 385
   INTEGER(IntKi), PARAMETER      :: BStC1_B4_Mxn = 386
   INTEGER(IntKi), PARAMETER      :: BStC1_B4_Myn = 387
   INTEGER(IntKi), PARAMETER      :: BStC1_B4_Mzn = 388
   INTEGER(IntKi), PARAMETER      :: BStC2_B4_XQ  = 389
   INTEGER(IntKi), PARAMETER      :: BStC2_B4_XQD = 390
   INTEGER(IntKi), PARAMETER      :: BStC2_B4_YQ  = 391
   INTEGER(IntKi), PARAMETER      :: BStC2_B4_YQD = 392
   INTEGER(IntKi), PARAMETER      :: BStC2_B4_ZQ  = 393
   INTEGER(IntKi), PARAMETER      :: BStC2_B4_ZQD = 394
   INTEGER(IntKi), PARAMETER      :: BStC2_B4_Fxi = 395
   INTEGER(IntKi), PARAMETER      :: BStC2_B4_Fyi = 396
   INTEGER(IntKi), PARAMETER      :: BStC2_B4_Fzi = 397
   INTEGER(IntKi), PARAMETER      :: BStC2_B4_Mxi = 398
   INTEGER(IntKi), PARAMETER      :: BStC2_B4_Myi = 399
   INTEGER(IntKi), PARAMETER      :: BStC2_B4_Mzi = 400
   INTEGER(IntKi), PARAMETER      :: BStC2_B4_Fxn = 401
   INTEGER(IntKi), PARAMETER      :: BStC2_B4_Fyn = 402
   INTEGER(IntKi), PARAMETER      :: BStC2_B4_Fzn = 403
   INTEGER(IntKi), PARAMETER      :: BStC2_B4_Mxn = 404
   INTEGER(IntKi), PARAMETER      :: BStC2_B4_Myn = 405
   INTEGER(IntKi), PARAMETER      :: BStC2_B4_Mzn = 406
   INTEGER(IntKi), PARAMETER      :: BStC3_B4_XQ  = 407
   INTEGER(IntKi), PARAMETER      :: BStC3_B4_XQD = 408
   INTEGER(IntKi), PARAMETER      :: BStC3_B4_YQ  = 409
   INTEGER(IntKi), PARAMETER      :: BStC3_B4_YQD = 410
   INTEGER(IntKi), PARAMETER      :: BStC3_B4_ZQ  = 411
   INTEGER(IntKi), PARAMETER      :: BStC3_B4_ZQD = 412
   INTEGER(IntKi), PARAMETER      :: BStC3_B4_Fxi = 413
   INTEGER(IntKi), PARAMETER      :: BStC3_B4_Fyi = 414
   INTEGER(IntKi), PARAMETER      :: BStC3_B4_Fzi = 415
   INTEGER(IntKi), PARAMETER      :: BStC3_B4_Mxi = 416
   INTEGER(IntKi), PARAMETER      :: BStC3_B4_Myi = 417
   INTEGER(IntKi), PARAMETER      :: BStC3_B4_Mzi = 418
   INTEGER(IntKi), PARAMETER      :: BStC3_B4_Fxn = 419
   INTEGER(IntKi), PARAMETER      :: BStC3_B4_Fyn = 420
   INTEGER(IntKi), PARAMETER      :: BStC3_B4_Fzn = 421
   INTEGER(IntKi), PARAMETER      :: BStC3_B4_Mxn = 422
   INTEGER(IntKi), PARAMETER      :: BStC3_B4_Myn = 423
   INTEGER(IntKi), PARAMETER      :: BStC3_B4_Mzn = 424
   INTEGER(IntKi), PARAMETER      :: BStC4_B4_XQ  = 425
   INTEGER(IntKi), PARAMETER      :: BStC4_B4_XQD = 426
   INTEGER(IntKi), PARAMETER      :: BStC4_B4_YQ  = 427
   INTEGER(IntKi), PARAMETER      :: BStC4_B4_YQD = 428
   INTEGER(IntKi), PARAMETER      :: BStC4_B4_ZQ  = 429
   INTEGER(IntKi), PARAMETER      :: BStC4_B4_ZQD = 430
   INTEGER(IntKi), PARAMETER      :: BStC4_B4_Fxi = 431
   INTEGER(IntKi), PARAMETER      :: BStC4_B4_Fyi = 432
   INTEGER(IntKi), PARAMETER      :: BStC4_B4_Fzi = 433
   INTEGER(IntKi), PARAMETER      :: BStC4_B4_Mxi = 434
   INTEGER(IntKi), PARAMETER      :: BStC4_B4_Myi = 435
   INTEGER(IntKi), PARAMETER      :: BStC4_B4_Mzi = 436
   INTEGER(IntKi), PARAMETER      :: BStC4_B4_Fxn = 437
   INTEGER(IntKi), PARAMETER      :: BStC4_B4_Fyn = 438
   INTEGER(IntKi), PARAMETER      :: BStC4_B4_Fzn = 439
   INTEGER(IntKi), PARAMETER      :: BStC4_B4_Mxn = 440
   INTEGER(IntKi), PARAMETER      :: BStC4_B4_Myn = 441
   INTEGER(IntKi), PARAMETER      :: BStC4_B4_Mzn = 442


     ! Platform  Structural Control  (StC):

   INTEGER(IntKi), PARAMETER      :: PtfmStC1_XQ  = 443
   INTEGER(IntKi), PARAMETER      :: PtfmStC1_XQD = 444
   INTEGER(IntKi), PARAMETER      :: PtfmStC1_YQ  = 445
   INTEGER(IntKi), PARAMETER      :: PtfmStC1_YQD = 446
   INTEGER(IntKi), PARAMETER      :: PtfmStC1_ZQ  = 447
   INTEGER(IntKi), PARAMETER      :: PtfmStC1_ZQD = 448
   INTEGER(IntKi), PARAMETER      :: PtfmStC1_Fxi = 449
   INTEGER(IntKi), PARAMETER      :: PtfmStC1_Fyi = 450
   INTEGER(IntKi), PARAMETER      :: PtfmStC1_Fzi = 451
   INTEGER(IntKi), PARAMETER      :: PtfmStC1_Mxi = 452
   INTEGER(IntKi), PARAMETER      :: PtfmStC1_Myi = 453
   INTEGER(IntKi), PARAMETER      :: PtfmStC1_Mzi = 454
   INTEGER(IntKi), PARAMETER      :: PtfmStC1_Fxn = 455
   INTEGER(IntKi), PARAMETER      :: PtfmStC1_Fyn = 456
   INTEGER(IntKi), PARAMETER      :: PtfmStC1_Fzn = 457
   INTEGER(IntKi), PARAMETER      :: PtfmStC1_Mxn = 458
   INTEGER(IntKi), PARAMETER      :: PtfmStC1_Myn = 459
   INTEGER(IntKi), PARAMETER      :: PtfmStC1_Mzn = 460
   INTEGER(IntKi), PARAMETER      :: PtfmStC2_XQ  = 461
   INTEGER(IntKi), PARAMETER      :: PtfmStC2_XQD = 462
   INTEGER(IntKi), PARAMETER      :: PtfmStC2_YQ  = 463
   INTEGER(IntKi), PARAMETER      :: PtfmStC2_YQD = 464
   INTEGER(IntKi), PARAMETER      :: PtfmStC2_ZQ  = 465
   INTEGER(IntKi), PARAMETER      :: PtfmStC2_ZQD = 466
   INTEGER(IntKi), PARAMETER      :: PtfmStC2_Fxi = 467
   INTEGER(IntKi), PARAMETER      :: PtfmStC2_Fyi = 468
   INTEGER(IntKi), PARAMETER      :: PtfmStC2_Fzi = 469
   INTEGER(IntKi), PARAMETER      :: PtfmStC2_Mxi = 470
   INTEGER(IntKi), PARAMETER      :: PtfmStC2_Myi = 471
   INTEGER(IntKi), PARAMETER      :: PtfmStC2_Mzi = 472
   INTEGER(IntKi), PARAMETER      :: PtfmStC2_Fxn = 473
   INTEGER(IntKi), PARAMETER      :: PtfmStC2_Fyn = 474
   INTEGER(IntKi), PARAMETER      :: PtfmStC2_Fzn = 475
   INTEGER(IntKi), PARAMETER      :: PtfmStC2_Mxn = 476
   INTEGER(IntKi), PARAMETER      :: PtfmStC2_Myn = 477
   INTEGER(IntKi), PARAMETER      :: PtfmStC2_Mzn = 478
   INTEGER(IntKi), PARAMETER      :: PtfmStC3_XQ  = 479
   INTEGER(IntKi), PARAMETER      :: PtfmStC3_XQD = 480
   INTEGER(IntKi), PARAMETER      :: PtfmStC3_YQ  = 481
   INTEGER(IntKi), PARAMETER      :: PtfmStC3_YQD = 482
   INTEGER(IntKi), PARAMETER      :: PtfmStC3_ZQ  = 483
   INTEGER(IntKi), PARAMETER      :: PtfmStC3_ZQD = 484
   INTEGER(IntKi), PARAMETER      :: PtfmStC3_Fxi = 485
   INTEGER(IntKi), PARAMETER      :: PtfmStC3_Fyi = 486
   INTEGER(IntKi), PARAMETER      :: PtfmStC3_Fzi = 487
   INTEGER(IntKi), PARAMETER      :: PtfmStC3_Mxi = 488
   INTEGER(IntKi), PARAMETER      :: PtfmStC3_Myi = 489
   INTEGER(IntKi), PARAMETER      :: PtfmStC3_Mzi = 490
   INTEGER(IntKi), PARAMETER      :: PtfmStC3_Fxn = 491
   INTEGER(IntKi), PARAMETER      :: PtfmStC3_Fyn = 492
   INTEGER(IntKi), PARAMETER      :: PtfmStC3_Fzn = 493
   INTEGER(IntKi), PARAMETER      :: PtfmStC3_Mxn = 494
   INTEGER(IntKi), PARAMETER      :: PtfmStC3_Myn = 495
   INTEGER(IntKi), PARAMETER      :: PtfmStC3_Mzn = 496
   INTEGER(IntKi), PARAMETER      :: PtfmStC4_XQ  = 497
   INTEGER(IntKi), PARAMETER      :: PtfmStC4_XQD = 498
   INTEGER(IntKi), PARAMETER      :: PtfmStC4_YQ  = 499
   INTEGER(IntKi), PARAMETER      :: PtfmStC4_YQD = 500
   INTEGER(IntKi), PARAMETER      :: PtfmStC4_ZQ  = 501
   INTEGER(IntKi), PARAMETER      :: PtfmStC4_ZQD = 502
   INTEGER(IntKi), PARAMETER      :: PtfmStC4_Fxi = 503
   INTEGER(IntKi), PARAMETER      :: PtfmStC4_Fyi = 504
   INTEGER(IntKi), PARAMETER      :: PtfmStC4_Fzi = 505
   INTEGER(IntKi), PARAMETER      :: PtfmStC4_Mxi = 506
   INTEGER(IntKi), PARAMETER      :: PtfmStC4_Myi = 507
   INTEGER(IntKi), PARAMETER      :: PtfmStC4_Mzi = 508
   INTEGER(IntKi), PARAMETER      :: PtfmStC4_Fxn = 509
   INTEGER(IntKi), PARAMETER      :: PtfmStC4_Fyn = 510
   INTEGER(IntKi), PARAMETER      :: PtfmStC4_Fzn = 511
   INTEGER(IntKi), PARAMETER      :: PtfmStC4_Mxn = 512
   INTEGER(IntKi), PARAMETER      :: PtfmStC4_Myn = 513
   INTEGER(IntKi), PARAMETER      :: PtfmStC4_Mzn = 514


     ! The maximum number of output channels which can be output by the code.
   INTEGER(IntKi), PARAMETER      :: MaxOutPts    = 514

!End of code generated by Matlab script
! ===================================================================================================
   INTEGER(IntKi), PARAMETER      :: BlPitchC (3) = (/ BlPitchC1, BlPitchC2, BlPitchC3 /) 
   INTEGER(IntKi), PARAMETER      :: BlAirfoilC (3) = (/ BlAirFlC1, BlAirFlC2, BlAirFlC3 /)

   ! Structural Control outputs -- these arrays simplify the output a little.  The MaxBlOuts and MaxStC
   !                               must be set according to what is in the OutListParameters and auto
   !                               generated code above.
   INTEGER(IntKi), PARAMETER      :: MaxBlOuts = 4    ! maximum number of blades that we can output for
   INTEGER(IntKi), PARAMETER      :: MaxStC    = 4    ! maximum number of StC outputs of type
   ! StC nacelle outputs -- maximum of 4 for now.  Expand if more needed
   INTEGER(IntKi), PARAMETER      :: NStC_XQ(MaxStC)    = (/ NStC1_XQ,  NStC2_XQ,  NStC3_XQ,  NStC4_XQ  /)
   INTEGER(IntKi), PARAMETER      :: NStC_XQD(MaxStC)   = (/ NStC1_XQD, NStC2_XQD, NStC3_XQD, NStC4_XQD /)
   INTEGER(IntKi), PARAMETER      :: NStC_YQ(MaxStC)    = (/ NStC1_YQ,  NStC2_YQ,  NStC3_YQ,  NStC4_YQ  /)
   INTEGER(IntKi), PARAMETER      :: NStC_YQD(MaxStC)   = (/ NStC1_YQD, NStC2_YQD, NStC3_YQD, NStC4_YQD /)
   INTEGER(IntKi), PARAMETER      :: NStC_ZQ(MaxStC)    = (/ NStC1_ZQ,  NStC2_ZQ,  NStC3_ZQ,  NStC4_ZQ  /)
   INTEGER(IntKi), PARAMETER      :: NStC_ZQD(MaxStC)   = (/ NStC1_ZQD, NStC2_ZQD, NStC3_ZQD, NStC4_ZQD /)
   INTEGER(IntKi), PARAMETER      :: NStC_Fxi(MaxStC)   = (/ NStC1_Fxi, NStC2_Fxi, NStC3_Fxi, NStC4_Fxi /)
   INTEGER(IntKi), PARAMETER      :: NStC_Fyi(MaxStC)   = (/ NStC1_Fyi, NStC2_Fyi, NStC3_Fyi, NStC4_Fyi /)
   INTEGER(IntKi), PARAMETER      :: NStC_Fzi(MaxStC)   = (/ NStC1_Fzi, NStC2_Fzi, NStC3_Fzi, NStC4_Fzi /)
   INTEGER(IntKi), PARAMETER      :: NStC_Mxi(MaxStC)   = (/ NStC1_Mxi, NStC2_Mxi, NStC3_Mxi, NStC4_Mxi /)
   INTEGER(IntKi), PARAMETER      :: NStC_Myi(MaxStC)   = (/ NStC1_Myi, NStC2_Myi, NStC3_Myi, NStC4_Myi /)
   INTEGER(IntKi), PARAMETER      :: NStC_Mzi(MaxStC)   = (/ NStC1_Mzi, NStC2_Mzi, NStC3_Mzi, NStC4_Mzi /)
   INTEGER(IntKi), PARAMETER      :: NStC_Fxn(MaxStC)   = (/ NStC1_Fxn, NStC2_Fxn, NStC3_Fxn, NStC4_Fxn /)
   INTEGER(IntKi), PARAMETER      :: NStC_Fyn(MaxStC)   = (/ NStC1_Fyn, NStC2_Fyn, NStC3_Fyn, NStC4_Fyn /)
   INTEGER(IntKi), PARAMETER      :: NStC_Fzn(MaxStC)   = (/ NStC1_Fzn, NStC2_Fzn, NStC3_Fzn, NStC4_Fzn /)
   INTEGER(IntKi), PARAMETER      :: NStC_Mxn(MaxStC)   = (/ NStC1_Mxn, NStC2_Mxn, NStC3_Mxn, NStC4_Mxn /)
   INTEGER(IntKi), PARAMETER      :: NStC_Myn(MaxStC)   = (/ NStC1_Myn, NStC2_Myn, NStC3_Myn, NStC4_Myn /)
   INTEGER(IntKi), PARAMETER      :: NStC_Mzn(MaxStC)   = (/ NStC1_Mzn, NStC2_Mzn, NStC3_Mzn, NStC4_Mzn /)
   ! StC tower outputs -- maximum of 4 for now.  Expand if more needed
   INTEGER(IntKi), PARAMETER      :: TStC_XQ(MaxStC)    = (/ TStC1_XQ,  TStC2_XQ,  TStC3_XQ,  TStC4_XQ  /)
   INTEGER(IntKi), PARAMETER      :: TStC_XQD(MaxStC)   = (/ TStC1_XQD, TStC2_XQD, TStC3_XQD, TStC4_XQD /)
   INTEGER(IntKi), PARAMETER      :: TStC_YQ(MaxStC)    = (/ TStC1_YQ,  TStC2_YQ,  TStC3_YQ,  TStC4_YQ  /)
   INTEGER(IntKi), PARAMETER      :: TStC_YQD(MaxStC)   = (/ TStC1_YQD, TStC2_YQD, TStC3_YQD, TStC4_YQD /)
   INTEGER(IntKi), PARAMETER      :: TStC_ZQ(MaxStC)    = (/ TStC1_ZQ,  TStC2_ZQ,  TStC3_ZQ,  TStC4_ZQ  /)
   INTEGER(IntKi), PARAMETER      :: TStC_ZQD(MaxStC)   = (/ TStC1_ZQD, TStC2_ZQD, TStC3_ZQD, TStC4_ZQD /)
   INTEGER(IntKi), PARAMETER      :: TStC_Fxi(MaxStC)   = (/ TStC1_Fxi, TStC2_Fxi, TStC3_Fxi, TStC4_Fxi /)
   INTEGER(IntKi), PARAMETER      :: TStC_Fyi(MaxStC)   = (/ TStC1_Fyi, TStC2_Fyi, TStC3_Fyi, TStC4_Fyi /)
   INTEGER(IntKi), PARAMETER      :: TStC_Fzi(MaxStC)   = (/ TStC1_Fzi, TStC2_Fzi, TStC3_Fzi, TStC4_Fzi /)
   INTEGER(IntKi), PARAMETER      :: TStC_Mxi(MaxStC)   = (/ TStC1_Mxi, TStC2_Mxi, TStC3_Mxi, TStC4_Mxi /)
   INTEGER(IntKi), PARAMETER      :: TStC_Myi(MaxStC)   = (/ TStC1_Myi, TStC2_Myi, TStC3_Myi, TStC4_Myi /)
   INTEGER(IntKi), PARAMETER      :: TStC_Mzi(MaxStC)   = (/ TStC1_Mzi, TStC2_Mzi, TStC3_Mzi, TStC4_Mzi /)
   INTEGER(IntKi), PARAMETER      :: TStC_Fxn(MaxStC)   = (/ TStC1_Fxn, TStC2_Fxn, TStC3_Fxn, TStC4_Fxn /)
   INTEGER(IntKi), PARAMETER      :: TStC_Fyn(MaxStC)   = (/ TStC1_Fyn, TStC2_Fyn, TStC3_Fyn, TStC4_Fyn /)
   INTEGER(IntKi), PARAMETER      :: TStC_Fzn(MaxStC)   = (/ TStC1_Fzn, TStC2_Fzn, TStC3_Fzn, TStC4_Fzn /)
   INTEGER(IntKi), PARAMETER      :: TStC_Mxn(MaxStC)   = (/ TStC1_Mxn, TStC2_Mxn, TStC3_Mxn, TStC4_Mxn /)
   INTEGER(IntKi), PARAMETER      :: TStC_Myn(MaxStC)   = (/ TStC1_Myn, TStC2_Myn, TStC3_Myn, TStC4_Myn /)
   INTEGER(IntKi), PARAMETER      :: TStC_Mzn(MaxStC)   = (/ TStC1_Mzn, TStC2_Mzn, TStC3_Mzn, TStC4_Mzn /)
   ! StC blade outputs -- maximum of 4 for now.  Expand if more needed
   INTEGER(IntKi), PARAMETER      :: BStC_XQ(MaxStC,MaxBlOuts) = reshape((/ &
                                         BStC1_B1_XQ,  BStC2_B1_XQ,  BStC3_B1_XQ,  BStC4_B1_XQ,  &
                                         BStC1_B2_XQ,  BStC2_B2_XQ,  BStC3_B2_XQ,  BStC4_B2_XQ,  &
                                         BStC1_B3_XQ,  BStC2_B3_XQ,  BStC3_B3_XQ,  BStC4_B3_XQ,  &
                                         BStC1_B4_XQ,  BStC2_B4_XQ,  BStC3_B4_XQ,  BStC4_B4_XQ   /),(/4,MaxBlOuts/))
   INTEGER(IntKi), PARAMETER      :: BStC_XQD(MaxStC,MaxBlOuts)= reshape((/ &
                                         BStC1_B1_XQD, BStC2_B1_XQD, BStC3_B1_XQD, BStC4_B1_XQD, &
                                         BStC1_B2_XQD, BStC2_B2_XQD, BStC3_B2_XQD, BStC4_B2_XQD, &
                                         BStC1_B3_XQD, BStC2_B3_XQD, BStC3_B3_XQD, BStC4_B3_XQD, &
                                         BStC1_B4_XQD, BStC2_B4_XQD, BStC3_B4_XQD, BStC4_B4_XQD  /),(/4,MaxBlOuts/))
   INTEGER(IntKi), PARAMETER      :: BStC_YQ(MaxStC,MaxBlOuts) = reshape((/ &
                                         BStC1_B1_YQ,  BStC2_B1_YQ,  BStC3_B1_YQ,  BStC4_B1_YQ,  &
                                         BStC1_B2_YQ,  BStC2_B2_YQ,  BStC3_B2_YQ,  BStC4_B2_YQ,  &
                                         BStC1_B3_YQ,  BStC2_B3_YQ,  BStC3_B3_YQ,  BStC4_B3_YQ,  &
                                         BStC1_B4_YQ,  BStC2_B4_YQ,  BStC3_B4_YQ,  BStC4_B4_YQ   /),(/4,MaxBlOuts/))
   INTEGER(IntKi), PARAMETER      :: BStC_YQD(MaxStC,MaxBlOuts)= reshape((/ &
                                         BStC1_B1_YQD, BStC2_B1_YQD, BStC3_B1_YQD, BStC4_B1_YQD, &
                                         BStC1_B2_YQD, BStC2_B2_YQD, BStC3_B2_YQD, BStC4_B2_YQD, &
                                         BStC1_B3_YQD, BStC2_B3_YQD, BStC3_B3_YQD, BStC4_B3_YQD, &
                                         BStC1_B4_YQD, BStC2_B4_YQD, BStC3_B4_YQD, BStC4_B4_YQD  /),(/4,MaxBlOuts/))
   INTEGER(IntKi), PARAMETER      :: BStC_ZQ(MaxStC,MaxBlOuts) = reshape((/ &
                                         BStC1_B1_ZQ,  BStC2_B1_ZQ,  BStC3_B1_ZQ,  BStC4_B1_ZQ,  &
                                         BStC1_B2_ZQ,  BStC2_B2_ZQ,  BStC3_B2_ZQ,  BStC4_B2_ZQ,  &
                                         BStC1_B3_ZQ,  BStC2_B3_ZQ,  BStC3_B3_ZQ,  BStC4_B3_ZQ,  &
                                         BStC1_B4_ZQ,  BStC2_B4_ZQ,  BStC3_B4_ZQ,  BStC4_B4_ZQ   /),(/4,MaxBlOuts/))
   INTEGER(IntKi), PARAMETER      :: BStC_ZQD(MaxStC,MaxBlOuts)= reshape((/ &
                                         BStC1_B1_ZQD, BStC2_B1_ZQD, BStC3_B1_ZQD, BStC4_B1_ZQD, &
                                         BStC1_B2_ZQD, BStC2_B2_ZQD, BStC3_B2_ZQD, BStC4_B2_ZQD, &
                                         BStC1_B3_ZQD, BStC2_B3_ZQD, BStC3_B3_ZQD, BStC4_B3_ZQD, &
                                         BStC1_B4_ZQD, BStC2_B4_ZQD, BStC3_B4_ZQD, BStC4_B4_ZQD  /),(/4,MaxBlOuts/))
   INTEGER(IntKi), PARAMETER      :: BStC_Fxi(MaxStC,MaxBlOuts)= reshape((/ &
                                         BStC1_B1_Fxi, BStC2_B1_Fxi, BStC3_B1_Fxi, BStC4_B1_Fxi, &
                                         BStC1_B2_Fxi, BStC2_B2_Fxi, BStC3_B2_Fxi, BStC4_B2_Fxi, &
                                         BStC1_B3_Fxi, BStC2_B3_Fxi, BStC3_B3_Fxi, BStC4_B3_Fxi, &
                                         BStC1_B4_Fxi, BStC2_B4_Fxi, BStC3_B4_Fxi, BStC4_B4_Fxi  /),(/4,MaxBlOuts/))
   INTEGER(IntKi), PARAMETER      :: BStC_Fyi(MaxStC,MaxBlOuts)= reshape((/ &
                                         BStC1_B1_Fyi, BStC2_B1_Fyi, BStC3_B1_Fyi, BStC4_B1_Fyi, &
                                         BStC1_B2_Fyi, BStC2_B2_Fyi, BStC3_B2_Fyi, BStC4_B2_Fyi, &
                                         BStC1_B3_Fyi, BStC2_B3_Fyi, BStC3_B3_Fyi, BStC4_B3_Fyi, &
                                         BStC1_B4_Fyi, BStC2_B4_Fyi, BStC3_B4_Fyi, BStC4_B4_Fyi  /),(/4,MaxBlOuts/))
   INTEGER(IntKi), PARAMETER      :: BStC_Fzi(MaxStC,MaxBlOuts)= reshape((/ &
                                         BStC1_B1_Fzi, BStC2_B1_Fzi, BStC3_B1_Fzi, BStC4_B1_Fzi, &
                                         BStC1_B2_Fzi, BStC2_B2_Fzi, BStC3_B2_Fzi, BStC4_B2_Fzi, &
                                         BStC1_B3_Fzi, BStC2_B3_Fzi, BStC3_B3_Fzi, BStC4_B3_Fzi, &
                                         BStC1_B4_Fzi, BStC2_B4_Fzi, BStC3_B4_Fzi, BStC4_B4_Fzi  /),(/4,MaxBlOuts/))
   INTEGER(IntKi), PARAMETER      :: BStC_Mxi(MaxStC,MaxBlOuts)= reshape((/ &
                                         BStC1_B1_Mxi, BStC2_B1_Mxi, BStC3_B1_Mxi, BStC4_B1_Mxi, &
                                         BStC1_B2_Mxi, BStC2_B2_Mxi, BStC3_B2_Mxi, BStC4_B2_Mxi, &
                                         BStC1_B3_Mxi, BStC2_B3_Mxi, BStC3_B3_Mxi, BStC4_B3_Mxi, &
                                         BStC1_B4_Mxi, BStC2_B4_Mxi, BStC3_B4_Mxi, BStC4_B4_Mxi  /),(/4,MaxBlOuts/))
   INTEGER(IntKi), PARAMETER      :: BStC_Myi(MaxStC,MaxBlOuts)= reshape((/ &
                                         BStC1_B1_Myi, BStC2_B1_Myi, BStC3_B1_Myi, BStC4_B1_Myi, &
                                         BStC1_B2_Myi, BStC2_B2_Myi, BStC3_B2_Myi, BStC4_B2_Myi, &
                                         BStC1_B3_Myi, BStC2_B3_Myi, BStC3_B3_Myi, BStC4_B3_Myi, &
                                         BStC1_B4_Myi, BStC2_B4_Myi, BStC3_B4_Myi, BStC4_B4_Myi  /),(/4,MaxBlOuts/))
   INTEGER(IntKi), PARAMETER      :: BStC_Mzi(MaxStC,MaxBlOuts)= reshape((/ &
                                         BStC1_B1_Mzi, BStC2_B1_Mzi, BStC3_B1_Mzi, BStC4_B1_Mzi, &
                                         BStC1_B2_Mzi, BStC2_B2_Mzi, BStC3_B2_Mzi, BStC4_B2_Mzi, &
                                         BStC1_B3_Mzi, BStC2_B3_Mzi, BStC3_B3_Mzi, BStC4_B3_Mzi, &
                                         BStC1_B4_Mzi, BStC2_B4_Mzi, BStC3_B4_Mzi, BStC4_B4_Mzi  /),(/4,MaxBlOuts/))
   INTEGER(IntKi), PARAMETER      :: BStC_Fxn(MaxStC,MaxBlOuts)= reshape((/ &
                                         BStC1_B1_Fxn, BStC2_B1_Fxn, BStC3_B1_Fxn, BStC4_B1_Fxn, &
                                         BStC1_B2_Fxn, BStC2_B2_Fxn, BStC3_B2_Fxn, BStC4_B2_Fxn, &
                                         BStC1_B3_Fxn, BStC2_B3_Fxn, BStC3_B3_Fxn, BStC4_B3_Fxn, &
                                         BStC1_B4_Fxn, BStC2_B4_Fxn, BStC3_B4_Fxn, BStC4_B4_Fxn  /),(/4,MaxBlOuts/))
   INTEGER(IntKi), PARAMETER      :: BStC_Fyn(MaxStC,MaxBlOuts)= reshape((/ &
                                         BStC1_B1_Fyn, BStC2_B1_Fyn, BStC3_B1_Fyn, BStC4_B1_Fyn, &
                                         BStC1_B2_Fyn, BStC2_B2_Fyn, BStC3_B2_Fyn, BStC4_B2_Fyn, &
                                         BStC1_B3_Fyn, BStC2_B3_Fyn, BStC3_B3_Fyn, BStC4_B3_Fyn, &
                                         BStC1_B1_Fyn, BStC2_B1_Fyn, BStC3_B1_Fyn, BStC4_B1_Fyn  /),(/4,MaxBlOuts/))
   INTEGER(IntKi), PARAMETER      :: BStC_Fzn(MaxStC,MaxBlOuts)= reshape((/ &
                                         BStC1_B1_Fzn, BStC2_B1_Fzn, BStC3_B1_Fzn, BStC4_B1_Fzn, &
                                                                   BStC1_B2_Fzn, BStC2_B2_Fzn, BStC3_B2_Fzn, BStC4_B2_Fzn, &
                                                                   BStC1_B3_Fzn, BStC2_B3_Fzn, BStC3_B3_Fzn, BStC4_B3_Fzn, &
                                                                   BStC1_B4_Fzn, BStC2_B4_Fzn, BStC3_B4_Fzn, BStC4_B4_Fzn  /),(/4,MaxBlOuts/))
   INTEGER(IntKi), PARAMETER      :: BStC_Mxn(MaxStC,MaxBlOuts)= reshape((/ &
                                         BStC1_B1_Mxn, BStC2_B1_Mxn, BStC3_B1_Mxn, BStC4_B1_Mxn, &
                                                                   BStC1_B2_Mxn, BStC2_B2_Mxn, BStC3_B2_Mxn, BStC4_B2_Mxn, &
                                                                   BStC1_B3_Mxn, BStC2_B3_Mxn, BStC3_B3_Mxn, BStC4_B3_Mxn, &
                                                                   BStC1_B4_Mxn, BStC2_B4_Mxn, BStC3_B4_Mxn, BStC4_B4_Mxn  /),(/4,MaxBlOuts/))
   INTEGER(IntKi), PARAMETER      :: BStC_Myn(MaxStC,MaxBlOuts)= reshape((/ &
                                         BStC1_B1_Myn, BStC2_B1_Myn, BStC3_B1_Myn, BStC4_B1_Myn, &
                                                                   BStC1_B2_Myn, BStC2_B2_Myn, BStC3_B2_Myn, BStC4_B2_Myn, &
                                                                   BStC1_B3_Myn, BStC2_B3_Myn, BStC3_B3_Myn, BStC4_B3_Myn, &
                                                                   BStC1_B4_Myn, BStC2_B4_Myn, BStC3_B4_Myn, BStC4_B4_Myn  /),(/4,MaxBlOuts/))
   INTEGER(IntKi), PARAMETER      :: BStC_Mzn(MaxStC,MaxBlOuts)= reshape((/ &
                                         BStC1_B1_Mzn, BStC2_B1_Mzn, BStC3_B1_Mzn, BStC4_B1_Mzn, &
                                         BStC1_B2_Mzn, BStC2_B2_Mzn, BStC3_B2_Mzn, BStC4_B2_Mzn, &
                                         BStC1_B3_Mzn, BStC2_B3_Mzn, BStC3_B3_Mzn, BStC4_B3_Mzn, &
                                         BStC1_B4_Mzn, BStC2_B4_Mzn, BStC3_B4_Mzn, BStC4_B4_Mzn  /),(/4,MaxBlOuts/))
   ! StC Platform outputs -- maximum of 4 for now.  Expand if more needed
   INTEGER(IntKi), PARAMETER      :: PtfmStC_XQ(MaxStC)    = (/ PtfmStC1_XQ,  PtfmStC2_XQ,  PtfmStC3_XQ,  PtfmStC4_XQ  /)
   INTEGER(IntKi), PARAMETER      :: PtfmStC_XQD(MaxStC)   = (/ PtfmStC1_XQD, PtfmStC2_XQD, PtfmStC3_XQD, PtfmStC4_XQD /)
   INTEGER(IntKi), PARAMETER      :: PtfmStC_YQ(MaxStC)    = (/ PtfmStC1_YQ,  PtfmStC2_YQ,  PtfmStC3_YQ,  PtfmStC4_YQ  /)
   INTEGER(IntKi), PARAMETER      :: PtfmStC_YQD(MaxStC)   = (/ PtfmStC1_YQD, PtfmStC2_YQD, PtfmStC3_YQD, PtfmStC4_YQD /)
   INTEGER(IntKi), PARAMETER      :: PtfmStC_ZQ(MaxStC)    = (/ PtfmStC1_ZQ,  PtfmStC2_ZQ,  PtfmStC3_ZQ,  PtfmStC4_ZQ  /)
   INTEGER(IntKi), PARAMETER      :: PtfmStC_ZQD(MaxStC)   = (/ PtfmStC1_ZQD, PtfmStC2_ZQD, PtfmStC3_ZQD, PtfmStC4_ZQD /)
   INTEGER(IntKi), PARAMETER      :: PtfmStC_Fxi(MaxStC)   = (/ PtfmStC1_Fxi, PtfmStC2_Fxi, PtfmStC3_Fxi, PtfmStC4_Fxi /)
   INTEGER(IntKi), PARAMETER      :: PtfmStC_Fyi(MaxStC)   = (/ PtfmStC1_Fyi, PtfmStC2_Fyi, PtfmStC3_Fyi, PtfmStC4_Fyi /)
   INTEGER(IntKi), PARAMETER      :: PtfmStC_Fzi(MaxStC)   = (/ PtfmStC1_Fzi, PtfmStC2_Fzi, PtfmStC3_Fzi, PtfmStC4_Fzi /)
   INTEGER(IntKi), PARAMETER      :: PtfmStC_Mxi(MaxStC)   = (/ PtfmStC1_Mxi, PtfmStC2_Mxi, PtfmStC3_Mxi, PtfmStC4_Mxi /)
   INTEGER(IntKi), PARAMETER      :: PtfmStC_Myi(MaxStC)   = (/ PtfmStC1_Myi, PtfmStC2_Myi, PtfmStC3_Myi, PtfmStC4_Myi /)
   INTEGER(IntKi), PARAMETER      :: PtfmStC_Mzi(MaxStC)   = (/ PtfmStC1_Mzi, PtfmStC2_Mzi, PtfmStC3_Mzi, PtfmStC4_Mzi /)
   INTEGER(IntKi), PARAMETER      :: PtfmStC_Fxn(MaxStC)   = (/ PtfmStC1_Fxn, PtfmStC2_Fxn, PtfmStC3_Fxn, PtfmStC4_Fxn /)
   INTEGER(IntKi), PARAMETER      :: PtfmStC_Fyn(MaxStC)   = (/ PtfmStC1_Fyn, PtfmStC2_Fyn, PtfmStC3_Fyn, PtfmStC4_Fyn /)
   INTEGER(IntKi), PARAMETER      :: PtfmStC_Fzn(MaxStC)   = (/ PtfmStC1_Fzn, PtfmStC2_Fzn, PtfmStC3_Fzn, PtfmStC4_Fzn /)
   INTEGER(IntKi), PARAMETER      :: PtfmStC_Mxn(MaxStC)   = (/ PtfmStC1_Mxn, PtfmStC2_Mxn, PtfmStC3_Mxn, PtfmStC4_Mxn /)
   INTEGER(IntKi), PARAMETER      :: PtfmStC_Myn(MaxStC)   = (/ PtfmStC1_Myn, PtfmStC2_Myn, PtfmStC3_Myn, PtfmStC4_Myn /)
   INTEGER(IntKi), PARAMETER      :: PtfmStC_Mzn(MaxStC)   = (/ PtfmStC1_Mzn, PtfmStC2_Mzn, PtfmStC3_Mzn, PtfmStC4_Mzn /)

!bjj: added parameters here (after the "(/ /)" above) so VS2010 doesn't get so confused with the previous statement.

      ! Parameters for type of control
      
   INTEGER(IntKi), PARAMETER :: ControlMode_NONE      = 0          !< The (ServoDyn-universal) control code for not using a particular type of control
   INTEGER(IntKi), PARAMETER :: ControlMode_SIMPLE    = 1          !< The (ServoDyn-universal) control code for obtaining the control values from a simple built-in controller
   INTEGER(IntKi), PARAMETER :: ControlMode_ADVANCED  = 2          !< The (ServoDyn-universal) control code for not using the control values from an advanced built-in controller (or just a different simple model?)
   INTEGER(IntKi), PARAMETER :: ControlMode_USER      = 3          !< The (ServoDyn-universal) control code for obtaining the control values from a user-defined routine
   INTEGER(IntKi), PARAMETER :: ControlMode_EXTERN    = 4          !< The (ServoDyn-universal) control code for obtaining the control values from Simulink or Labivew
   INTEGER(IntKi), PARAMETER :: ControlMode_DLL       = 5          !< The (ServoDyn-universal) control code for obtaining the control values from a Bladed-Style dynamic-link library
   
   INTEGER(IntKi), PARAMETER, PUBLIC :: TrimCase_none   = 0
   INTEGER(IntKi), PARAMETER, PUBLIC :: TrimCase_yaw    = 1
   INTEGER(IntKi), PARAMETER, PUBLIC :: TrimCase_torque = 2
   INTEGER(IntKi), PARAMETER, PUBLIC :: TrimCase_pitch  = 3
   
      ! ..... Public Subroutines ...................................................................................................

   PUBLIC :: SrvD_Init                           ! Initialization routine
   PUBLIC :: SrvD_End                            ! Ending routine (includes clean up)

   PUBLIC :: SrvD_UpdateStates                   ! Loose coupling routine for solving for constraint states, integrating
                                                 !   continuous states, and updating discrete states
   PUBLIC :: SrvD_CalcOutput                     ! Routine for computing outputs

   PUBLIC :: SrvD_CalcConstrStateResidual        ! Tight coupling routine for returning the constraint state residual
   PUBLIC :: SrvD_CalcContStateDeriv             ! Tight coupling routine for computing derivatives of continuous states
   PUBLIC :: SrvD_UpdateDiscState                ! Tight coupling routine for updating discrete states

   PUBLIC :: SrvD_JacobianPInput                 ! Routine to compute the Jacobians of the output (Y), continuous- (X), discrete-
                                                 !   (Xd), and constraint-state (Z) equations all with respect to the inputs (u)
   PUBLIC :: SrvD_JacobianPContState             ! Routine to compute the Jacobians of the output (Y), continuous- (X), discrete-
                                                 !   (Xd), and constraint-state (Z) equations all with respect to the continuous
                                                 !   states (x)
   PUBLIC :: SrvD_JacobianPDiscState             ! Routine to compute the Jacobians of the output (Y), continuous- (X), discrete-
                                                 !   (Xd), and constraint-state (Z) equations all with respect to the discrete
                                                 !   states (xd)
   PUBLIC :: SrvD_JacobianPConstrState           ! Routine to compute the Jacobians of the output (Y), continuous- (X), discrete-
                                                 !   (Xd), and constraint-state (Z) equations all with respect to the constraint
                                                 !   states (z)
   PUBLIC :: SrvD_GetOP                          ! Routine to pack the operating point values (for linearization) into arrays
   
   
CONTAINS
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine is called at the start of the simulation to perform initialization steps.
!! The parameters are set here and not changed during the simulation.
!! The initial states and initial guess for the input are defined.
SUBROUTINE SrvD_Init( InitInp, u, p, x, xd, z, OtherState, y, m, Interval, InitOut, ErrStat, ErrMsg )
!..................................................................................................................................

   TYPE(SrvD_InitInputType),       INTENT(IN   )  :: InitInp     !< Input data for initialization routine
   TYPE(SrvD_InputType),           INTENT(  OUT)  :: u           !< An initial guess for the input; input mesh must be defined
   TYPE(SrvD_ParameterType),       INTENT(  OUT)  :: p           !< Parameters
   TYPE(SrvD_ContinuousStateType), INTENT(  OUT)  :: x           !< Initial continuous states
   TYPE(SrvD_DiscreteStateType),   INTENT(  OUT)  :: xd          !< Initial discrete states
   TYPE(SrvD_ConstraintStateType), INTENT(  OUT)  :: z           !< Initial guess of the constraint states
   TYPE(SrvD_OtherStateType),      INTENT(  OUT)  :: OtherState  !< Initial other states
   TYPE(SrvD_OutputType),          INTENT(  OUT)  :: y           !< Initial system outputs (outputs are not calculated;
                                                                 !!   only the output mesh is initialized)
   TYPE(SrvD_MiscVarType),         INTENT(  OUT)  :: m           !< Initial misc (optimization) variables
   REAL(DbKi),                     INTENT(INOUT)  :: Interval    !< Coupling interval in seconds: the rate that
                                                                 !!   (1) SrvD_UpdateStates() is called in loose coupling &
                                                                 !!   (2) SrvD_UpdateDiscState() is called in tight coupling.
                                                                 !!   Input is the suggested time from the glue code;
                                                                 !!   Output is the actual coupling interval that will be used
                                                                 !!   by the glue code.
   TYPE(SrvD_InitOutputType),      INTENT(  OUT)  :: InitOut     !< Output for initialization routine
   INTEGER(IntKi),                 INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                   INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None

      ! local variables

   character(1024)                                :: PriPath        ! Path name of the primary file
   type(FileInfoType)                             :: FileInfo_In    !< The derived type for holding the full input file for parsing -- we may pass this in the future
   TYPE(SrvD_InputFile)                           :: InputFileData  ! Data stored in the module's input file
   TYPE(StC_InitInputType)                        :: StC_InitInp    ! data to initialize StC module
   TYPE(StC_InitOutputType)                       :: StC_InitOut    ! data from StC module initialization (not used)
   INTEGER(IntKi)                                 :: i              ! loop counter
   INTEGER(IntKi)                                 :: j              ! loop counter
   INTEGER(IntKi)                                 :: K              ! loop counter
   INTEGER(IntKi)                                 :: ErrStat2       ! temporary Error status of the operation
   CHARACTER(ErrMsgLen)                           :: ErrMsg2        ! temporary Error message if ErrStat /= ErrID_None
   
   character(*), parameter                        :: RoutineName = 'SrvD_Init'


      ! Initialize variables

   ErrStat = ErrID_None
   ErrMsg  = ""

      
      ! Initialize the NWTC Subroutine Library

   CALL NWTC_Init( EchoLibVer=.FALSE. )

      ! Display the module information

   CALL DispNVD( SrvD_Ver )
   CALL GetPath( InitInp%InputFile, PriPath )     ! Input files will be relative to the path where the primary input file is located.

      !............................................................................................      
      ! Read the input file and validate the data
      ! (note p%NumBl and p%RootName must be set first!) 
      !............................................................................................      
   p%RootName = InitInp%Rootname ! FAST adds the '.SrvD' before calling this module
   p%NumBl    = InitInp%NumBl         
      
   if (InitInp%UseInputFile) then
      ! Read the entire input file, minus any comment lines, into the FileInfo_In
      ! data structure in memory for further processing.
      call ProcessComFile( InitInp%InputFile, FileInfo_In, ErrStat2, ErrMsg2 )
   else
         ! put passed string info into the FileInfo_In -- FileInfo structure
      call NWTC_Library_CopyFileInfoType( InitInp%PassedPrimaryInputData, FileInfo_In, MESH_NEWCOPY, ErrStat2, ErrMsg2 )
   endif
   if (Failed())  return;
  
   ! For diagnostic purposes, the following can be used to display the contents
   ! of the FileInfo_In data structure.
   ! call Print_FileInfo_Struct( CU, FileInfo_In ) ! CU is the screen -- different number on different systems.

     !  Parse the FileInfo_In structure of data from the inputfile into the InitInp%InputFile structure
   CALL ParseInputFileInfo( PriPath, InitInp%InputFile, TRIM(InitInp%RootName), FileInfo_In, InputFileData, Interval, ErrStat2, ErrMsg2 )
      if (Failed())  return;

   CALL ValidatePrimaryData( InitInp, InputFileData, ErrStat2, ErrMsg2 )
      if (Failed())  return;
      
   if ( (InitInp%NumCtrl2SC  > 0 .and. InitInp%NumCtrl2SC <= 0) .or. &
        (InitInp%NumSC2Ctrl <= 0 .and. InitInp%NumSC2Ctrl  > 0) ) then      
      call SetErrStat( ErrID_Fatal, "If supercontroller is used, there must be at least one supercontroller input and one supercontroller output.",ErrStat,ErrMsg,RoutineName)
      call Cleanup()
      return
   end if
        
      !............................................................................................
      ! Define parameters here:
      !............................................................................................
   CALL SrvD_SetParameters( InputFileData, p, ErrStat2, ErrMsg2 )
      if (Failed())  return;

      ! Set and verify BlPitchInit, which comes from InitInputData (not the inputfiledata)
   CALL AllocAry( p%BlPitchInit, p%NumBl, 'BlPitchInit', ErrStat2, ErrMsg2 )
      if (Failed())  return;
   p%BlPitchInit = InitInp%BlPitchInit

   IF ( ANY( p%BlPitchInit <= -pi ) .OR. ANY( p%BlPitchInit > pi ) )  THEN
      call SetErrStat( ErrID_Fatal, 'BlPitchInit must be in the range (-pi,pi] radians (i.e., (-180,180] degrees).',ErrStat,ErrMsg,RoutineName)
      call Cleanup()
   END IF     
   
      !............................................................................................
      ! Define initial system states here:
      !............................................................................................

   x%DummyContState           = 0.0_ReKi   
   z%DummyConstrState         = 0.0_ReKi
   
   CALL AllocAry( m%xd_BlPitchFilter,  p%NumBl, 'BlPitchFilter',  ErrStat2, ErrMsg2 )
      if (Failed())  return;
   m%xd_BlPitchFilter = p%BlPitchInit
   
      !.......................
      ! Other states for pitch maneuver
      !.......................
   CALL AllocAry( OtherState%BegPitMan, p%NumBl, 'BegPitMan', ErrStat2, ErrMsg2 )
      if (Failed())  return;
   OtherState%BegPitMan = .false.  ! Pitch maneuvers didn't actually start, yet   
   
   CALL AllocAry( OtherState%BlPitchI,  p%NumBl, 'BlPitchI',  ErrStat2, ErrMsg2 )
      if (Failed())  return;
   OtherState%BlPitchI = 0.0_ReKi
   
   CALL AllocAry( OtherState%TPitManE,  p%NumBl, 'TPitManE',  ErrStat2, ErrMsg2 )
      if (Failed())  return;
   OtherState%TPitManE = 0.0_DbKi

      !.......................
      ! Other states for yaw maneuver
      !.......................   
   OtherState%BegYawMan = .false.                              ! Yaw maneuver didn't actually start, yet   
   OtherState%NacYawI   = 0.0_ReKi
   OtherState%TYawManE  = 0.0_ReKi
   
      !.......................
      ! other states for torque control:
      !.......................      
   OtherState%Off4Good  = .false.                              ! generator is not off for good
      ! is the generator online at initialization?
   IF ( p%GenTiStr .and. p%TimGenOn <= 0.0_ReKi )  THEN   ! Start-up of generator determined by time, TimGenOn
      OtherState%GenOnLine = .true.
   ELSE
      OtherState%GenOnLine = .false.                                    
   END IF
         
      
      !............................................................................................
      ! Define initial guess for the system inputs here:
      !............................................................................................

   CALL AllocAry( u%BlPitch, p%NumBl, 'BlPitch', ErrStat2, ErrMsg2 )
      if (Failed())  return;

   CALL AllocAry( u%ExternalBlPitchCom, p%NumBl, 'ExternalBlPitchCom', ErrStat2, ErrMsg2 )
      if (Failed())  return;
        
   IF (InitInp%NumSC2Ctrl > 0 .and. p%UseBladedInterface) THEN
      CALL AllocAry( u%SuperController, InitInp%NumSC2Ctrl, 'u%SuperController', ErrStat2, ErrMsg2 )
      if (Failed())  return;
      u%SuperController = 0.0_SiKi
   END IF
                  
      
   u%BlPitch = p%BlPitchInit
   
   u%Yaw = p%YawNeut
   u%YawRate   = 0.0
   
   u%LSS_Spd   = 0.0
   u%HSS_Spd   = 0.0
   u%RotSpeed  = 0.0
   
   u%ExternalYawPosCom = p%YawNeut
   u%ExternalYawRateCom = 0.
   u%ExternalBlPitchCom = p%BlPitchInit
   u%ExternalGenTrq = 0.
   u%ExternalElecPwr = 0.
   u%ExternalHSSBrFrac = 0.
   
   u%TwrAccel  = 0.
   u%YawErr    = 0.   
   u%WindDir   = 0.
   
      !Inputs for the Bladed Interface:
   u%RootMyc   = 0.
   u%YawBrTAxp = 0.
   u%YawBrTAyp = 0.
   u%LSSTipPxa = 0.
   u%RootMxc   = 0.
   u%LSSTipMxa = 0.
   u%LSSTipMya = 0.
   u%LSSTipMza = 0.
   u%LSSTipMys = 0.
   u%LSSTipMzs = 0.
   u%YawBrMyn  = 0.
   u%YawBrMzn  = 0.   
   u%NcIMURAxs = 0.
   u%NcIMURAys = 0.
   u%NcIMURAzs = 0.
   u%RotPwr = 0.
   u%HorWindV = 0.
   u%YawAngle = 0.
   m%dll_data%ElecPwr_prev = 0.
   m%dll_data%GenTrq_prev = 0.

      !............................................................................................
      ! Define system output initializations (set up mesh) here:
      !............................................................................................
   CALL AllocAry( y%BlPitchCom, p%NumBl, 'BlPitchCom', ErrStat2, ErrMsg2 )
      if (Failed())  return;

      ! Commanded Airfoil UserProp for blade.  Must be same units as given in AD15 airfoil tables
      !  This is passed to AD15 to be interpolated with the airfoil table userprop column
   CALL AllocAry( y%BlAirfoilCom, p%NumBl, 'BlAirfoilCom', ErrStat2, ErrMsg2 )
      if (Failed())  return;
   y%BlAirfoilCom = 0.0_ReKi

      ! tip brakes - this may be added back, later, so we'll keep these here for now
   CALL AllocAry( y%TBDrCon, p%NumBl, 'TBDrCon', ErrStat2, ErrMsg2 )
      if (Failed())  return;

   
   IF (InitInp%NumCtrl2SC > 0 .and. p%UseBladedInterface) THEN
      CALL AllocAry( y%SuperController, InitInp%NumCtrl2SC, 'y%SuperController', ErrStat2, ErrMsg2 )
      if (Failed())  return;
      y%SuperController = 0.0_SiKi
   END IF
      
      
      !............................................................................................
      ! tip brakes - this may be added back, later, so we'll keep these here for now
      !............................................................................................      
   CALL AllocAry( OtherState%BegTpBr,  p%NumBl, 'BegTpBr', ErrStat2, ErrMsg2 )
      if (Failed())  return;
   OtherState%BegTpBr = .FALSE.
    
   CALL AllocAry( OtherState%TTpBrDp,  p%NumBl, 'TTpBrDp', ErrStat2, ErrMsg2 )
      if (Failed())  return;
   OtherState%TTpBrDp = HUGE(OtherState%TTpBrDp) !basically never deploy them. Eventually this will be added back?

   CALL AllocAry( OtherState%TTpBrFl,  p%NumBl, 'TTpBrFl', ErrStat2, ErrMsg2 )
      if (Failed())  return;
   OtherState%TTpBrFl = HUGE(OtherState%TTpBrFl) !basically never deploy them. Eventually this will be added back?
   !OtherState%TTpBrFl = InputFileData%TTpBrFl + p%TpBrDT


      !............................................................................................
      ! yaw control integrated command angle
      !............................................................................................
   OtherState%YawPosComInt = p%YawNeut 
   
   
      !............................................................................................
      ! If you want to choose your own rate instead of using what the glue code suggests, tell the glue code the rate at which
      !   this module must be called here:
      !............................................................................................

   Interval = p%DT      
      
      !............................................................................................
      ! After we've set up all the data for everything else, we'll call the routines to initialize the Bladed Interface
      ! (it requires initial guesses for input/output)
      !............................................................................................
      
   IF ( p%UseBladedInterface ) THEN

      p%AirDens      = InitInp%AirDens
      p%AvgWindSpeed = InitInp%AvgWindSpeed
      
      CALL BladedInterface_Init(u, p, m, y, InputFileData, InitInp, ErrStat2, ErrMsg2 )
         if (Failed())  return;
         
      m%LastTimeCalled   = - m%dll_data%DLL_DT  ! we'll initialize the last time the DLL was called as -1 DLL_DT.
      m%LastTimeFiltered = - p%DT      ! we'll initialize the last time the DLL was filtered as -1 DT.
      m%FirstWarn        = .TRUE.
   ELSE
      m%dll_data%DLL_DT = p%DT         ! DLL_DT is used to compute the pitch rate and acceleration outputs
      p%DLL_n  = 1                     ! Without a call to the DLL, update the history every time step

      p%DLL_Trgt%FileName = ""
      p%DLL_Trgt%ProcName = ""
      
   END IF
         
  
      !............................................................................................
      ! Setup and initialize the StC submodule (possibly multiple instances at each location)
      !............................................................................................
   call StC_Nacelle_Setup(InitInp,p,InputFileData,u%NStC,p%NStC,x%NStC,xd%NStC,z%NStC,OtherState%NStC,y%NStC,m%NStC,ErrStat2,ErrMsg2)
      if (Failed())  return;

   call StC_Tower_Setup(InitInp,p,InputFileData,u%TStC,p%TStC,x%TStC,xd%TStC,z%TStC,OtherState%TStC,y%TStC,m%TStC,ErrStat2,ErrMsg2)
      if (Failed())  return;

   call StC_Blade_Setup(InitInp,p,InputFileData,u%BStC,p%BStC,x%BStC,xd%BStC,z%BStC,OtherState%BStC,y%BStC,m%BStC,ErrStat2,ErrMsg2)
      if (Failed())  return;

   call StC_Ptfm_Setup(InitInp,p,InputFileData,u%PtfmStC,p%PtfmStC,x%PtfmStC,xd%PtfmStC,z%PtfmStC,OtherState%PtfmStC,y%PtfmStC,m%PtfmStC,ErrStat2,ErrMsg2)
      if (Failed())  return;


      !............................................................................................
      ! Set Init outputs for linearization (after StrucCtrl, in case we ever add the StrucCtrl to the linearization features):
      !............................................................................................
   xd%CtrlOffset = 0.0_ReKi ! initialize before first use with TrimCase in linearization
   p%TrimCase    = InitInp%TrimCase
   p%TrimGain    = InitInp%TrimGain
   p%RotSpeedRef = InitInp%RotSpeedRef

   if (InitInp%Linearize) then
            
      ! If the module does allow linearization, return the appropriate Jacobian row/column names here:   
      ! Allocate and set these variables: InitOut%LinNames_y, InitOut%LinNames_x, InitOut%LinNames_xd, InitOut%LinNames_z, InitOut%LinNames_u 
      
      CALL AllocAry( InitOut%RotFrame_y, SrvD_Indx_Y_WrOutput+p%NumOuts, 'RotFrame_y', ErrStat2, ErrMsg2 )
      if (Failed())  return;
      
      CALL AllocAry( InitOut%LinNames_y, SrvD_Indx_Y_WrOutput+p%NumOuts, 'LinNames_y', ErrStat2, ErrMsg2 )
      if (Failed())  return;
         
      do i=1,size(SrvD_Indx_Y_BlPitchCom)
         InitOut%LinNames_y(SrvD_Indx_Y_BlPitchCom(i)) = 'BlPitchCom('//trim(num2lstr(i))//'), rad'
         InitOut%RotFrame_y(SrvD_Indx_Y_BlPitchCom(i)) = .true.         
      end do
      InitOut%LinNames_y(SrvD_Indx_Y_YawMom)  = 'YawMom, Nm'
      InitOut%RotFrame_y(SrvD_Indx_Y_YawMom)  = .false.
      
      InitOut%LinNames_y(SrvD_Indx_Y_GenTrq)  = 'GenTrq, Nm'
      InitOut%RotFrame_y(SrvD_Indx_Y_GenTrq)  = .false.

      InitOut%LinNames_y(SrvD_Indx_Y_ElecPwr) = 'ElecPwr, W'
      InitOut%RotFrame_y(SrvD_Indx_Y_ElecPwr) = .false.

      do i=1,p%NumOuts
         InitOut%LinNames_y(i+SrvD_Indx_Y_WrOutput) = trim(p%OutParam(i)%Name)//', '//p%OutParam(i)%Units
         InitOut%RotFrame_y(i+SrvD_Indx_Y_WrOutput) = ANY( p%OutParam(i)%Indx == BlPitchC ) ! the only WriteOutput values in the rotating frame are BlPitch commands
      end do
            
      
      CALL AllocAry( InitOut%RotFrame_u, 3, 'RotFrame_u', ErrStat2, ErrMsg2 )
         if (Failed())  return;

      CALL AllocAry( InitOut%IsLoad_u, 3, 'IsLoad_u', ErrStat2, ErrMsg2 )
         if (Failed())  return;

      CALL AllocAry( InitOut%LinNames_u, 3, 'LinNames_u', ErrStat2, ErrMsg2 )
         if (Failed())  return;

      InitOut%LinNames_u(Indx_u_Yaw    ) = 'Yaw, rad'
      InitOut%LinNames_u(Indx_u_YawRate) = 'YawRate, rad/s'
      InitOut%LinNames_u(Indx_u_HSS_Spd) = 'HSS_Spd, rad/s'
      InitOut%RotFrame_u = .false.  ! none of these are in the rotating frame
      InitOut%IsLoad_u   = .false.  ! none of these linearization inputs are loads

   else

      p%TrimCase = TrimCase_none

   end if


      !............................................................................................
      ! Define initialization-routine output here:
      !............................................................................................
   CALL AllocAry( y%WriteOutput, p%NumOuts+p%NumOuts_DLL, 'WriteOutput', ErrStat2, ErrMsg2 )
      if (Failed())  return;
   y%WriteOutput = 0

   CALL AllocAry( InitOut%WriteOutputHdr, p%NumOuts+p%NumOuts_DLL, 'WriteOutputHdr', ErrStat2, ErrMsg2 )
      if (Failed())  return;
   CALL AllocAry( InitOut%WriteOutputUnt, p%NumOuts+p%NumOuts_DLL, 'WriteOutputUnt', ErrStat2, ErrMsg2 )
      if (Failed())  return;
   
   do i=1,p%NumOuts
      InitOut%WriteOutputHdr(i) = p%OutParam(i)%Name
      InitOut%WriteOutputUnt(i) = p%OutParam(i)%Units
   end do
   
   j=p%NumOuts
   do i=1,p%NumOuts_DLL
      j = j + 1
      InitOut%WriteOutputHdr(j) = m%dll_data%LogChannels_OutParam(i)%Name
      InitOut%WriteOutputUnt(j) = m%dll_data%LogChannels_OutParam(i)%Units
   end do
   
   InitOut%Ver = SrvD_Ver
   
   InitOut%UseHSSBrake = (p%HSSBrMode /= ControlMode_None .AND. p%THSSBrDp < InitInp%TMax) .or. p%HSSBrMode == ControlMode_DLL
   
   IF ( p%UseBladedInterface .OR. InitOut%UseHSSBrake ) THEN
      InitOut%CouplingScheme = ExplicitLoose
   !   CALL SetErrStat( ErrID_Info, 'The external dynamic-link library option being used in ServoDyn '&
   !                    //'requires an explicit-loose coupling scheme.',ErrStat,ErrMsg,RoutineName )
   ELSE
      InitOut%CouplingScheme = ExplicitLoose
   END IF
   
   
      !............................................................................................
      ! Clean up the local variables:
      !............................................................................................
   CALL SrvD_DestroyInputFile( InputFileData, ErrStat2, ErrMsg2 )
   CALL StC_DestroyInitOutput(StC_InitOut, ErrStat2, ErrMsg2 )

   RETURN

contains
   logical function Failed()
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      Failed = ErrStat >= AbortErrLev
      if (Failed)    call Cleanup()
   end function Failed
   subroutine Cleanup()    ! Ignore any errors here
      CALL SrvD_DestroyInputFile(InputFileData, ErrStat2, ErrMsg2 )
      CALL StC_DestroyInitInput(StC_InitInp, ErrStat2, ErrMsg2 )
      CALL StC_DestroyInitOutput(StC_InitOut, ErrStat2, ErrMsg2 )
   end subroutine Cleanup
END SUBROUTINE SrvD_Init
!----------------------------------------------------------------------------------------------------------------------------------

!----------------------------------------------------------------------------------------------------------------------------------
!> This routine sets the data structures for the structural control (StC) module -- Nacelle Instances
subroutine StC_Nacelle_Setup(SrvD_InitInp,SrvD_p,InputFileData,u,p,x,xd,z,OtherState,y,m,ErrStat,ErrMsg)
   type(SrvD_InitInputType),                    intent(in   )  :: SrvD_InitInp   !< Input data for initialization routine
   type(SrvD_ParameterType),                    intent(in   )  :: SrvD_p         !< Parameters
   TYPE(SrvD_InputFile),                        intent(in   )  :: InputFileData  ! Data stored in the module's input file
   type(StC_InputType),             allocatable,intent(  out)  :: u(:)           !< An initial guess for the input; input mesh must be defined
   type(StC_ParameterType),         allocatable,intent(  out)  :: p(:)           !< Parameters
   type(StC_ContinuousStateType),   allocatable,intent(  out)  :: x(:)           !< Initial continuous states
   type(StC_DiscreteStateType),     allocatable,intent(  out)  :: xd(:)          !< Initial discrete states
   type(StC_ConstraintStateType),   allocatable,intent(  out)  :: z(:)           !< Initial guess of the constraint states
   type(StC_OtherStateType),        allocatable,intent(  out)  :: OtherState(:)  !< Initial other states
   type(StC_OutputType),            allocatable,intent(  out)  :: y(:)           !< Initial system outputs (outputs are not calculated;
   type(StC_MiscVarType),           allocatable,intent(  out)  :: m(:)           !< Misc (optimization) variables
   integer(IntKi),                              intent(  out)  :: ErrStat        !< Error status of the operation
   character(*),                                intent(  out)  :: ErrMsg         !< Error message if ErrStat /= ErrID_None

   integer(IntKi)             :: ErrStat2       ! temporary Error status of the operation
   character(ErrMsgLen)       :: ErrMsg2        ! temporary Error message if ErrStat /= ErrID_None
   integer(IntKi)             :: j              ! Counter for the instances
   real(DbKi)                 :: Interval       !< Coupling interval in seconds from StC
   type(StC_InitInputType)    :: StC_InitInp    !< data to initialize StC module
   type(StC_InitOutputType)   :: StC_InitOut    !< data from StC module initialization (not currently used)
   character(*), parameter    :: RoutineName = 'StC_Nacelle_Setup'

   ErrStat  = ErrID_None
   ErrMsg   = ""

   if (SrvD_p%CompNStC > 0_IntKi) then
      allocate(u(SrvD_p%CompNStC), STAT=ErrStat2);          if ( AllErr('Could not allocate StrucCtrl input array, u') )            return;
      allocate(p(SrvD_p%CompNStC), STAT=ErrStat2);          if ( AllErr('Could not allocate StrucCtrl input array, p') )            return;
      allocate(x(SrvD_p%CompNStC), STAT=ErrStat2);          if ( AllErr('Could not allocate StrucCtrl input array, x') )            return;
      allocate(xd(SrvD_p%CompNStC),STAT=ErrStat2);          if ( AllErr('Could not allocate StrucCtrl input array, xd') )           return;
      allocate(z(SrvD_p%CompNStC), STAT=ErrStat2);          if ( AllErr('Could not allocate StrucCtrl input array, z') )            return;
      allocate(OtherState(SrvD_p%CompNStC), STAT=ErrStat2); if ( AllErr('Could not allocate StrucCtrl input array, OtherState') )   return;
      allocate(y(SrvD_p%CompNStC), STAT=ErrStat2);          if ( AllErr('Could not allocate StrucCtrl input array, y') )            return;
      allocate(m(SrvD_p%CompNStC), STAT=ErrStat2);          if ( AllErr('Could not allocate StrucCtrl input array, m') )            return;

      do j=1,SrvD_p%CompNStC
         StC_InitInp%InputFile      =  InputFileData%NStCfile(j)
         StC_InitInp%RootName       =  TRIM(SrvD_p%RootName)//'.NStC'
         StC_InitInp%Gravity        =  SrvD_InitInp%gravity
         StC_InitInp%NumMeshPts     =  1_IntKi        ! single point mesh for Nacelle
         Interval                   =  SrvD_p%DT      ! Pass the ServoDyn DT

         CALL AllocAry( StC_InitInp%InitPosition,      3, StC_InitInp%NumMeshPts, 'StC_InitInp%InitPosition',     errStat2, ErrMsg2);  if (Failed())  return;
         CALL AllocAry( StC_InitInp%InitOrientation,3, 3, StC_InitInp%NumMeshPts, 'StC_InitInp%InitOrientation',  errStat2, ErrMsg2);  if (Failed())  return;
         StC_InitInp%InitPosition(:,1)      = SrvD_InitInp%NacPosition
         StC_InitInp%InitOrientation(:,:,1) = SrvD_InitInp%NacOrientation

         CALL StC_Init( StC_InitInp, u(j), p(j), x(j), xd(j), z(j), OtherState(j), y(j), m(j), Interval, StC_InitOut, ErrStat2, ErrMsg2 )
         if (Failed())  return;

         IF (.NOT. EqualRealNos( Interval, SrvD_p%DT ) ) &
            CALL SetErrStat( ErrID_Fatal, "Nacelle StrucCtrl (instance "//trim(num2lstr(j))//") time step differs from SrvD time step.",ErrStat,ErrMsg,RoutineName )
         if (Failed())  return;

         call Cleanup()
      enddo
   endif
contains
   logical function Failed()
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      Failed = ErrStat >= AbortErrLev
      if (Failed)    call Cleanup()
   end function Failed
   logical function AllErr(Msg)
      character(*), intent(in) :: Msg
      if(ErrStat2 /= 0) then
         CALL SetErrStat( ErrID_Fatal, Msg, ErrStat, ErrMsg, RoutineName )
      endif
      AllErr = ErrStat >= AbortErrLev
      if (AllErr)    call Cleanup()
   end function AllErr
   subroutine Cleanup()    ! Ignore any errors here
      CALL StC_DestroyInitInput(StC_InitInp, ErrStat2, ErrMsg2 )
      CALL StC_DestroyInitOutput(StC_InitOut, ErrStat2, ErrMsg2 )
   end subroutine Cleanup
end subroutine StC_Nacelle_Setup
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine sets the data structures for the structural control (StC) module -- Tower instances
subroutine StC_Tower_Setup(SrvD_InitInp,SrvD_p,InputFileData,u,p,x,xd,z,OtherState,y,m,ErrStat,ErrMsg)
   type(SrvD_InitInputType),                    intent(in   )  :: SrvD_InitInp   !< Input data for initialization routine
   type(SrvD_ParameterType),                    intent(in   )  :: SrvD_p         !< Parameters
   TYPE(SrvD_InputFile),                        intent(in   )  :: InputFileData  ! Data stored in the module's input file
   type(StC_InputType),             allocatable,intent(  out)  :: u(:)           !< An initial guess for the input; input mesh must be defined
   type(StC_ParameterType),         allocatable,intent(  out)  :: p(:)           !< Parameters
   type(StC_ContinuousStateType),   allocatable,intent(  out)  :: x(:)           !< Initial continuous states
   type(StC_DiscreteStateType),     allocatable,intent(  out)  :: xd(:)          !< Initial discrete states
   type(StC_ConstraintStateType),   allocatable,intent(  out)  :: z(:)           !< Initial guess of the constraint states
   type(StC_OtherStateType),        allocatable,intent(  out)  :: OtherState(:)  !< Initial other states
   type(StC_OutputType),            allocatable,intent(  out)  :: y(:)           !< Initial system outputs (outputs are not calculated;
   type(StC_MiscVarType),           allocatable,intent(  out)  :: m(:)           !< Misc (optimization) variables
   integer(IntKi),                              intent(  out)  :: ErrStat        !< Error status of the operation
   character(*),                                intent(  out)  :: ErrMsg         !< Error message if ErrStat /= ErrID_None

   integer(IntKi)             :: ErrStat2       ! temporary Error status of the operation
   character(ErrMsgLen)       :: ErrMsg2        ! temporary Error message if ErrStat /= ErrID_None
   integer(IntKi)             :: j              ! Counter for the instances
   real(DbKi)                 :: Interval       !< Coupling interval in seconds from StC
   type(StC_InitInputType)    :: StC_InitInp    !< data to initialize StC module
   type(StC_InitOutputType)   :: StC_InitOut    !< data from StC module initialization (not currently used)
   character(*), parameter    :: RoutineName = 'StC_Tower_Setup'

   ErrStat  = ErrID_None
   ErrMsg   = ""

   if (SrvD_p%CompTStC > 0_IntKi) then
      allocate(u(SrvD_p%CompTStC), STAT=ErrStat2);          if ( AllErr('Could not allocate StrucCtrl input array, u') )            return;
      allocate(p(SrvD_p%CompTStC), STAT=ErrStat2);          if ( AllErr('Could not allocate StrucCtrl input array, p') )            return;
      allocate(x(SrvD_p%CompTStC), STAT=ErrStat2);          if ( AllErr('Could not allocate StrucCtrl input array, x') )            return;
      allocate(xd(SrvD_p%CompTStC),STAT=ErrStat2);          if ( AllErr('Could not allocate StrucCtrl input array, xd') )           return;
      allocate(z(SrvD_p%CompTStC), STAT=ErrStat2);          if ( AllErr('Could not allocate StrucCtrl input array, z') )            return;
      allocate(OtherState(SrvD_p%CompTStC), STAT=ErrStat2); if ( AllErr('Could not allocate StrucCtrl input array, OtherState') )   return;
      allocate(y(SrvD_p%CompTStC), STAT=ErrStat2);          if ( AllErr('Could not allocate StrucCtrl input array, y') )            return;
      allocate(m(SrvD_p%CompTStC), STAT=ErrStat2);          if ( AllErr('Could not allocate StrucCtrl input array, m') )            return;

      do j=1,SrvD_p%CompTStC
         StC_InitInp%InputFile      =  InputFileData%TStCfile(j)
         StC_InitInp%RootName       =  TRIM(SrvD_p%RootName)//'.TStC'
         StC_InitInp%Gravity        =  SrvD_InitInp%gravity
         StC_InitInp%NumMeshPts     =  1_IntKi        ! single point mesh for Tower
         Interval                   =  SrvD_p%DT      ! Pass the ServoDyn DT

         CALL AllocAry( StC_InitInp%InitPosition,      3, StC_InitInp%NumMeshPts, 'StC_InitInp%InitPosition',     errStat2, ErrMsg2);  if (Failed())  return;
         CALL AllocAry( StC_InitInp%InitOrientation,3, 3, StC_InitInp%NumMeshPts, 'StC_InitInp%InitOrientation',  errStat2, ErrMsg2);  if (Failed())  return;
         StC_InitInp%InitPosition(:,1)      = SrvD_InitInp%TwrBasePos
         StC_InitInp%InitOrientation(:,:,1) = SrvD_InitInp%TwrBaseOrient

         CALL StC_Init( StC_InitInp, u(j), p(j), x(j), xd(j), z(j), OtherState(j), y(j), m(j), Interval, StC_InitOut, ErrStat2, ErrMsg2 )
         if (Failed())  return;

         IF (.NOT. EqualRealNos( Interval, SrvD_p%DT ) ) &
            CALL SetErrStat( ErrID_Fatal, "Tower StrucCtrl (instance "//trim(num2lstr(j))//") time step differs from SrvD time step.",ErrStat,ErrMsg,RoutineName )
         if (Failed())  return;

         call Cleanup()
      enddo
   endif
contains
   logical function Failed()
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      Failed = ErrStat >= AbortErrLev
      if (Failed)    call Cleanup()
   end function Failed
   logical function AllErr(Msg)
      character(*), intent(in) :: Msg
      if(ErrStat2 /= 0) then
         CALL SetErrStat( ErrID_Fatal, Msg, ErrStat, ErrMsg, RoutineName )
      endif
      AllErr = ErrStat >= AbortErrLev
      if (AllErr)    call Cleanup()
   end function AllErr
   subroutine Cleanup()    ! Ignore any errors here
      CALL StC_DestroyInitInput(StC_InitInp, ErrStat2, ErrMsg2 )
      CALL StC_DestroyInitOutput(StC_InitOut, ErrStat2, ErrMsg2 )
   end subroutine Cleanup
end subroutine StC_Tower_Setup
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine sets the data structures for the structural control (StC) module -- Blade instances
subroutine StC_Blade_Setup(SrvD_InitInp,SrvD_p,InputFileData,u,p,x,xd,z,OtherState,y,m,ErrStat,ErrMsg)
   type(SrvD_InitInputType),                    intent(in   )  :: SrvD_InitInp   !< Input data for initialization routine
   type(SrvD_ParameterType),                    intent(in   )  :: SrvD_p         !< Parameters
   TYPE(SrvD_InputFile),                        intent(in   )  :: InputFileData  ! Data stored in the module's input file
   type(StC_InputType),             allocatable,intent(  out)  :: u(:)           !< An initial guess for the input; input mesh must be defined
   type(StC_ParameterType),         allocatable,intent(  out)  :: p(:)           !< Parameters
   type(StC_ContinuousStateType),   allocatable,intent(  out)  :: x(:)           !< Initial continuous states
   type(StC_DiscreteStateType),     allocatable,intent(  out)  :: xd(:)          !< Initial discrete states
   type(StC_ConstraintStateType),   allocatable,intent(  out)  :: z(:)           !< Initial guess of the constraint states
   type(StC_OtherStateType),        allocatable,intent(  out)  :: OtherState(:)  !< Initial other states
   type(StC_OutputType),            allocatable,intent(  out)  :: y(:)           !< Initial system outputs (outputs are not calculated;
   type(StC_MiscVarType),           allocatable,intent(  out)  :: m(:)           !< Misc (optimization) variables
   integer(IntKi),                              intent(  out)  :: ErrStat        !< Error status of the operation
   character(*),                                intent(  out)  :: ErrMsg         !< Error message if ErrStat /= ErrID_None

   integer(IntKi)             :: ErrStat2       ! temporary Error status of the operation
   character(ErrMsgLen)       :: ErrMsg2        ! temporary Error message if ErrStat /= ErrID_None
   integer(IntKi)             :: j              ! Counter for the instances
   integer(IntKi)             :: k              ! Counter for the blade
   real(DbKi)                 :: Interval       !< Coupling interval in seconds from StC
   type(StC_InitInputType)    :: StC_InitInp    !< data to initialize StC module
   type(StC_InitOutputType)   :: StC_InitOut    !< data from StC module initialization (not currently used)
   character(*), parameter    :: RoutineName = 'StC_Blade_Setup'

   ErrStat  = ErrID_None
   ErrMsg   = ""

   if (SrvD_p%CompBStC > 0_IntKi) then
      allocate(u(SrvD_p%CompBStC), STAT=ErrStat2);          if ( AllErr('Could not allocate StrucCtrl input array, u') )            return;
      allocate(p(SrvD_p%CompBStC), STAT=ErrStat2);          if ( AllErr('Could not allocate StrucCtrl input array, p') )            return;
      allocate(x(SrvD_p%CompBStC), STAT=ErrStat2);          if ( AllErr('Could not allocate StrucCtrl input array, x') )            return;
      allocate(xd(SrvD_p%CompBStC),STAT=ErrStat2);          if ( AllErr('Could not allocate StrucCtrl input array, xd') )           return;
      allocate(z(SrvD_p%CompBStC), STAT=ErrStat2);          if ( AllErr('Could not allocate StrucCtrl input array, z') )            return;
      allocate(OtherState(SrvD_p%CompBStC), STAT=ErrStat2); if ( AllErr('Could not allocate StrucCtrl input array, OtherState') )   return;
      allocate(y(SrvD_p%CompBStC), STAT=ErrStat2);          if ( AllErr('Could not allocate StrucCtrl input array, y') )            return;
      allocate(m(SrvD_p%CompBStC), STAT=ErrStat2);          if ( AllErr('Could not allocate StrucCtrl input array, m') )            return;

      do j=1,SrvD_p%CompBStC
         StC_InitInp%InputFile      =  InputFileData%BStCfile(j)
         StC_InitInp%RootName       =  TRIM(SrvD_p%RootName)//'.BStC'
         StC_InitInp%Gravity        =  SrvD_InitInp%gravity
         StC_InitInp%NumMeshPts     =  SrvD_p%NumBl        ! p%NumBl points for blades
         Interval                   =  SrvD_p%DT      ! Pass the ServoDyn DT

         CALL AllocAry( StC_InitInp%InitPosition,      3, StC_InitInp%NumMeshPts, 'StC_InitInp%InitPosition',     errStat2, ErrMsg2);  if (Failed())  return;
         CALL AllocAry( StC_InitInp%InitOrientation,3, 3, StC_InitInp%NumMeshPts, 'StC_InitInp%InitOrientation',  errStat2, ErrMsg2);  if (Failed())  return;
         do k=1,StC_InitInp%NumMeshPts
            StC_InitInp%InitPosition(:,k)      = SrvD_InitInp%BladeRootPosition(:,k)
            StC_InitInp%InitOrientation(:,:,k) = SrvD_InitInp%BladeRootOrientation(:,:,k)
         enddo

         CALL StC_Init( StC_InitInp, u(j), p(j), x(j), xd(j), z(j), OtherState(j), y(j), m(j), Interval, StC_InitOut, ErrStat2, ErrMsg2 )
         if (Failed())  return;

         IF (.NOT. EqualRealNos( Interval, SrvD_p%DT ) ) &
            CALL SetErrStat( ErrID_Fatal, "Blade StrucCtrl (instance "//trim(num2lstr(j))//") time step differs from SrvD time step.",ErrStat,ErrMsg,RoutineName )
         if (Failed())  return;

         call Cleanup()
      enddo
   endif
contains
   logical function Failed()
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      Failed = ErrStat >= AbortErrLev
      if (Failed)    call Cleanup()
   end function Failed
   logical function AllErr(Msg)
      character(*), intent(in) :: Msg
      if(ErrStat2 /= 0) then
         CALL SetErrStat( ErrID_Fatal, Msg, ErrStat, ErrMsg, RoutineName )
      endif
      AllErr = ErrStat >= AbortErrLev
      if (AllErr)    call Cleanup()
   end function AllErr
   subroutine Cleanup()    ! Ignore any errors here
      CALL StC_DestroyInitInput(StC_InitInp, ErrStat2, ErrMsg2 )
      CALL StC_DestroyInitOutput(StC_InitOut, ErrStat2, ErrMsg2 )
   end subroutine Cleanup
end subroutine StC_Blade_Setup
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine sets the data structures for the structural control (StC) module -- hydrodynamics platform instances
subroutine StC_Ptfm_Setup(SrvD_InitInp,SrvD_p,InputFileData,u,p,x,xd,z,OtherState,y,m,ErrStat,ErrMsg)
   type(SrvD_InitInputType),                    intent(in   )  :: SrvD_InitInp   !< Input data for initialization routine
   type(SrvD_ParameterType),                    intent(in   )  :: SrvD_p         !< Parameters
   TYPE(SrvD_InputFile),                        intent(in   )  :: InputFileData  ! Data stored in the module's input file
   type(StC_InputType),             allocatable,intent(  out)  :: u(:)           !< An initial guess for the input; input mesh must be defined
   type(StC_ParameterType),         allocatable,intent(  out)  :: p(:)           !< Parameters
   type(StC_ContinuousStateType),   allocatable,intent(  out)  :: x(:)           !< Initial continuous states
   type(StC_DiscreteStateType),     allocatable,intent(  out)  :: xd(:)          !< Initial discrete states
   type(StC_ConstraintStateType),   allocatable,intent(  out)  :: z(:)           !< Initial guess of the constraint states
   type(StC_OtherStateType),        allocatable,intent(  out)  :: OtherState(:)  !< Initial other states
   type(StC_OutputType),            allocatable,intent(  out)  :: y(:)           !< Initial system outputs (outputs are not calculated;
   type(StC_MiscVarType),           allocatable,intent(  out)  :: m(:)           !< Misc (optimization) variables
   integer(IntKi),                              intent(  out)  :: ErrStat        !< Error status of the operation
   character(*),                                intent(  out)  :: ErrMsg         !< Error message if ErrStat /= ErrID_None

   integer(IntKi)             :: ErrStat2       ! temporary Error status of the operation
   character(ErrMsgLen)       :: ErrMsg2        ! temporary Error message if ErrStat /= ErrID_None
   integer(IntKi)             :: j              ! Counter for the instances
   real(DbKi)                 :: Interval       !< Coupling interval in seconds from StC
   type(StC_InitInputType)    :: StC_InitInp    !< data to initialize StC module
   type(StC_InitOutputType)   :: StC_InitOut    !< data from StC module initialization (not currently used)
   character(*), parameter    :: RoutineName = 'StC_Ptfm_Setup'

   ErrStat  = ErrID_None
   ErrMsg   = ""

   if (SrvD_p%CompPtfmStC > 0_IntKi) then
      allocate(u(SrvD_p%CompPtfmStC), STAT=ErrStat2);          if ( AllErr('Could not allocate StrucCtrl input array, u') )            return;
      allocate(p(SrvD_p%CompPtfmStC), STAT=ErrStat2);          if ( AllErr('Could not allocate StrucCtrl input array, p') )            return;
      allocate(x(SrvD_p%CompPtfmStC), STAT=ErrStat2);          if ( AllErr('Could not allocate StrucCtrl input array, x') )            return;
      allocate(xd(SrvD_p%CompPtfmStC),STAT=ErrStat2);          if ( AllErr('Could not allocate StrucCtrl input array, xd') )           return;
      allocate(z(SrvD_p%CompPtfmStC), STAT=ErrStat2);          if ( AllErr('Could not allocate StrucCtrl input array, z') )            return;
      allocate(OtherState(SrvD_p%CompPtfmStC), STAT=ErrStat2); if ( AllErr('Could not allocate StrucCtrl input array, OtherState') )   return;
      allocate(y(SrvD_p%CompPtfmStC), STAT=ErrStat2);          if ( AllErr('Could not allocate StrucCtrl input array, y') )            return;
      allocate(m(SrvD_p%CompPtfmStC), STAT=ErrStat2);          if ( AllErr('Could not allocate StrucCtrl input array, m') )            return;

      do j=1,SrvD_p%CompPtfmStC
         StC_InitInp%InputFile      =  InputFileData%PtfmStCfile(j)
         StC_InitInp%RootName       =  TRIM(SrvD_p%RootName)//'.PtfmStC'
         StC_InitInp%Gravity        =  SrvD_InitInp%gravity
         StC_InitInp%NumMeshPts     =  1_IntKi        ! single point mesh for Platform
         Interval                   =  SrvD_p%DT      ! Pass the ServoDyn DT

         CALL AllocAry( StC_InitInp%InitPosition,      3, StC_InitInp%NumMeshPts, 'StC_InitInp%InitPosition',     errStat2, ErrMsg2);  if (Failed())  return;
         CALL AllocAry( StC_InitInp%InitOrientation,3, 3, StC_InitInp%NumMeshPts, 'StC_InitInp%InitOrientation',  errStat2, ErrMsg2);  if (Failed())  return;
         StC_InitInp%InitPosition(1:3,1)    = SrvD_InitInp%PlatformPos(1:3)
         StC_InitInp%InitOrientation(:,:,1) = SrvD_InitInp%PlatformOrient

         CALL StC_Init( StC_InitInp, u(j), p(j), x(j), xd(j), z(j), OtherState(j), y(j), m(j), Interval, StC_InitOut, ErrStat2, ErrMsg2 )
         if (Failed())  return;

         IF (.NOT. EqualRealNos( Interval, SrvD_p%DT ) ) &
            CALL SetErrStat( ErrID_Fatal, "Platform StrucCtrl (instance "//trim(num2lstr(j))//") time step differs from SrvD time step.",ErrStat,ErrMsg,RoutineName )
         if (Failed())  return;

         call Cleanup()
      enddo
   endif
contains
   logical function Failed()
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      Failed = ErrStat >= AbortErrLev
      if (Failed)    call Cleanup()
   end function Failed
   logical function AllErr(Msg)
      character(*), intent(in) :: Msg
      if(ErrStat2 /= 0) then
         CALL SetErrStat( ErrID_Fatal, Msg, ErrStat, ErrMsg, RoutineName )
      endif
      AllErr = ErrStat >= AbortErrLev
      if (AllErr)    call Cleanup()
   end function AllErr
   subroutine Cleanup()    ! Ignore any errors here
      CALL StC_DestroyInitInput(StC_InitInp, ErrStat2, ErrMsg2 )
      CALL StC_DestroyInitOutput(StC_InitOut, ErrStat2, ErrMsg2 )
   end subroutine Cleanup
end subroutine StC_Ptfm_Setup

!----------------------------------------------------------------------------------------------------------------------------------
!> This routine is called at the end of the simulation.
SUBROUTINE SrvD_End( u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg )
!..................................................................................................................................

      TYPE(SrvD_InputType),           INTENT(INOUT)  :: u           !< System inputs
      TYPE(SrvD_ParameterType),       INTENT(INOUT)  :: p           !< Parameters
      TYPE(SrvD_ContinuousStateType), INTENT(INOUT)  :: x           !< Continuous states
      TYPE(SrvD_DiscreteStateType),   INTENT(INOUT)  :: xd          !< Discrete states
      TYPE(SrvD_ConstraintStateType), INTENT(INOUT)  :: z           !< Constraint states
      TYPE(SrvD_OtherStateType),      INTENT(INOUT)  :: OtherState  !< Other states
      TYPE(SrvD_OutputType),          INTENT(INOUT)  :: y           !< System outputs
      TYPE(SrvD_MiscVarType),         INTENT(INOUT)  :: m           !< Initial misc (optimization) variables
      INTEGER(IntKi),                 INTENT(  OUT)  :: ErrStat     !< Error status of the operation
      CHARACTER(*),                   INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None

      integer(IntKi) :: j     ! loop counter for instance of StC at location


         ! Place any last minute operations or calculations here:
      IF ( p%UseBladedInterface ) THEN
         CALL BladedInterface_End(u, p, m, ErrStat, ErrMsg )
      END IF
      
      ! StrucCtrl
      do j=1,p%CompNStC       ! Nacelle
         call StC_End( u%NStC(j), p%NStC(j), x%NStC(j), xd%NStC(j), z%NStC(j), OtherState%NStC(j), y%NStC(j), m%NStC(j), ErrStat, ErrMsg )
      enddo
      do j=1,p%CompTStC       ! Tower
         call StC_End( u%TStC(j), p%TStC(j), x%TStC(j), xd%TStC(j), z%TStC(j), OtherState%TStC(j), y%TStC(j), m%TStC(j), ErrStat, ErrMsg )
      enddo
      do j=1,p%CompBStC       ! Blades
         call StC_End( u%BStC(j), p%BStC(j), x%BStC(j), xd%BStC(j), z%BStC(j), OtherState%BStC(j), y%BStC(j), m%BStC(j), ErrStat, ErrMsg )
      enddo
      do j=1,p%CompPtfmStC    ! Platform
         call StC_End( u%PtfmStC(j), p%PtfmStC(j), x%PtfmStC(j), xd%PtfmStC(j), z%PtfmStC(j), OtherState%PtfmStC(j), y%PtfmStC(j), m%PtfmStC(j), ErrStat, ErrMsg )
      enddo

         ! Destroy the input data:
      CALL SrvD_DestroyInput( u, ErrStat, ErrMsg )

         ! Destroy the parameter data:
      CALL SrvD_DestroyParam( p, ErrStat, ErrMsg )

         ! Destroy the state data:
      CALL SrvD_DestroyContState(   x,           ErrStat, ErrMsg )
      CALL SrvD_DestroyDiscState(   xd,          ErrStat, ErrMsg )
      CALL SrvD_DestroyConstrState( z,           ErrStat, ErrMsg )
      CALL SrvD_DestroyOtherState(  OtherState,  ErrStat, ErrMsg )
      
         ! Destroy the misc var data:
      CALL SrvD_DestroyMisc( m, ErrStat, ErrMsg )

         ! Destroy the output data:
      CALL SrvD_DestroyOutput( y, ErrStat, ErrMsg )

         ! We are ignoring any errors from destroying data
      ErrStat = ErrID_None
      ErrMsg  = ""

END SUBROUTINE SrvD_End
!----------------------------------------------------------------------------------------------------------------------------------
!> This is a loose coupling routine for solving constraint states, integrating continuous states, and updating discrete and other 
!! states. Continuous, constraint, discrete, and other states are updated to values at t + Interval.
SUBROUTINE SrvD_UpdateStates( t, n, Inputs, InputTimes, p, x, xd, z, OtherState, m, ErrStat, ErrMsg )
!..................................................................................................................................

   REAL(DbKi),                      INTENT(IN   ) :: t               !< Current simulation time in seconds
   INTEGER(IntKi),                  INTENT(IN   ) :: n               !< Current step of the simulation: t = n*Interval
   TYPE(SrvD_InputType),            INTENT(INOUT) :: Inputs(:)       !< Inputs at InputTimes (output only for mesh record-keeping in ExtrapInterp routine)
   REAL(DbKi),                      INTENT(IN   ) :: InputTimes(:)   !< Times in seconds associated with Inputs
   TYPE(SrvD_ParameterType),        INTENT(IN   ) :: p               !< Parameters
   TYPE(SrvD_ContinuousStateType),  INTENT(INOUT) :: x               !< Input: Continuous states at t;
                                                                     !!   Output: Continuous states at t + Interval
   TYPE(SrvD_DiscreteStateType),    INTENT(INOUT) :: xd              !< Input: Discrete states at t;
                                                                     !!   Output: Discrete states at t  + Interval
   TYPE(SrvD_ConstraintStateType),  INTENT(INOUT) :: z               !< Input: Constraint states at t;
                                                                     !!   Output: Constraint states at t + Interval
   TYPE(SrvD_OtherStateType),       INTENT(INOUT) :: OtherState      !< Other states: Other states at t;
                                                                     !!   Output: Other states at t + Interval
   TYPE(SrvD_MiscVarType),          INTENT(INOUT) :: m               !< Misc (optimization) variables
   INTEGER(IntKi),                  INTENT(  OUT) :: ErrStat         !< Error status of the operation
   CHARACTER(*),                    INTENT(  OUT) :: ErrMsg          !< Error message if ErrStat /= ErrID_None

      ! Local variables
   TYPE(StC_InputType),ALLOCATABLE                :: u(:)            ! Inputs at t
   INTEGER(IntKi)                                 :: i               ! loop counter 
   INTEGER(IntKi)                                 :: j               ! loop counter for StC instance of type
   INTEGER(IntKi)                                 :: order
   TYPE(SrvD_InputType)                           :: u_interp        ! interpolated input
      ! Local variables:
      
      
   INTEGER(IntKi)                                 :: ErrStat2        ! Error status of the operation (occurs after initial error)
   CHARACTER(ErrMsgLen)                           :: ErrMsg2         ! Error message if ErrStat2 /= ErrID_None
   CHARACTER(*), PARAMETER                        :: RoutineName = 'SrvD_UpdateStates'
   REAL(DbKi)                                     :: t_next
      
      ! Initialize ErrStat

   ErrStat = ErrID_None
   ErrMsg  = ""
                  
   !...............................................................................................................................   
   ! update states in StrucCtrl submodule, if necessary:
   !...............................................................................................................................   

   IF ((p%CompNStC + p%CompTStC + p%CompBStC + p%CompPtfmStC) > 0_IntKi) THEN 
      order = SIZE(Inputs)
      allocate(u(order), STAT=ErrStat2)
      if (ErrStat2 /= 0) then
         CALL SetErrStat( ErrID_Fatal, 'Could not allocate StrucCtrl input array, u', ErrStat, ErrMsg, RoutineName )
            if (Failed()) return;
      endif
   ENDIF
      

      ! Nacelle StrucCtrl
   do j=1,p%CompNStC
      do i=1,order
         call StC_CopyInput( Inputs(i)%NStC(j), u(i), MESH_NEWCOPY, ErrStat2, ErrMsg2 )
         if (Failed()) return;
      enddo

      call StC_UpdateStates( t, n, u, InputTimes, p%NStC(j), x%NStC(j), xd%NStC(j), z%NStC(j), OtherState%NStC(j), m%NStC(j), ErrStat2, ErrMsg2 )
         if (Failed()) return;

         ! destroy these for the next call to StC_UpdateStates (reset for next StC instance)
      do i=1,SIZE(u)
         call StC_DestroyInput(u(i), ErrStat2, ErrMsg2)
         if (Failed()) return;
      enddo
   enddo


      ! Tower StrucCtrl
   do j=1,p%CompTStC
      do i=1,order
         call StC_CopyInput( Inputs(i)%TStC(j), u(i), MESH_NEWCOPY, ErrStat2, ErrMsg2 )
         if (Failed()) return;
      enddo

      call StC_UpdateStates( t, n, u, InputTimes, p%TStC(j), x%TStC(j), xd%TStC(j), z%TStC(j), OtherState%TStC(j), m%TStC(j), ErrStat2, ErrMsg2 )
         if (Failed()) return;

         ! destroy these for the next call to StC_UpdateStates (reset for next StC instance)
      do i=1,SIZE(u)
         call StC_DestroyInput(u(i), ErrStat2, ErrMsg2)
         if (Failed()) return;
      enddo
   enddo


      ! Blade StrucCtrl
   do j=1,p%CompBStC
      do i=1,order
         call StC_CopyInput( Inputs(i)%BStC(j), u(i), MESH_NEWCOPY, ErrStat2, ErrMsg2 )
         if (Failed()) return;
      enddo

      call StC_UpdateStates( t, n, u, InputTimes, p%BStC(j), x%BStC(j), xd%BStC(j), z%BStC(j), OtherState%BStC(j), m%BStC(j), ErrStat2, ErrMsg2 )
         if (Failed()) return;

         ! destroy these for the next call to StC_UpdateStates (reset for next StC instance)
      do i=1,SIZE(u)
         call StC_DestroyInput(u(i), ErrStat2, ErrMsg2)
         if (Failed()) return;
      enddo
   enddo


      ! Platform StrucCtrl
   do j=1,p%CompPtfmStC
      do i=1,order
         call StC_CopyInput( Inputs(i)%PtfmStC(j), u(i), MESH_NEWCOPY, ErrStat2, ErrMsg2 )
         if (Failed()) return;
      enddo

      call StC_UpdateStates( t, n, u, InputTimes, p%PtfmStC(j), x%PtfmStC(j), xd%PtfmStC(j), z%PtfmStC(j), OtherState%PtfmStC(j), m%PtfmStC(j), ErrStat2, ErrMsg2 )
         if (Failed()) return;

         ! destroy these for the next call to StC_UpdateStates (reset for next StC instance)
      do i=1,SIZE(u)
         call StC_DestroyInput(u(i), ErrStat2, ErrMsg2)
         if (Failed()) return;
      enddo
   enddo


   !...............................................................................................................................   
   ! get inputs at t:
   !...............................................................................................................................  
   CALL SrvD_CopyInput( Inputs(1), u_interp, MESH_NEWCOPY, ErrStat2, ErrMsg2 )
      if (Failed()) return;
   
   CALL SrvD_Input_ExtrapInterp( Inputs, InputTimes, u_interp, t, ErrStat2, ErrMsg2 )
      if (Failed()) return;
      
   !...............................................................................................................................   
   ! update discrete states:
   !...............................................................................................................................  
      ! 1. Get appropriate value of input for the filter in discrete states (this works only for the DLL at this point, so we're going to move it there)
      ! 2. Update control offset for trim solutions

   CALL SrvD_UpdateDiscState( t, u_interp, p, x, xd, z, OtherState, m, ErrStat2, ErrMsg2 )
      if (Failed()) return;
      
   !...............................................................................................................................   
   ! get inputs at t+dt:
   !...............................................................................................................................  
   t_next = t+p%dt
   
   CALL SrvD_Input_ExtrapInterp( Inputs, InputTimes, u_interp, t_next, ErrStat2, ErrMsg2 )
      if (Failed()) return;
   
   IF (p%UseBladedInterface) THEN
      CALL DLL_controller_call(t_next, u_interp, p, x, xd, z, OtherState, m, ErrStat2, ErrMsg2 )
         if (Failed()) return;
   END IF
   
   !...............................................................................................................................   
   ! update remaining states to values at t+dt:
   !...............................................................................................................................  
      
      ! Torque control:
   CALL Torque_UpdateStates( t_next, u_interp, p, x, xd, z, OtherState, m, ErrStat2, ErrMsg2 )
      if (Failed()) return;
      
      ! Pitch control:
   CALL Pitch_UpdateStates( t_next, u_interp, p, x, xd, z, OtherState, m, ErrStat2, ErrMsg2 )
      if (Failed()) return;
      
      ! Yaw control: 
   CALL Yaw_UpdateStates( t_next, u_interp, p, x, xd, z, OtherState, m, ErrStat2, ErrMsg2 )
      if (Failed()) return;
   
      ! Tip brake control:    
   CALL TipBrake_UpdateStates( t_next, u_interp, p, x, xd, z, OtherState, m, ErrStat2, ErrMsg2 )
      if (Failed()) return;
   
   !...................................................................
   ! Compute ElecPwr and GenTrq for controller (and DLL needs this saved):
   !...................................................................
   IF ( OtherState%GenOnLine .and. .not. OtherState%Off4Good )  THEN    ! Generator is on line.
      CALL CalculateTorque( t, u_interp, p, m, m%dll_data%GenTrq_prev, m%dll_data%ElecPwr_prev, ErrStat2, ErrMsg2 )
         if (Failed()) return;
   ELSE                                                                 ! Generator is off line.
      m%dll_data%GenTrq_prev  = 0.0_ReKi
      m%dll_data%ElecPwr_prev = 0.0_ReKi
   ENDIF

   !...............................................................................................................................   
   CALL Cleanup()
      
   RETURN
      
CONTAINS
   logical function Failed()
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      Failed = ErrStat >= AbortErrLev
      if (Failed)    call Cleanup()
   end function Failed
   SUBROUTINE Cleanup()
      IF (ALLOCATED(u)) THEN
         DO i=1,SIZE(u)
            CALL StC_DestroyInput(u(i), ErrStat2, ErrMsg2)
               CALL SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
         END DO
         DEALLOCATE(u)
      END IF      
      CALL SrvD_DestroyInput(u_interp, ErrStat2, ErrMsg2)
         CALL SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
   END SUBROUTINE Cleanup
      
END SUBROUTINE SrvD_UpdateStates
!----------------------------------------------------------------------------------------------------------------------------------
!> Routine for deciding if Bladed-style DLL controller should be called
SUBROUTINE DLL_controller_call(t, u, p, x, xd, z, OtherState, m, ErrStat, ErrMsg )
!..................................................................................................................................

   REAL(DbKi),                     INTENT(IN   )  :: t           !< Current simulation time in seconds
   TYPE(SrvD_InputType),           INTENT(IN   )  :: u           !< Inputs at t
   TYPE(SrvD_ParameterType),       INTENT(IN   )  :: p           !< Parameters
   TYPE(SrvD_ContinuousStateType), INTENT(IN   )  :: x           !< Continuous states at t
   TYPE(SrvD_DiscreteStateType),   INTENT(IN   )  :: xd          !< Discrete states at t
   TYPE(SrvD_ConstraintStateType), INTENT(IN   )  :: z           !< Constraint states at t
   TYPE(SrvD_OtherStateType),      INTENT(IN   )  :: OtherState  !< Other states at t
   TYPE(SrvD_MiscVarType),         INTENT(INOUT)  :: m           !< Misc (optimization) variables
   INTEGER(IntKi),                 INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                   INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None

   
   INTEGER(IntKi)                                 :: ErrStat2
   CHARACTER(ErrMsgLen)                           :: ErrMsg2
   CHARACTER(*), PARAMETER                        :: RoutineName = 'DLL_controller_call'


      ! Initialize ErrStat

   ErrStat = ErrID_None
   ErrMsg  = ""

   ! we should be calling this routine ONLY when the following statement is true:
   !IF ( p%UseBladedInterface ) THEN 
      
      IF ( .NOT. EqualRealNos( t - m%dll_data%DLL_DT, m%LastTimeCalled ) ) THEN
         IF (m%FirstWarn) THEN
            IF ( EqualRealNos( p%DT, m%dll_data%DLL_DT ) ) THEN ! This must be because we're doing a correction step or calling multiple times per time step
               CALL SetErrStat ( ErrID_Warn, 'BladedInterface option was designed for an explicit-loose '//&
               'coupling scheme. Using last calculated values from DLL on all subsequent calls until time is advanced. '//&
               'Warning will not be displayed again.', ErrStat, ErrMsg, RoutineName )
            ELSE ! this may be because of calling multiple times per time step, but most likely is because DT /= DLL_DT
               CALL SetErrStat ( ErrID_Warn, 'Using last calculated values from DLL on all subsequent calls until next DLL_DT has been reached. '//&
               'Warning will not be displayed again.', ErrStat, ErrMsg, RoutineName )
            END IF
            m%FirstWarn = .FALSE.
         END IF
      ELSE
         m%dll_data%PrevBlPitch(1:p%NumBl) = m%dll_data%BlPitchCom  ! used for linear ramp of delayed signal
         m%LastTimeCalled = t

         CALL BladedInterface_CalcOutput( t, u, p, m, ErrStat2, ErrMsg2 )
            CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
            
         m%dll_data%initialized = .true.
      END IF
      
   !END IF
   
END SUBROUTINE DLL_controller_call
!----------------------------------------------------------------------------------------------------------------------------------
!> Routine for computing outputs, used in both loose and tight coupling.
SUBROUTINE SrvD_CalcOutput( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg )
!..................................................................................................................................

   REAL(DbKi),                     INTENT(IN   )  :: t           !< Current simulation time in seconds
   TYPE(SrvD_InputType),           INTENT(IN   )  :: u           !< Inputs at t
   TYPE(SrvD_ParameterType),       INTENT(IN   )  :: p           !< Parameters
   TYPE(SrvD_ContinuousStateType), INTENT(IN   )  :: x           !< Continuous states at t
   TYPE(SrvD_DiscreteStateType),   INTENT(IN   )  :: xd          !< Discrete states at t
   TYPE(SrvD_ConstraintStateType), INTENT(IN   )  :: z           !< Constraint states at t
   TYPE(SrvD_OtherStateType),      INTENT(IN   )  :: OtherState  !< Other states at t
   TYPE(SrvD_OutputType),          INTENT(INOUT)  :: y           !< Outputs computed at t (Input only so that mesh con-
                                                                 !!   nectivity information does not have to be recalculated)
   TYPE(SrvD_MiscVarType),         INTENT(INOUT)  :: m           !< Misc (optimization) variables
   INTEGER(IntKi),                 INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                   INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None

      ! Local variables
   REAL(ReKi)                                     :: AllOuts(0:MaxOutPts)   ! All the the available output channels
   INTEGER(IntKi)                                 :: I                      ! Generic loop index
   INTEGER(IntKi)                                 :: K                      ! Blade index
   INTEGER(IntKi)                                 :: J                      ! Structural control instance at location
   INTEGER(IntKi)                                 :: ErrStat2
   CHARACTER(ErrMsgLen)                           :: ErrMsg2
   CHARACTER(*), PARAMETER                        :: RoutineName = 'SrvD_CalcOutput'
         
      ! Initialize ErrStat

   ErrStat = ErrID_None
   ErrMsg  = ""

      ! StrucCtrl
   do j=1,p%CompNStC       ! Nacelle
      CALL StC_CalcOutput( t, u%NStC(j), p%NStC(j), x%NStC(j), xd%NStC(j), z%NStC(j), OtherState%NStC(j), y%NStC(j), m%NStC(j), ErrStat2, ErrMsg2 )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   enddo
   do j=1,p%CompTStC       ! Tower
      CALL StC_CalcOutput( t, u%TStC(j), p%TStC(j), x%TStC(j), xd%TStC(j), z%TStC(j), OtherState%TStC(j), y%TStC(j), m%TStC(j), ErrStat2, ErrMsg2 )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   enddo
   do j=1,p%CompBStC       ! Blades
      CALL StC_CalcOutput( t, u%BStC(j), p%BStC(j), x%BStC(j), xd%BStC(j), z%BStC(j), OtherState%BStC(j), y%BStC(j), m%BStC(j), ErrStat2, ErrMsg2 )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   enddo
   do j=1,p%CompPtfmStC    ! Platform
      CALL StC_CalcOutput( t, u%PtfmStC(j), p%PtfmStC(j), x%PtfmStC(j), xd%PtfmStC(j), z%PtfmStC(j), OtherState%PtfmStC(j), y%PtfmStC(j), m%PtfmStC(j), ErrStat2, ErrMsg2 )
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
   enddo
   
   !...............................................................................................................................   
   ! Get the demanded values from the external Bladed dynamic link library, if necessary:
   !...............................................................................................................................   
   IF ( p%UseBladedInterface ) THEN

         ! Initialize the DLL controller in CalcOutput ONLY if it hasn't already been initialized in SrvD_UpdateStates
      IF (.NOT. m%dll_data%initialized) THEN
         CALL DLL_controller_call(t, u, p, x, xd, z, OtherState, m, ErrStat2, ErrMsg2 )
            CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      END IF
      
      !  Commanded Airfoil UserProp for blade (must be same units as given in AD15 airfoil tables)
      !  This is passed to AD15 to be interpolated with the airfoil table userprop column
      !  (might be used for airfoil flap angles for example)
      y%BlAirfoilCom(1:p%NumBl) = m%dll_data%BlAirfoilCom(1:p%NumBl)
      
      IF (ALLOCATED(y%SuperController)) THEN
         y%SuperController = m%dll_data%SCoutput
      END IF
      
   END IF
      
   !...............................................................................................................................   
   ! Compute the outputs
   !...............................................................................................................................   

      ! Torque control:
   CALL Torque_CalcOutput( t, u, p, x, xd, z, OtherState, y, m, ErrStat2, ErrMsg2 )      !  calculates ElecPwr, which Pitch_CalcOutput will use in the user pitch routine  
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      IF (ErrStat >= AbortErrLev) RETURN

      ! Pitch control:
   CALL Pitch_CalcOutput( t, u, p, x, xd, z, OtherState, y%BlPitchCom, y%ElecPwr, m, ErrStat2, ErrMsg2 )  
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      IF (ErrStat >= AbortErrLev) RETURN

      ! Yaw control: 
   CALL Yaw_CalcOutput( t, u, p, x, xd, z, OtherState, y, m,ErrStat2, ErrMsg2 )      
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      IF (ErrStat >= AbortErrLev) RETURN

      ! Tip brake control: 
   CALL TipBrake_CalcOutput( t, u, p, x, xd, z, OtherState, y, m, ErrStat2, ErrMsg2 )      
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      IF (ErrStat >= AbortErrLev) RETURN
   
      
   !...............................................................................................................................   
   ! Calculate all of the available output channels:
   !...............................................................................................................................   
      ! This is overwriting the values if it was called from UpdateStates, but they 
      ! should be the same and this sets the values if we called the DLL above.
   m%dll_data%ElecPwr_prev = y%ElecPwr
   m%dll_data%GenTrq_prev  = y%GenTrq
   
   !...............................................................................................................................   
   ! Calculate all of the available output channels:
   !...............................................................................................................................   
!   AllOuts(Time) = t    
   
   AllOuts(GenTq)   = 0.001*y%GenTrq
   AllOuts(GenPwr)  = 0.001*y%ElecPwr
   AllOuts(HSSBrTqC)= 0.001*y%HSSBrTrqC

   DO K=1,p%NumBl
      AllOuts( BlPitchC(K) )     = y%BlPitchCom(K)*R2D
      AllOuts( BlAirfoilC(K) )   = y%BlAirfoilCom(K)
   END DO

   AllOuts(YawMomCom) = -0.001*y%YawMom

   if (p%CompNStC>0)    call Set_NStC_Outs(     p, x%NStC,     m%NStC,     y%NStC,     AllOuts )
   if (p%CompTStC>0)    call Set_TStC_Outs(     p, x%TStC,     m%TStC,     y%TStC,     AllOuts )
   if (p%CompBStC>0)    call Set_BStC_Outs(     p, x%BStC,     m%BStC,     y%BStC,     AllOuts )
   if (p%CompPtfmStC>0) call Set_PtfmStC_Outs(  p, x%PtfmStC,  m%PtfmStC,  y%PtfmStC,  AllOuts )
  
   !...............................................................................................................................   
   ! Place the selected output channels into the WriteOutput(:) array with the proper sign:
   !...............................................................................................................................   

   DO I = 1,p%NumOuts  ! Loop through all selected output channels

      y%WriteOutput(I) = p%OutParam(I)%SignM * AllOuts( p%OutParam(I)%Indx )

   ENDDO             ! I - All selected output channels
   
   DO I = 1,p%NumOuts_DLL  ! Loop through all DLL logging channels
      y%WriteOutput(I+p%NumOuts) = m%dll_data%LogChannels( I )
   ENDDO
   
   RETURN
CONTAINS
   !---------------------------
   subroutine Set_NStC_Outs( p_SrvD, x, m, y, AllOuts )     ! Nacelle
      type(SrvD_ParameterType),                    intent(in   )  :: p_SrvD      !< Parameters
      type(StC_ContinuousStateType),   allocatable,intent(in   )  :: x(:)        !< Continuous states at t
      type(StC_MiscVarType),           allocatable,intent(in   )  :: m(:)        !< Misc (optimization) variables
      type(StC_OutputType),            allocatable,intent(in   )  :: y(:)        !< Outputs computed at Time
      real(ReKi),                                  intent(inout)  :: AllOuts(:)  ! All the the available output channels
      integer  :: i,j
      j=1
      if (allocated(x) .and. allocated(m) .and. allocated(y)) then
         do i=1,min(p_SrvD%CompNStC,MaxStC)                 ! in case we have more Nacelle StCs than the outputs are set for
            AllOuts(NStC_XQ( i)) = x(i)%StC_x(1,1)          ! x
            AllOuts(NStC_XQD(i)) = x(i)%StC_x(2,1)          ! x-dot
            AllOuts(NStC_YQ( i)) = x(i)%StC_x(3,1)          ! y
            AllOuts(NStC_YQD(i)) = x(i)%StC_x(4,1)          ! y-dot
            AllOuts(NStC_ZQ( i)) = x(i)%StC_x(5,1)          ! z
            AllOuts(NStC_ZQD(i)) = x(i)%StC_x(6,1)          ! z-dot
            AllOuts(NStC_Fxi(i)) = y(i)%Mesh(j)%Force(1,1)  ! only one mesh per NStC instance
            AllOuts(NStC_Fyi(i)) = y(i)%Mesh(j)%Force(2,1)  ! only one mesh per NStC instance
            AllOuts(NStC_Fzi(i)) = y(i)%Mesh(j)%Force(3,1)  ! only one mesh per NStC instance
            AllOuts(NStC_Mxi(i)) = y(i)%Mesh(j)%Moment(1,1) ! only one mesh per NStC instance
            AllOuts(NStC_Myi(i)) = y(i)%Mesh(j)%Moment(2,1) ! only one mesh per NStC instance
            AllOuts(NStC_Mzi(i)) = y(i)%Mesh(j)%Moment(3,1) ! only one mesh per NStC instance
            AllOuts(NStC_Fxn(i)) = m(i)%F_P(1,j)
            AllOuts(NStC_Fyn(i)) = m(i)%F_P(2,j)
            AllOuts(NStC_Fzn(i)) = m(i)%F_P(3,j)
            AllOuts(NStC_Mxn(i)) = m(i)%M_P(1,j)
            AllOuts(NStC_Myn(i)) = m(i)%M_P(2,j)
            AllOuts(NStC_Mzn(i)) = m(i)%M_P(3,j)
         enddo
      endif
   end subroutine Set_NStC_Outs
   !---------------------------
   subroutine Set_TStC_Outs( p_SrvD, x, m, y, AllOuts )     ! Tower
      type(SrvD_ParameterType),                    intent(in   )  :: p_SrvD      !< Parameters
      type(StC_ContinuousStateType),   allocatable,intent(in   )  :: x(:)        !< Continuous states at t
      type(StC_MiscVarType),           allocatable,intent(in   )  :: m(:)        !< Misc (optimization) variables
      type(StC_OutputType),            allocatable,intent(in   )  :: y(:)        !< Outputs computed at Time
      real(ReKi),                                  intent(inout)  :: AllOuts(:)  ! All the the available output channels
      integer  :: i,j
      j=1
      if (allocated(x) .and. allocated(m) .and. allocated(y)) then
         do i=1,min(p_SrvD%CompTStC,MaxStC)                 ! in case we have more Nacelle StCs than the outputs are set for
            AllOuts(TStC_XQ( i)) = x(i)%StC_x(1,1)          ! x
            AllOuts(TStC_XQD(i)) = x(i)%StC_x(2,1)          ! x-dot
            AllOuts(TStC_YQ( i)) = x(i)%StC_x(3,1)          ! y
            AllOuts(TStC_YQD(i)) = x(i)%StC_x(4,1)          ! y-dot
            AllOuts(TStC_ZQ( i)) = x(i)%StC_x(5,1)          ! z
            AllOuts(TStC_ZQD(i)) = x(i)%StC_x(6,1)          ! z-dot
            AllOuts(TStC_Fxi(i)) = y(i)%Mesh(j)%Force(1,1)  ! only one mesh per TStC instance
            AllOuts(TStC_Fyi(i)) = y(i)%Mesh(j)%Force(2,1)  ! only one mesh per TStC instance
            AllOuts(TStC_Fzi(i)) = y(i)%Mesh(j)%Force(3,1)  ! only one mesh per TStC instance
            AllOuts(TStC_Mxi(i)) = y(i)%Mesh(j)%Moment(1,1) ! only one mesh per TStC instance
            AllOuts(TStC_Myi(i)) = y(i)%Mesh(j)%Moment(2,1) ! only one mesh per TStC instance
            AllOuts(TStC_Mzi(i)) = y(i)%Mesh(j)%Moment(3,1) ! only one mesh per TStC instance
            AllOuts(TStC_Fxn(i)) = m(i)%F_P(1,j)
            AllOuts(TStC_Fyn(i)) = m(i)%F_P(2,j)
            AllOuts(TStC_Fzn(i)) = m(i)%F_P(3,j)
            AllOuts(TStC_Mxn(i)) = m(i)%M_P(1,j)
            AllOuts(TStC_Myn(i)) = m(i)%M_P(2,j)
            AllOuts(TStC_Mzn(i)) = m(i)%M_P(3,j)
         enddo
      endif
   end subroutine Set_TStC_Outs
   !---------------------------
   subroutine Set_BStC_Outs( p_SrvD, x, m, y, AllOuts )        ! Blades
      type(SrvD_ParameterType),                    intent(in   )  :: p_SrvD      !< Parameters
      type(StC_ContinuousStateType),   allocatable,intent(in   )  :: x(:)        !< Continuous states at t
      type(StC_MiscVarType),           allocatable,intent(in   )  :: m(:)        !< Misc (optimization) variables
      type(StC_OutputType),            allocatable,intent(in   )  :: y(:)        !< Outputs computed at Time
      real(ReKi),                                  intent(inout)  :: AllOuts(:)  ! All the the available output channels
      integer  :: i,j
      if (allocated(x) .and. allocated(m) .and. allocated(y)) then
         do j=1,min(p%NumBl,MaxBlOuts)
            do i=1,min(p_SrvD%CompBStC,MaxStC)                 ! in case we have more Nacelle StCs than the outputs are set for
               AllOuts(BStC_XQ( i,j)) = x(i)%StC_x(1,j)          ! x
               AllOuts(BStC_XQD(i,j)) = x(i)%StC_x(2,j)          ! x-dot
               AllOuts(BStC_YQ( i,j)) = x(i)%StC_x(3,j)          ! y
               AllOuts(BStC_YQD(i,j)) = x(i)%StC_x(4,j)          ! y-dot
               AllOuts(BStC_ZQ( i,j)) = x(i)%StC_x(5,j)          ! z
               AllOuts(BStC_ZQD(i,j)) = x(i)%StC_x(6,j)          ! z-dot
               AllOuts(BStC_Fxi(i,j)) = y(i)%Mesh(j)%Force(1,1)  ! only one mesh per BStC instance
               AllOuts(BStC_Fyi(i,j)) = y(i)%Mesh(j)%Force(2,1)  ! only one mesh per BStC instance
               AllOuts(BStC_Fzi(i,j)) = y(i)%Mesh(j)%Force(3,1)  ! only one mesh per BStC instance
               AllOuts(BStC_Mxi(i,j)) = y(i)%Mesh(j)%Moment(1,1) ! only one mesh per BStC instance
               AllOuts(BStC_Myi(i,j)) = y(i)%Mesh(j)%Moment(2,1) ! only one mesh per BStC instance
               AllOuts(BStC_Mzi(i,j)) = y(i)%Mesh(j)%Moment(3,1) ! only one mesh per BStC instance
               AllOuts(BStC_Fxn(i,j)) = m(i)%F_P(1,j)
               AllOuts(BStC_Fyn(i,j)) = m(i)%F_P(2,j)
               AllOuts(BStC_Fzn(i,j)) = m(i)%F_P(3,j)
               AllOuts(BStC_Mxn(i,j)) = m(i)%M_P(1,j)
               AllOuts(BStC_Myn(i,j)) = m(i)%M_P(2,j)
               AllOuts(BStC_Mzn(i,j)) = m(i)%M_P(3,j)
            enddo
         enddo
      endif
   end subroutine Set_BStC_Outs
   !---------------------------
   subroutine Set_PtfmStC_Outs( p_SrvD, x, m, y, AllOuts )     ! Platform 
      type(SrvD_ParameterType),                    intent(in   )  :: p_SrvD      !< Parameters
      type(StC_ContinuousStateType),   allocatable,intent(in   )  :: x(:)        !< Continuous states at t
      type(StC_MiscVarType),           allocatable,intent(in   )  :: m(:)        !< Misc (optimization) variables
      type(StC_OutputType),            allocatable,intent(in   )  :: y(:)        !< Outputs computed at Time
      real(ReKi),                                  intent(inout)  :: AllOuts(:)  ! All the the available output channels
      integer  :: i,j
      j=1
      if (allocated(x) .and. allocated(m) .and. allocated(y)) then
         do i=1,min(p_SrvD%CompPtfmStC,MaxStC)                 ! in case we have more Nacelle StCs than the outputs are set for
            AllOuts(PtfmStC_XQ( i)) = x(i)%StC_x(1,1)          ! x
            AllOuts(PtfmStC_XQD(i)) = x(i)%StC_x(2,1)          ! x-dot
            AllOuts(PtfmStC_YQ( i)) = x(i)%StC_x(3,1)          ! y
            AllOuts(PtfmStC_YQD(i)) = x(i)%StC_x(4,1)          ! y-dot
            AllOuts(PtfmStC_ZQ( i)) = x(i)%StC_x(5,1)          ! z
            AllOuts(PtfmStC_ZQD(i)) = x(i)%StC_x(6,1)          ! z-dot
            AllOuts(PtfmStC_Fxi(i)) = y(i)%Mesh(j)%Force(1,1)  ! only one mesh per PtfmStC instance
            AllOuts(PtfmStC_Fyi(i)) = y(i)%Mesh(j)%Force(2,1)  ! only one mesh per PtfmStC instance
            AllOuts(PtfmStC_Fzi(i)) = y(i)%Mesh(j)%Force(3,1)  ! only one mesh per PtfmStC instance
            AllOuts(PtfmStC_Mxi(i)) = y(i)%Mesh(j)%Moment(1,1) ! only one mesh per PtfmStC instance
            AllOuts(PtfmStC_Myi(i)) = y(i)%Mesh(j)%Moment(2,1) ! only one mesh per PtfmStC instance
            AllOuts(PtfmStC_Mzi(i)) = y(i)%Mesh(j)%Moment(3,1) ! only one mesh per PtfmStC instance
            AllOuts(PtfmStC_Fxn(i)) = m(i)%F_P(1,j)
            AllOuts(PtfmStC_Fyn(i)) = m(i)%F_P(2,j)
            AllOuts(PtfmStC_Fzn(i)) = m(i)%F_P(3,j)
            AllOuts(PtfmStC_Mxn(i)) = m(i)%M_P(1,j)
            AllOuts(PtfmStC_Myn(i)) = m(i)%M_P(2,j)
            AllOuts(PtfmStC_Mzn(i)) = m(i)%M_P(3,j)
         enddo
      endif
   end subroutine Set_PtfmStC_Outs
   !---------------------------
END SUBROUTINE SrvD_CalcOutput
!----------------------------------------------------------------------------------------------------------------------------------
!> Tight coupling routine for computing derivatives of continuous states.
SUBROUTINE SrvD_CalcContStateDeriv( t, u, p, x, xd, z, OtherState, m, dxdt, ErrStat, ErrMsg )
!..................................................................................................................................

      REAL(DbKi),                     INTENT(IN   )  :: t           !< Current simulation time in seconds
      TYPE(SrvD_InputType),           INTENT(IN   )  :: u           !< Inputs at t
      TYPE(SrvD_ParameterType),       INTENT(IN   )  :: p           !< Parameters
      TYPE(SrvD_ContinuousStateType), INTENT(IN   )  :: x           !< Continuous states at t
      TYPE(SrvD_DiscreteStateType),   INTENT(IN   )  :: xd          !< Discrete states at t
      TYPE(SrvD_ConstraintStateType), INTENT(IN   )  :: z           !< Constraint states at t
      TYPE(SrvD_OtherStateType),      INTENT(IN   )  :: OtherState  !< Other states at t
      TYPE(SrvD_MiscVarType),         INTENT(INOUT)  :: m           !< Misc (optimization) variables
      TYPE(SrvD_ContinuousStateType), INTENT(  OUT)  :: dxdt        !< Continuous state derivatives at t
      INTEGER(IntKi),                 INTENT(  OUT)  :: ErrStat     !< Error status of the operation
      CHARACTER(*),                   INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None

      CHARACTER(*), PARAMETER                        :: RoutineName = 'SrvD_CalcContStateDeriv'
      INTEGER(IntKi)                                 :: ErrStat2
      CHARACTER(ErrMsgLen)                           :: ErrMsg2
      integer(IntKi)                                 :: j           ! Index to instance of StC for location

         ! Initialize ErrStat

      ErrStat = ErrID_None
      ErrMsg  = ""


         ! Compute the first time derivatives of the continuous states here:

      dxdt%DummyContState = 0.0_ReKi

         ! StrucCtrl
      do j=1,p%CompNStC       ! Nacelle
         CALL StC_CalcContStateDeriv( t, u%NStC(j), p%NStC(j), x%NStC(j), xd%NStC(j), z%NStC(j), OtherState%NStC(j), m%NStC(j), dxdt%NStC(j), ErrStat2, ErrMsg2 )
         call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
      enddo
      do j=1,p%CompTStC       ! Tower
         CALL StC_CalcContStateDeriv( t, u%TStC(j), p%TStC(j), x%TStC(j), xd%TStC(j), z%TStC(j), OtherState%TStC(j), m%TStC(j), dxdt%TStC(j), ErrStat2, ErrMsg2 )
         call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
      enddo
      do j=1,p%CompBStC       ! Blade
         CALL StC_CalcContStateDeriv( t, u%BStC(j), p%BStC(j), x%BStC(j), xd%BStC(j), z%BStC(j), OtherState%BStC(j), m%BStC(j), dxdt%BStC(j), ErrStat2, ErrMsg2 )
         call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
      enddo
      do j=1,p%CompPtfmStC    ! Platform
         CALL StC_CalcContStateDeriv( t, u%PtfmStC(j), p%PtfmStC(j), x%PtfmStC(j), xd%PtfmStC(j), z%PtfmStC(j), OtherState%PtfmStC(j), m%PtfmStC(j), dxdt%PtfmStC(j), ErrStat2, ErrMsg2 )
         call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
      enddo

      
END SUBROUTINE SrvD_CalcContStateDeriv
!----------------------------------------------------------------------------------------------------------------------------------
!> Tight coupling routine for updating discrete states.
SUBROUTINE SrvD_UpdateDiscState( t, u, p, x, xd, z, OtherState, m, ErrStat, ErrMsg )
!..................................................................................................................................

      REAL(DbKi),                     INTENT(IN   )  :: t           !< Current simulation time in seconds
      TYPE(SrvD_InputType),           INTENT(IN   )  :: u           !< Inputs at t
      TYPE(SrvD_ParameterType),       INTENT(IN   )  :: p           !< Parameters
      TYPE(SrvD_ContinuousStateType), INTENT(IN   )  :: x           !< Continuous states at t
      TYPE(SrvD_DiscreteStateType),   INTENT(INOUT)  :: xd          !< Input: Discrete states at t;
                                                                    !!   Output: Discrete states at t + Interval
      TYPE(SrvD_ConstraintStateType), INTENT(IN   )  :: z           !< Constraint states at t
      TYPE(SrvD_OtherStateType),      INTENT(IN   )  :: OtherState  !< Other states at t
      TYPE(SrvD_MiscVarType),         INTENT(INOUT)  :: m           !< Misc (optimization) variables
      INTEGER(IntKi),                 INTENT(  OUT)  :: ErrStat     !< Error status of the operation
      CHARACTER(*),                   INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None

      CHARACTER(*), PARAMETER                        :: RoutineName = 'SrvD_UpdateDiscState'
      INTEGER(IntKi)                                 :: ErrStat2
      CHARACTER(ErrMsgLen)                           :: ErrMsg2
      integer(IntKi)                                 :: j           ! Index to instance of StC for location

         ! Initialize ErrStat

      ErrStat = ErrID_None
      ErrMsg  = ""

      
      select case (p%TrimCase)
      case (TrimCase_yaw)
         xd%CtrlOffset = xd%CtrlOffset + (u%RotSpeed - p%RotSpeedRef) * sign(p%TrimGain, p%YawNeut + xd%CtrlOffset)
      case (TrimCase_torque, TrimCase_pitch)
         xd%CtrlOffset = xd%CtrlOffset + (u%RotSpeed - p%RotSpeedRef) * p%TrimGain
!     case default
!        xd%CtrlOffset = 0.0_ReKi ! same as initialized value
      end select
      

      !xd%BlPitchFilter = p%BlAlpha * xd%BlPitchFilter + (1.0_ReKi - p%BlAlpha) * u%BlPitch
   
      !if ( p%PCMode == ControlMode_DLL ) then
      !   if ( p%DLL_Ramp ) then
      !      temp = (t - m%LastTimeCalled) / m%dll_data%DLL_DT                            
      !      temp = m%dll_data%PrevBlPitch(1:p%NumBl) + &
      !               temp * ( m%dll_data%BlPitchCom(1:p%NumBl) - m%dll_data%PrevBlPitch(1:p%NumBl) )
      !   else
      !      temp = m%dll_data%BlPitchCom(1:p%NumBl)
      !   end if
      !   
      !   xd%BlPitchFilter = p%BlAlpha * xd%BlPitchFilter + (1.0_ReKi - p%BlAlpha) * temp
      !else
      !   
      !end if
      

      ! Update discrete states for StrucCtrl       --- StC does not currently support this
!  do j=1,p%CompNStC       ! Nacelle
!     CALL StC_UpdateDiscState( t, u%NStC(j), p%NStC(j), x%NStC(j), xd%NStC(j), z%NStC(j), OtherState%NStC(j), m%NStC(j), ErrStat, ErrMsg )
!     call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
!  enddo
!  do j=1,p%CompTStC       ! tower
!     CALL StC_UpdateDiscState( t, u%TStC(j), p%TStC(j), x%TStC(j), xd%TStC(j), z%TStC(j), OtherState%TStC(j), m%TStC(j), ErrStat, ErrMsg )
!     call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
!  enddo
!  do j=1,p%CompBStC       ! Blade
!     CALL StC_UpdateDiscState( t, u%BStC(j), p%BStC(j), x%BStC(j), xd%BStC(j), z%BStC(j), OtherState%BStC(j), m%BStC(j), ErrStat, ErrMsg )
!     call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
!  enddo
!  do j=1,p%CompPtfmStC    ! Platform
!     CALL StC_UpdateDiscState( t, u%PtfmStC(j), p%PtfmStC(j), x%PtfmStC(j), xd%PtfmStC(j), z%PtfmStC(j), OtherState%PtfmStC(j), m%PtfmStC(j), ErrStat, ErrMsg )
!     call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
!  enddo
         
END SUBROUTINE SrvD_UpdateDiscState
!----------------------------------------------------------------------------------------------------------------------------------
!> Tight coupling routine for solving for the residual of the constraint state equations.
SUBROUTINE SrvD_CalcConstrStateResidual( t, u, p, x, xd, z, OtherState, m, z_residual, ErrStat, ErrMsg )
!..................................................................................................................................

   REAL(DbKi),                     INTENT(IN   )  :: t           !< Current simulation time in seconds
   TYPE(SrvD_InputType),           INTENT(IN   )  :: u           !< Inputs at t
   TYPE(SrvD_ParameterType),       INTENT(IN   )  :: p           !< Parameters
   TYPE(SrvD_ContinuousStateType), INTENT(IN   )  :: x           !< Continuous states at t
   TYPE(SrvD_DiscreteStateType),   INTENT(IN   )  :: xd          !< Discrete states at t
   TYPE(SrvD_ConstraintStateType), INTENT(IN   )  :: z           !< Constraint states at t (possibly a guess)
   TYPE(SrvD_OtherStateType),      INTENT(IN   )  :: OtherState  !< Other states at t
   TYPE(SrvD_MiscVarType),         INTENT(INOUT)  :: m           !< Misc (optimization) variables
   TYPE(SrvD_ConstraintStateType), INTENT(  OUT)  :: z_residual  !< Residual of the constraint state equations using
                                                                 !!     the input values described above
   INTEGER(IntKi),                 INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                   INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None

   CHARACTER(*), PARAMETER                        :: RoutineName = 'SrvD_CalcConstrStateResidual'
   INTEGER(IntKi)                                 :: ErrStat2
   CHARACTER(ErrMsgLen)                           :: ErrMsg2
   integer(IntKi)                                 :: j           ! Index to instance of StC for location

      ! Initialize ErrStat

   ErrStat = ErrID_None
   ErrMsg  = ""


      ! Solve for the constraint states for StrucCtrl    --- StC does not currently support this
!  do j=1,p%CompNStC       ! Nacelle
!     CALL StC_CalcConstrStateResidual( t, u%NStC(j), p%NStC(j), x%NStC(j), xd%NStC(j), z%NStC(j), OtherState%NStC(j), m%NStC(j), z_residual%NStC(j), ErrStat, ErrMsg )
!     call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
!  enddo
!  do j=1,p%CompTStC       ! Tower
!     CALL StC_CalcConstrStateResidual( t, u%TStC(j), p%TStC(j), x%TStC(j), xd%TStC(j), z%TStC(j), OtherState%TStC(j), m%TStC(j), z_residual%TStC(j), ErrStat, ErrMsg )
!     call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
!  enddo
!  do j=1,p%CompBStC       ! Blade
!     CALL StC_CalcConstrStateResidual( t, u%BStC(j), p%BStC(j), x%BStC(j), xd%BStC(j), z%BStC(j), OtherState%BStC(j), m%BStC(j), z_residual%BStC(j), ErrStat, ErrMsg )
!     call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
!  enddo
!  do j=1,p%CompPtfmStC    ! Platform
!     CALL StC_CalcConstrStateResidual( t, u%PtfmStC(j), p%PtfmStC(j), x%PtfmStC(j), xd%PtfmStC(j), z%PtfmStC(j), OtherState%PtfmStC(j), m%PtfmStC(j), z_residual%PtfmStC(j), ErrStat, ErrMsg )
!     call SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
!  enddo

   z_residual%DummyConstrState = 0.0_ReKi

END SUBROUTINE SrvD_CalcConstrStateResidual


!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
! ###### The following four routines are Jacobian routines for linearization capabilities #######
!----------------------------------------------------------------------------------------------------------------------------------
!> Routine to compute the Jacobians of the output (Y), continuous- (X), discrete- (Xd), and constraint-state (Z) functions
!! with respect to the inputs (u). The partial derivative dY/du is returned.
SUBROUTINE SrvD_JacobianPInput( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg, dYdu, dXdu, dXddu, dZdu )
!..................................................................................................................................

   REAL(DbKi),                             INTENT(IN   )           :: t          !< Time in seconds at operating point
   TYPE(SrvD_InputType),                   INTENT(IN   )           :: u          !< Inputs at operating point (may change to inout if a mesh copy is required)
   TYPE(SrvD_ParameterType),               INTENT(IN   )           :: p          !< Parameters
   TYPE(SrvD_ContinuousStateType),         INTENT(IN   )           :: x          !< Continuous states at operating point
   TYPE(SrvD_DiscreteStateType),           INTENT(IN   )           :: xd         !< Discrete states at operating point
   TYPE(SrvD_ConstraintStateType),         INTENT(IN   )           :: z          !< Constraint states at operating point
   TYPE(SrvD_OtherStateType),              INTENT(IN   )           :: OtherState !< Other states at operating point
   TYPE(SrvD_OutputType),                  INTENT(IN   )           :: y          !< Output (change to inout if a mesh copy is required);
                                                                                 !!   Output fields are not used by this routine, but type is   
                                                                                 !!   available here so that mesh parameter information (i.e.,  
                                                                                 !!   connectivity) does not have to be recalculated for dYdu.
   TYPE(SrvD_MiscVarType),                 INTENT(INOUT)           :: m          !< Misc/optimization variables
   INTEGER(IntKi),                         INTENT(  OUT)           :: ErrStat    !< Error status of the operation
   CHARACTER(*),                           INTENT(  OUT)           :: ErrMsg     !< Error message if ErrStat /= ErrID_None
   REAL(R8Ki), ALLOCATABLE, OPTIONAL,      INTENT(INOUT)           :: dYdu(:,:)  !< Partial derivatives of output functions
                                                                                 !!   (Y) with respect to the inputs (u) [intent in to avoid deallocation]
   REAL(R8Ki), ALLOCATABLE, OPTIONAL,      INTENT(INOUT)           :: dXdu(:,:)  !< Partial derivatives of continuous state
                                                                                 !!   functions (X) with respect to inputs (u) [intent in to avoid deallocation]
   REAL(R8Ki), ALLOCATABLE, OPTIONAL,      INTENT(INOUT)           :: dXddu(:,:) !< Partial derivatives of discrete state 
                                                                                 !!   functions (Xd) with respect to inputs (u) [intent in to avoid deallocation]
   REAL(R8Ki), ALLOCATABLE, OPTIONAL,      INTENT(INOUT)           :: dZdu(:,:)  !< Partial derivatives of constraint state
                                                                                 !!   functions (Z) with respect to inputs (u) [intent in to avoid deallocation]

      ! local variables
   REAL(R8Ki)                                                      :: AllOuts(3,1:MaxOutPts) ! All the the available output channels
   REAL(R8Ki)                                                      :: GenTrq_du, ElecPwr_du  ! derivatives of generator torque and electrical power w.r.t. u%HSS_SPD
   INTEGER(IntKi)                                                  :: I                      ! Generic loop index
   INTEGER(IntKi)                                                  :: ErrStat2               ! Error status of the operation
   CHARACTER(ErrMsgLen)                                            :: ErrMsg2                ! Error message if ErrStat /= ErrID_None
   CHARACTER(*), PARAMETER                                         :: RoutineName = 'SrvD_JacobianPInput'

   
      ! Initialize ErrStat

   ErrStat = ErrID_None
   ErrMsg  = ''

   
      ! Calculate the partial derivative of the output functions (Y) with respect to the inputs (u) here:

   IF ( PRESENT( dYdu ) ) THEN
      
      !> \f{equation}{ \frac{\partial Y}{\partial u} = \begin{bmatrix} 
      !! \frac{\partial Y_{BlPitchCom_1}}{\partial u_{Yaw}}  & \frac{\partial Y_{BlPitchCom_1}}{\partial u_{YawRate}}  & \frac{\partial Y_{BlPitchCom_1}}{\partial u_{HSS\_Spd}} \\
      !! \frac{\partial Y_{BlPitchCom_2}}{\partial u_{Yaw}}  & \frac{\partial Y_{BlPitchCom_2}}{\partial u_{YawRate}}  & \frac{\partial Y_{BlPitchCom_2}}{\partial u_{HSS\_Spd}} \\
      !! \frac{\partial Y_{BlPitchCom_3}}{\partial u_{Yaw}}  & \frac{\partial Y_{BlPitchCom_3}}{\partial u_{YawRate}}  & \frac{\partial Y_{BlPitchCom_3}}{\partial u_{HSS\_Spd}} \\
      !! \frac{\partial Y_{YawMom}}{\partial u_{Yaw}}        & \frac{\partial Y_{YawMom}}{\partial u_{YawRate}}        & \frac{\partial Y_{YawMom}}{\partial u_{HSS\_Spd}} \\
      !! \frac{\partial Y_{GenTrq}}{\partial u_{Yaw}}        & \frac{\partial Y_{GenTrq}}{\partial u_{YawRate}}        & \frac{\partial Y_{GenTrq}}{\partial u_{HSS\_Spd}} \\
      !! \frac{\partial Y_{ElecPwr}}{\partial u_{Yaw}}       & \frac{\partial Y_{ElecPwr}}{\partial u_{YawRate}}       & \frac{\partial Y_{ElecPwr}}{\partial u_{HSS\_Spd}} \\
      !! \frac{\partial Y_{WriteOutput_i}}{\partial u_{Yaw}} & \frac{\partial Y_{WriteOutput_i}}{\partial u_{YawRate}} & \frac{\partial Y_{WriteOutput_i}}{\partial u_{HSS\_Spd}} \end{bmatrix}
      !! = \begin{bmatrix} 
      !! 0 & 0 & 0 \\
      !! 0 & 0 & 0 \\
      !! 0 & 0 & 0 \\
      !! \frac{\partial Y_{YawMom}}{\partial u_{Yaw}} & \frac{\partial Y_{YawMom}}{\partial u_{YawRate}} & 0 \\
      !! 0 & 0 & \frac{\partial Y_{GenTrq}}{\partial u_{HSS\_Spd}} \\
      !! 0 & 0 & \frac{\partial Y_{ElecPwr}}{\partial u_{HSS\_Spd}} \\
      !! \frac{\partial Y_{WriteOutput_i}}{\partial u_{Yaw}} & \frac{\partial Y_{WriteOutput_i}}{\partial u_{YawRate}} & \frac{\partial Y_{WriteOutput_i}}{\partial u_{HSS\_Spd}} \end{bmatrix}
      !!\f}      

      
      ! Note this is similiar to SrvD_CalcOutput
      
      if (.not. allocated(dYdu)) then
         call allocAry(dYdu, SrvD_Indx_Y_WrOutput+p%NumOuts, 3, 'dYdu', ErrStat2, ErrMsg2)
         call SetErrStat(ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName)
      end if
      dYdu = 0.0_R8Ki
             
   
      !   ! Torque control:
      !> Compute
      !> \f$ \frac{\partial Y_{GenTrq}}{\partial u_{HSS\_Spd}} \f$ and
      !> \f$ \frac{\partial Y_{ElecPwr}}{\partial u_{HSS\_Spd}} \f$ in servodyn::torque_jacobianpinput.
      call Torque_JacobianPInput( t, u, p, x, xd, z, OtherState, m, GenTrq_du, ElecPwr_du, ErrStat, ErrMsg )      !   CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF (ErrStat >= AbortErrLev) RETURN
         dYdu(SrvD_Indx_Y_GenTrq, Indx_u_HSS_Spd)  = GenTrq_du
         dYdu(SrvD_Indx_Y_ElecPwr,Indx_u_HSS_Spd)  = ElecPwr_du

            
         ! Pitch control:
      !> \f$ \frac{\partial Y_{BlPitchCom_k}}{\partial u} = 0 \f$
                  
         ! Yaw control: 
      !> \f$ \frac{\partial Y_{YawMom}}{\partial u_{Yaw}} = -p\%YawSpr \f$
      dYdu(SrvD_Indx_Y_YawMom,Indx_u_Yaw) = -p%YawSpr ! from Yaw_CalcOutput
      !> \f$ \frac{\partial Y_{YawMom}}{\partial u_{YawRate}} = -p\%YawDamp \f$
      dYdu(SrvD_Indx_Y_YawMom,Indx_u_YawRate) = -p%YawDamp   ! from Yaw_CalcOutput

         
         !.........................................................................................................................   
         ! Calculate all of the available output channels (because they repeat for the derivative) here:
         !.........................................................................................................................   
      AllOuts = 0.0_R8Ki ! all variables not specified below are zeros (either constant or disabled):
         
      AllOuts(:, GenTq)     =  0.001_R8Ki*dYdu(SrvD_Indx_Y_GenTrq,:)
      AllOuts(:, GenPwr)    =  0.001_R8Ki*dYdu(SrvD_Indx_Y_ElecPwr,:)
      AllOuts(:, YawMomCom) = -0.001_R8Ki*dYdu(SrvD_Indx_Y_YawMom,:)
      
      !...............................................................................................................................   
      ! Place the selected output channels into the WriteOutput(:) portion of the jacobian with the proper sign:
      !...............................................................................................................................   
      
      DO I = 1,p%NumOuts  ! Loop through all selected output channels      
         dYdu(I+SrvD_Indx_Y_WrOutput,:) = p%OutParam(I)%SignM * AllOuts( :, p%OutParam(I)%Indx )      
      ENDDO             ! I - All selected output channels
               
   END IF

   IF ( PRESENT( dXdu ) ) THEN
      if (allocated(dXdu)) deallocate(dXdu)
   END IF

   IF ( PRESENT( dXddu ) ) THEN
      if (allocated(dXddu)) deallocate(dXddu)
   END IF

   IF ( PRESENT( dZdu ) ) THEN
      if (allocated(dZdu)) deallocate(dZdu)
   END IF


END SUBROUTINE SrvD_JacobianPInput
!----------------------------------------------------------------------------------------------------------------------------------
!> Routine to compute the Jacobians of the output (Y), continuous- (X), discrete- (Xd), and constraint-state (Z) functions
!! with respect to the continuous states (x). The partial derivatives dY/dx, dX/dx, dXd/dx, and DZ/dx are returned.
!! Note SrvD does not have continuous states, so these are not set.
SUBROUTINE SrvD_JacobianPContState( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg, dYdx, dXdx, dXddx, dZdx )
!..................................................................................................................................

   REAL(DbKi),                             INTENT(IN   )           :: t          !< Time in seconds at operating point
   TYPE(SrvD_InputType),                   INTENT(IN   )           :: u          !< Inputs at operating point (may change to inout if a mesh copy is required)
   TYPE(SrvD_ParameterType),               INTENT(IN   )           :: p          !< Parameters
   TYPE(SrvD_ContinuousStateType),         INTENT(IN   )           :: x          !< Continuous states at operating point
   TYPE(SrvD_DiscreteStateType),           INTENT(IN   )           :: xd         !< Discrete states at operating point
   TYPE(SrvD_ConstraintStateType),         INTENT(IN   )           :: z          !< Constraint states at operating point
   TYPE(SrvD_OtherStateType),              INTENT(IN   )           :: OtherState !< Other states at operating point
   TYPE(SrvD_OutputType),                  INTENT(IN   )           :: y          !< Output (change to inout if a mesh copy is required);
                                                                                 !!   Output fields are not used by this routine, but type is   
                                                                                 !!   available here so that mesh parameter information (i.e.,  
                                                                                 !!   connectivity) does not have to be recalculated for dYdx.
   TYPE(SrvD_MiscVarType),                 INTENT(INOUT)           :: m          !< Misc/optimization variables
   INTEGER(IntKi),                         INTENT(  OUT)           :: ErrStat    !< Error status of the operation
   CHARACTER(*),                           INTENT(  OUT)           :: ErrMsg     !< Error message if ErrStat /= ErrID_None
   REAL(R8Ki), ALLOCATABLE, OPTIONAL,      INTENT(INOUT)           :: dYdx(:,:)  !< Partial derivatives of output functions
                                                                                 !!   (Y) with respect to the continuous
                                                                                 !!   states (x) [intent in to avoid deallocation]
   REAL(R8Ki), ALLOCATABLE, OPTIONAL,      INTENT(INOUT)           :: dXdx(:,:)  !< Partial derivatives of continuous state
                                                                                 !!   functions (X) with respect to
                                                                                 !!   the continuous states (x) [intent in to avoid deallocation]
   REAL(R8Ki), ALLOCATABLE, OPTIONAL,      INTENT(INOUT)           :: dXddx(:,:) !< Partial derivatives of discrete state
                                                                                 !!   functions (Xd) with respect to
                                                                                 !!   the continuous states (x) [intent in to avoid deallocation]
   REAL(R8Ki), ALLOCATABLE, OPTIONAL,      INTENT(INOUT)           :: dZdx(:,:)  !< Partial derivatives of constraint state
                                                                                 !!   functions (Z) with respect to
                                                                                 !!   the continuous states (x) [intent in to avoid deallocation]


      ! Initialize ErrStat

   ErrStat = ErrID_None
   ErrMsg  = ''



   IF ( PRESENT( dYdx ) ) THEN

      ! Calculate the partial derivative of the output functions (Y) with respect to the continuous states (x) here:

      ! allocate and set dYdx

   END IF

   IF ( PRESENT( dXdx ) ) THEN

      ! Calculate the partial derivative of the continuous state functions (X) with respect to the continuous states (x) here:

      ! allocate and set dXdx

   END IF

   IF ( PRESENT( dXddx ) ) THEN

      ! Calculate the partial derivative of the discrete state functions (Xd) with respect to the continuous states (x) here:

      ! allocate and set dXddx

   END IF

   IF ( PRESENT( dZdx ) ) THEN


      ! Calculate the partial derivative of the constraint state functions (Z) with respect to the continuous states (x) here:

      ! allocate and set dZdx

   END IF


END SUBROUTINE SrvD_JacobianPContState
!----------------------------------------------------------------------------------------------------------------------------------
!> Routine to compute the Jacobians of the output (Y), continuous- (X), discrete- (Xd), and constraint-state (Z) functions
!! with respect to the discrete states (xd). The partial derivatives dY/dxd, dX/dxd, dXd/dxd, and DZ/dxd are returned.
!! Note SrvD does not have discrete states, so these are not set.
SUBROUTINE SrvD_JacobianPDiscState( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg, dYdxd, dXdxd, dXddxd, dZdxd )
!..................................................................................................................................

   REAL(DbKi),                             INTENT(IN   )           :: t          !< Time in seconds at operating point
   TYPE(SrvD_InputType),                   INTENT(IN   )           :: u          !< Inputs at operating point (may change to inout if a mesh copy is required)
   TYPE(SrvD_ParameterType),               INTENT(IN   )           :: p          !< Parameters
   TYPE(SrvD_ContinuousStateType),         INTENT(IN   )           :: x          !< Continuous states at operating point
   TYPE(SrvD_DiscreteStateType),           INTENT(IN   )           :: xd         !< Discrete states at operating point
   TYPE(SrvD_ConstraintStateType),         INTENT(IN   )           :: z          !< Constraint states at operating point
   TYPE(SrvD_OtherStateType),              INTENT(IN   )           :: OtherState !< Other states at operating point
   TYPE(SrvD_OutputType),                  INTENT(IN   )           :: y          !< Output (change to inout if a mesh copy is required);
                                                                                 !!   Output fields are not used by this routine, but type is   
                                                                                 !!   available here so that mesh parameter information (i.e.,  
                                                                                 !!   connectivity) does not have to be recalculated for dYdxd.
   TYPE(SrvD_MiscVarType),                 INTENT(INOUT)           :: m          !< Misc/optimization variables
   INTEGER(IntKi),                         INTENT(  OUT)           :: ErrStat    !< Error status of the operation
   CHARACTER(*),                           INTENT(  OUT)           :: ErrMsg     !< Error message if ErrStat /= ErrID_None
   REAL(R8Ki), ALLOCATABLE, OPTIONAL,      INTENT(INOUT)           :: dYdxd(:,:) !< Partial derivatives of output functions
                                                                                 !!  (Y) with respect to the discrete
                                                                                 !!  states (xd) [intent in to avoid deallocation]
   REAL(R8Ki), ALLOCATABLE, OPTIONAL,      INTENT(INOUT)           :: dXdxd(:,:) !< Partial derivatives of continuous state
                                                                                 !!   functions (X) with respect to the
                                                                                 !!   discrete states (xd) [intent in to avoid deallocation]
   REAL(R8Ki), ALLOCATABLE, OPTIONAL,      INTENT(INOUT)           :: dXddxd(:,:)!< Partial derivatives of discrete state
                                                                                 !!   functions (Xd) with respect to the
                                                                                 !!   discrete states (xd) [intent in to avoid deallocation]
   REAL(R8Ki), ALLOCATABLE, OPTIONAL,      INTENT(INOUT)           :: dZdxd(:,:) !< Partial derivatives of constraint state
                                                                                 !!   functions (Z) with respect to the
                                                                                 !!   discrete states (xd) [intent in to avoid deallocation]


      ! Initialize ErrStat

   ErrStat = ErrID_None
   ErrMsg  = ''


   IF ( PRESENT( dYdxd ) ) THEN

      ! Calculate the partial derivative of the output functions (Y) with respect to the discrete states (xd) here:

      ! allocate and set dYdxd

   END IF

   IF ( PRESENT( dXdxd ) ) THEN

      ! Calculate the partial derivative of the continuous state functions (X) with respect to the discrete states (xd) here:

      ! allocate and set dXdxd

   END IF

   IF ( PRESENT( dXddxd ) ) THEN

      ! Calculate the partial derivative of the discrete state functions (Xd) with respect to the discrete states (xd) here:

      ! allocate and set dXddxd

   END IF

   IF ( PRESENT( dZdxd ) ) THEN

      ! Calculate the partial derivative of the constraint state functions (Z) with respect to the discrete states (xd) here:

      ! allocate and set dZdxd

   END IF


END SUBROUTINE SrvD_JacobianPDiscState
!----------------------------------------------------------------------------------------------------------------------------------
!> Routine to compute the Jacobians of the output (Y), continuous- (X), discrete- (Xd), and constraint-state (Z) functions
!! with respect to the constraint states (z). The partial derivatives dY/dz, dX/dz, dXd/dz, and DZ/dz are returned.
!! Note SrvD does not have constraint states, so these are not set.
SUBROUTINE SrvD_JacobianPConstrState( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg, dYdz, dXdz, dXddz, dZdz )
!..................................................................................................................................

   REAL(DbKi),                             INTENT(IN   )           :: t          !< Time in seconds at operating point
   TYPE(SrvD_InputType),                   INTENT(IN   )           :: u          !< Inputs at operating point (may change to inout if a mesh copy is required)
   TYPE(SrvD_ParameterType),               INTENT(IN   )           :: p          !< Parameters
   TYPE(SrvD_ContinuousStateType),         INTENT(IN   )           :: x          !< Continuous states at operating point
   TYPE(SrvD_DiscreteStateType),           INTENT(IN   )           :: xd         !< Discrete states at operating point
   TYPE(SrvD_ConstraintStateType),         INTENT(IN   )           :: z          !< Constraint states at operating point
   TYPE(SrvD_OtherStateType),              INTENT(IN   )           :: OtherState !< Other states at operating point
   TYPE(SrvD_OutputType),                  INTENT(IN   )           :: y          !< Output (change to inout if a mesh copy is required);
                                                                                 !!   Output fields are not used by this routine, but type is   
                                                                                 !!   available here so that mesh parameter information (i.e.,  
                                                                                 !!   connectivity) does not have to be recalculated for dYdz.
   TYPE(SrvD_MiscVarType),                 INTENT(INOUT)           :: m          !< Misc/optimization variables
   INTEGER(IntKi),                         INTENT(  OUT)           :: ErrStat    !< Error status of the operation
   CHARACTER(*),                           INTENT(  OUT)           :: ErrMsg     !< Error message if ErrStat /= ErrID_None
   REAL(R8Ki), ALLOCATABLE, OPTIONAL,      INTENT(INOUT)           :: dYdz(:,:)  !< Partial derivatives of output
                                                                                 !!  functions (Y) with respect to the
                                                                                 !!  constraint states (z) [intent in to avoid deallocation]
   REAL(R8Ki), ALLOCATABLE, OPTIONAL,      INTENT(INOUT)           :: dXdz(:,:)  !< Partial derivatives of continuous
                                                                                 !!  state functions (X) with respect to
                                                                                 !!  the constraint states (z) [intent in to avoid deallocation]
   REAL(R8Ki), ALLOCATABLE, OPTIONAL,      INTENT(INOUT)           :: dXddz(:,:) !< Partial derivatives of discrete state
                                                                                 !!  functions (Xd) with respect to the
                                                                                 !!  constraint states (z) [intent in to avoid deallocation]
   REAL(R8Ki), ALLOCATABLE, OPTIONAL,      INTENT(INOUT)           :: dZdz(:,:)  !< Partial derivatives of constraint
                                                                                 !! state functions (Z) with respect to
                                                                                 !!  the constraint states (z) [intent in to avoid deallocation]


      ! Initialize ErrStat

   ErrStat = ErrID_None
   ErrMsg  = ''

   IF ( PRESENT( dYdz ) ) THEN

         ! Calculate the partial derivative of the output functions (Y) with respect to the constraint states (z) here:

      ! allocate and set dYdz

   END IF

   IF ( PRESENT( dXdz ) ) THEN

         ! Calculate the partial derivative of the continuous state functions (X) with respect to the constraint states (z) here:

      ! allocate and set dXdz

   END IF

   IF ( PRESENT( dXddz ) ) THEN

         ! Calculate the partial derivative of the discrete state functions (Xd) with respect to the constraint states (z) here:

      ! allocate and set dXddz

   END IF

   IF ( PRESENT( dZdz ) ) THEN

         ! Calculate the partial derivative of the constraint state functions (Z) with respect to the constraint states (z) here:

      ! allocate and set dZdz

   END IF


END SUBROUTINE SrvD_JacobianPConstrState
!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
!> Routine to pack the data structures representing the operating points into arrays for linearization.
SUBROUTINE SrvD_GetOP( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg, u_op, y_op, x_op, dx_op, xd_op, z_op )

   REAL(DbKi),                           INTENT(IN   )           :: t          !< Time in seconds at operating point
   TYPE(SrvD_InputType),                 INTENT(IN   )           :: u          !< Inputs at operating point (may change to inout if a mesh copy is required)
   TYPE(SrvD_ParameterType),             INTENT(IN   )           :: p          !< Parameters
   TYPE(SrvD_ContinuousStateType),       INTENT(IN   )           :: x          !< Continuous states at operating point
   TYPE(SrvD_DiscreteStateType),         INTENT(IN   )           :: xd         !< Discrete states at operating point
   TYPE(SrvD_ConstraintStateType),       INTENT(IN   )           :: z          !< Constraint states at operating point
   TYPE(SrvD_OtherStateType),            INTENT(IN   )           :: OtherState !< Other states at operating point
   TYPE(SrvD_OutputType),                INTENT(IN   )           :: y          !< Output at operating point
   TYPE(SrvD_MiscVarType),               INTENT(INOUT)           :: m          !< Misc/optimization variables
   INTEGER(IntKi),                       INTENT(  OUT)           :: ErrStat    !< Error status of the operation
   CHARACTER(*),                         INTENT(  OUT)           :: ErrMsg     !< Error message if ErrStat /= ErrID_None
   REAL(ReKi), ALLOCATABLE, OPTIONAL,    INTENT(INOUT)           :: u_op(:)    !< values of linearized inputs
   REAL(ReKi), ALLOCATABLE, OPTIONAL,    INTENT(INOUT)           :: y_op(:)    !< values of linearized outputs
   REAL(ReKi), ALLOCATABLE, OPTIONAL,    INTENT(INOUT)           :: x_op(:)    !< values of linearized continuous states
   REAL(ReKi), ALLOCATABLE, OPTIONAL,    INTENT(INOUT)           :: dx_op(:)   !< values of first time derivatives of linearized continuous states
   REAL(ReKi), ALLOCATABLE, OPTIONAL,    INTENT(INOUT)           :: xd_op(:)   !< values of linearized discrete states
   REAL(ReKi), ALLOCATABLE, OPTIONAL,    INTENT(INOUT)           :: z_op(:)    !< values of linearized constraint states


   INTEGER(IntKi)                                 :: i        
   INTEGER(IntKi)                                 :: ErrStat2        ! Error status of the operation (occurs after initial error)
   CHARACTER(ErrMsgLen)                           :: ErrMsg2         ! Error message if ErrStat2 /= ErrID_None
   CHARACTER(*), PARAMETER                        :: RoutineName = 'SrvD_GetOP'
   
   
      ! Initialize ErrStat

   ErrStat = ErrID_None
   ErrMsg  = ''

   !..........................................
   IF ( PRESENT( u_op ) ) THEN
                  
      if (.not. allocated(u_op)) then
         CALL AllocAry( u_op, 3, 'u_op', ErrStat2, ErrMsg2 )
         CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
         IF (ErrStat >= AbortErrLev) RETURN
      end if
      

      u_op(Indx_u_Yaw    ) = u%Yaw
      u_op(Indx_u_YawRate) = u%YawRate
      u_op(Indx_u_HSS_Spd) = u%HSS_Spd     
      
   END IF

   !..........................................
   IF ( PRESENT( y_op ) ) THEN
      
      if (.not. allocated(y_op)) then
         CALL AllocAry( y_op, SrvD_Indx_Y_WrOutput+p%NumOuts, 'y_op', ErrStat2, ErrMsg2 )
            CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
            IF (ErrStat >= AbortErrLev) RETURN
      end if
      
         
      do i=1,size(SrvD_Indx_Y_BlPitchCom)
         y_op(SrvD_Indx_Y_BlPitchCom(i)) = y%BlPitchCom(i)
      end do
      y_op(SrvD_Indx_Y_YawMom)  = y%YawMom
      y_op(SrvD_Indx_Y_GenTrq)  = y%GenTrq
      y_op(SrvD_Indx_Y_ElecPwr) = y%ElecPwr
      do i=1,p%NumOuts
         y_op(i+SrvD_Indx_Y_WrOutput) = y%WriteOutput(i)
      end do
      
   END IF

   IF ( PRESENT( x_op ) ) THEN

   END IF

   IF ( PRESENT( dx_op ) ) THEN

   END IF

   IF ( PRESENT( xd_op ) ) THEN

   END IF
   
   IF ( PRESENT( z_op ) ) THEN

   END IF

END SUBROUTINE SrvD_GetOP
!++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

!----------------------------------------------------------------------------------------------------------------------------------
!> This subroutine parses the input file and stores all the data in the SrvD_InputFile structure.
!! It does not perform data validation.
subroutine ParseInputFileInfo( PriPath, InputFile, OutFileRoot, FileInfo_In, InputFileData, Default_DT, ErrStat, ErrMsg )

   implicit    none

      ! Passed variables
   character(*),                    intent(in   )  :: PriPath           ! Path name of the primary file
   character(*),                    intent(in   )  :: InputFile         !< Name of the file containing the primary input data
   character(*),                    intent(in   )  :: OutFileRoot       !< The rootname of the echo file, possibly opened in this routine
   type(SrvD_InputFile),            intent(  out)  :: InputFileData     !< All the data in the StrucCtrl input file
   type(FileInfoType),              intent(in   )  :: FileInfo_In       !< The derived type for holding the file information.
   real(DbKi),                      intent(in   )  :: Default_DT        !< The default DT (from glue code)
   integer(IntKi),                  intent(  out)  :: ErrStat           !< Error status
   character(ErrMsgLen),            intent(  out)  :: ErrMsg            !< Error message

      ! Local variables:
   integer(IntKi)                                  :: i                 !< generic counter
   character(20)                                   :: TmpChr            !< Temporary char array
   integer(IntKi)                                  :: UnEcho
   integer(IntKi)                                  :: ErrStat2          !< Temporary Error status
   character(ErrMsgLen)                            :: ErrMsg2           !< Temporary Error message
   integer(IntKi)                                  :: CurLine           !< current entry in FileInfo_In%Lines array
   real(ReKi)                                      :: TmpRe2(2)         !< temporary 2 number array for reading values in
   character(*), parameter                         :: RoutineName = 'ParseInputFileInfo'


   ! Initialization
   ErrStat  =  ErrID_None
   ErrMsg   =  ""
   UnEcho   = -1     ! Echo file unit.  >0 when used

   call AllocAry( InputFileData%OutList, MaxOutPts, "ServoDyn Input File's Outlist", ErrStat2, ErrMsg2 )
      if (Failed()) return;

      ! Give verbose info on what we are reading
   if (NWTC_VerboseLevel == NWTC_Verbose) THEN
      call WrScr( ' Heading of the '//trim(SrvD_Ver%Name)//' input file: ' )      
      call WrScr( '   '//trim( FileInfo_In%Lines(2) ) )
   end if

   !-------------------------------------------------------------------------------------------------
   ! General settings
   !-------------------------------------------------------------------------------------------------
   CurLine = 4    ! Skip the first three lines as they are known to be header lines and separators
   call ParseVar( FileInfo_In, CurLine, 'Echo', InputFileData%Echo, ErrStat2, ErrMsg2 )
         if (Failed()) return;

   if ( InputFileData%Echo ) then
      CALL OpenEcho ( UnEcho, TRIM(OutFileRoot)//'.ech', ErrStat2, ErrMsg2 )
         if (Failed()) return;
      WRITE(UnEcho, '(A)') 'Echo file for ServoDyn input file: '//trim(InputFile)
      ! Write the first three lines into the echo file
      WRITE(UnEcho, '(A)') FileInfo_In%Lines(1)
      WRITE(UnEcho, '(A)') FileInfo_In%Lines(2)
      WRITE(UnEcho, '(A)') FileInfo_In%Lines(3)

      CurLine = 4
      call ParseVar( FileInfo_In, CurLine, 'Echo', InputFileData%Echo, ErrStat2, ErrMsg2, UnEcho )
            if (Failed()) return
   endif

      !  DT - Communication interval for controllers (s) (or "default")
   call ParseVarWDefault ( FileInfo_In, CurLine, 'DT', InputFileData%DT, Default_DT, ErrStat2, ErrMsg2, UnEcho )


   !---------------------- PITCH CONTROL -------------------------------------------
   if ( InputFileData%Echo )   WRITE(UnEcho, '(A)') FileInfo_In%Lines(CurLine)    ! Write section break to echo
   CurLine = CurLine + 1
      !  PCMode (switch) - Pitch control mode { 0: none
      !                                         3: user-defined from routine PitchCntrl,
      !                                         4: user-defined from Simulink/Labview
      !                                         5: user-defined from Bladed-style DLL} (switch)
   call ParseVar( FileInfo_In, CurLine, 'PCMode', InputFileData%PCMode, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  TPCOn          - Time to enable active pitch control (s) [unused when PCMode=0]
   call ParseVar( FileInfo_In, CurLine, 'TPCOn', InputFileData%TPCOn, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;

      !  TPitManS       - Time to start override pitch maneuver for blade 1 and end standard pitch control (s)
   do i=1,size(InputFileData%TPitManS)
      TmpChr='TPitManS('//trim(Num2LStr(i))//')'
      call ParseVar( FileInfo_In, CurLine, trim(TmpChr), InputFileData%TPitManS(i), ErrStat2, ErrMsg2, UnEcho )
         if (Failed())  return;
   enddo

      !  PitManRat      - Pitch rate at which override pitch maneuver heads toward final pitch angle for blade 1 (deg/s)
   do i=1,size(InputFileData%PitManRat)
      TmpChr='PitManRat('//trim(Num2LStr(i))//')'
      call ParseVar( FileInfo_In, CurLine, trim(TmpChr), InputFileData%PitManRat(i), ErrStat2, ErrMsg2, UnEcho )
         if (Failed())  return;
   enddo

      !  BlPitchF       - Blade 1 final pitch for pitch maneuvers (degrees)
   do i=1,size(InputFileData%BlPitchF)
      TmpChr='BlPitchF('//trim(Num2LStr(i))//')'
      call ParseVar( FileInfo_In, CurLine, trim(TmpChr), InputFileData%BlPitchF(i), ErrStat2, ErrMsg2, UnEcho )
         if (Failed())  return;
   enddo
   InputFileData%BlPitchF = InputFileData%BlPitchF*D2R


   !---------------------- GENERATOR AND TORQUE CONTROL ----------------------------
   if ( InputFileData%Echo )   WRITE(UnEcho, '(A)') FileInfo_In%Lines(CurLine)    ! Write section break to echo
   CurLine = CurLine + 1
      !  VSContrl (switch) - Variable-speed control mode {
      !                          0: none
      !                          1: simple VS,
      !                          3: user-defined from routine UserVSCont,
      !                          4: user-defined from Simulink/Labview,
      !                          5: user-defined from Bladed-style DLL}
   call ParseVar( FileInfo_In, CurLine, 'VSContrl', InputFileData%VSContrl, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  GenModel       - Generator model {1: simple, 2: Thevenin, 3: user-defined from routine UserGen} (switch) [used only when VSContrl=0]
   call ParseVar( FileInfo_In, CurLine, 'GenModel', InputFileData%GenModel, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  GenEff         - Generator efficiency [ignored by the Thevenin and user-defined generator models] (
   call ParseVar( FileInfo_In, CurLine, 'GenEff', InputFileData%GenEff, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
   InputFileData%GenEff = InputFileData%GenEff*0.01      
      !  GenTiStr       - Method to start the generator {T: timed using TimGenOn, F: generator speed using SpdGenOn} (flag)
   call ParseVar( FileInfo_In, CurLine, 'GenTiStr', InputFileData%GenTiStr, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  GenTiStp       - Method to stop the generator {T: timed using TimGenOf, F: when generator power = 0} (flag)
   call ParseVar( FileInfo_In, CurLine, 'GenTiStp', InputFileData%GenTiStp, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  SpdGenOn       - Generator speed to turn on the generator for a startup (HSS speed) (rpm) [used only when GenTiStr=False]
   call ParseVar( FileInfo_In, CurLine, 'SpdGenOn', InputFileData%SpdGenOn, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
   InputFileData%SpdGenOn = InputFileData%SpdGenOn*RPM2RPS
      !  TimGenOn       - Time to turn on the generator for a startup (s) [used only when GenTiStr=True]
   call ParseVar( FileInfo_In, CurLine, 'TimGenOn', InputFileData%TimGenOn, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  TimGenOf       - Time to turn off the generator (s) [used only when GenTiStp=True]
   call ParseVar( FileInfo_In, CurLine, 'TimGenOf', InputFileData%TimGenOf, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;


   !---------------------- SIMPLE VARIABLE-SPEED TORQUE CONTROL --------------------
   if ( InputFileData%Echo )   WRITE(UnEcho, '(A)') FileInfo_In%Lines(CurLine)    ! Write section break to echo
   CurLine = CurLine + 1
      !  VS_RtGnSp      - Rated generator speed for simple variable-speed generator control (HSS side) (rpm) [used only when VSContrl=1]
   call ParseVar( FileInfo_In, CurLine, 'VS_RtGnSp', InputFileData%VS_RtGnSp, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
   InputFileData%VS_RtGnSp = InputFileData%VS_RtGnSp*RPM2RPS
      !  VS_RtTq        - Rated generator torque/constant generator torque in Region 3 for simple variable-speed generator control (HSS side) (N-m) [used only when VSContrl=1]
   call ParseVar( FileInfo_In, CurLine, 'VS_RtTq', InputFileData%VS_RtTq, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  VS_Rgn2K       - Generator torque constant in Region 2 for simple variable-speed generator control (HSS side) (N-m/rpm^2) [used only when VSContrl=1]
   call ParseVar( FileInfo_In, CurLine, 'VS_Rgn2K', InputFileData%VS_Rgn2K, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
   InputFileData%VS_Rgn2K = InputFileData%VS_Rgn2K/( RPM2RPS**2 )
      !  VS_SlPc        - Rated generator slip percentage in Region 2 1/2 for simple variable-speed generator control (
   call ParseVar( FileInfo_In, CurLine, 'VS_SlPc', InputFileData%VS_SlPc, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
   InputFileData%VS_SlPc = InputFileData%VS_SlPc*.01


   !---------------------- SIMPLE INDUCTION GENERATOR ------------------------------
   if ( InputFileData%Echo )   WRITE(UnEcho, '(A)') FileInfo_In%Lines(CurLine)    ! Write section break to echo
   CurLine = CurLine + 1
      !  SIG_SlPc       - Rated generator slip percentage (
   call ParseVar( FileInfo_In, CurLine, 'SIG_SlPc', InputFileData%SIG_SlPc, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
   InputFileData%SIG_SlPc = InputFileData%SIG_SlPc*.01
      !  SIG_SySp       - Synchronous (zero-torque) generator speed (rpm) [used only when VSContrl=0 and GenModel=1]
   call ParseVar( FileInfo_In, CurLine, 'SIG_SySp', InputFileData%SIG_SySp, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
   InputFileData%SIG_SySp = InputFileData%SIG_SySp*RPM2RPS  
      !  SIG_RtTq       - Rated torque (N-m) [used only when VSContrl=0 and GenModel=1]
   call ParseVar( FileInfo_In, CurLine, 'SIG_RtTq', InputFileData%SIG_RtTq, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  SIG_PORt       - Pull-out ratio (Tpullout/Trated) (-) [used only when VSContrl=0 and GenModel=1]
   call ParseVar( FileInfo_In, CurLine, 'SIG_PORt', InputFileData%SIG_PORt, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;


   !---------------------- THEVENIN-EQUIVALENT INDUCTION GENERATOR -----------------
   if ( InputFileData%Echo )   WRITE(UnEcho, '(A)') FileInfo_In%Lines(CurLine)    ! Write section break to echo
   CurLine = CurLine + 1
      !  TEC_Freq       - Line frequency [50 or 60] (Hz) [used only when VSContrl=0 and GenModel=2]
   call ParseVar( FileInfo_In, CurLine, 'TEC_Freq', InputFileData%TEC_Freq, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  TEC_NPol       - Number of poles [even integer > 0] (-) [used only when VSContrl=0 and GenModel=2]
   call ParseVar( FileInfo_In, CurLine, 'TEC_NPol', InputFileData%TEC_NPol, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  TEC_SRes       - Stator resistance (ohms) [used only when VSContrl=0 and GenModel=2]
   call ParseVar( FileInfo_In, CurLine, 'TEC_SRes', InputFileData%TEC_SRes, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  TEC_RRes       - Rotor resistance (ohms) [used only when VSContrl=0 and GenModel=2]
   call ParseVar( FileInfo_In, CurLine, 'TEC_RRes', InputFileData%TEC_RRes, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  TEC_VLL        - Line-to-line RMS voltage (volts) [used only when VSContrl=0 and GenModel=2]
   call ParseVar( FileInfo_In, CurLine, 'TEC_VLL', InputFileData%TEC_VLL, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  TEC_SLR        - Stator leakage reactance (ohms) [used only when VSContrl=0 and GenModel=2]
   call ParseVar( FileInfo_In, CurLine, 'TEC_SLR', InputFileData%TEC_SLR, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  TEC_RLR        - Rotor leakage reactance (ohms) [used only when VSContrl=0 and GenModel=2]
   call ParseVar( FileInfo_In, CurLine, 'TEC_RLR', InputFileData%TEC_RLR, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  TEC_MR         - Magnetizing reactance (ohms) [used only when VSContrl=0 and GenModel=2]
   call ParseVar( FileInfo_In, CurLine, 'TEC_MR', InputFileData%TEC_MR, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;


   !---------------------- HIGH-SPEED SHAFT BRAKE ----------------------------------
   if ( InputFileData%Echo )   WRITE(UnEcho, '(A)') FileInfo_In%Lines(CurLine)    ! Write section break to echo
   CurLine = CurLine + 1
      !  HSSBrMode (switch)   - HSS brake model {
      !                             0: none,
      !                             1: simple,
      !                             3: user-defined from routine UserHSSBr,
      !                             4: user-defined from Simulink/Labview,
      !                             5: user-defined from Bladed-style DLL}
   call ParseVar( FileInfo_In, CurLine, 'HSSBrMode', InputFileData%HSSBrMode, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  THSSBrDp   - Time to initiate deployment of the HSS brake (s)
   call ParseVar( FileInfo_In, CurLine, 'THSSBrDp', InputFileData%THSSBrDp, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  HSSBrDT   - Time for HSS-brake to reach full deployment once initiated (sec) [used only when HSSBrMode=1]
   call ParseVar( FileInfo_In, CurLine, 'HSSBrDT', InputFileData%HSSBrDT, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  HSSBrTqF   - Fully deployed HSS-brake torque (N-m)
   call ParseVar( FileInfo_In, CurLine, 'HSSBrTqF', InputFileData%HSSBrTqF, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;


   !---------------------- YAW CONTROL ---------------------------------------------
   if ( InputFileData%Echo )   WRITE(UnEcho, '(A)') FileInfo_In%Lines(CurLine)    ! Write section break to echo
   CurLine = CurLine + 1
      !  YCMode (switch)   - Yaw control mode {
      !                             0: none,
      !                             3: user-defined from routine UserYawCont,
      !                             4: user-defined from Simulink/Labview,
      !                             5: user-defined from Bladed-style DLL}
   call ParseVar( FileInfo_In, CurLine, 'YCMode', InputFileData%YCMode, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  TYCOn  - Time to enable active yaw control (s) [unused when YCMode=0]
   call ParseVar( FileInfo_In, CurLine, 'TYCOn', InputFileData%TYCOn, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  YawNeut  - Neutral yaw position--yaw spring force is zero at this yaw (degrees)
   call ParseVar( FileInfo_In, CurLine, 'YawNeut', InputFileData%YawNeut, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
   InputFileData%YawNeut = InputFileData%YawNeut*D2R
      !  YawSpr  - Nacelle-yaw spring constant (N-m/rad)
   call ParseVar( FileInfo_In, CurLine, 'YawSpr', InputFileData%YawSpr, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  YawDamp  - Nacelle-yaw damping constant (N-m/(rad/s))
   call ParseVar( FileInfo_In, CurLine, 'YawDamp', InputFileData%YawDamp, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  TYawManS  - Time to start override yaw maneuver and end standard yaw control (s)
   call ParseVar( FileInfo_In, CurLine, 'TYawManS', InputFileData%TYawManS, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  YawManRat  - Yaw maneuver rate (in absolute value) (deg/s)
   call ParseVar( FileInfo_In, CurLine, 'YawManRat', InputFileData%YawManRat, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
   InputFileData%YawManRat = InputFileData%YawManRat*D2R
      !  NacYawF  - Final yaw angle for override yaw maneuvers (degrees)
   call ParseVar( FileInfo_In, CurLine, 'NacYawF', InputFileData%NacYawF, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
   InputFileData%NacYawF = InputFileData%NacYawF*D2R


   !---------------------- TUNED MASS DAMPER ----------------------------------------         
   if ( InputFileData%Echo )   WRITE(UnEcho, '(A)') FileInfo_In%Lines(CurLine)    ! Write section break to echo
   CurLine = CurLine + 1
      !  CompNStC  - Compute nacelle structural control damping {number of nacelle TMDs} (integer)
   call ParseVar( FileInfo_In, CurLine, 'CompNStC', InputFileData%CompNStC, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  NStCfile  - Name of the file for nacelle structural control damping (quoted strings) [unused when CompNStC==0]
   call AllocAry( InputFileData%NStCfile, InputFileData%CompNStC, 'NStCfile', ErrStat2, ErrMsg2 )
      if (Failed())  return;
   call ParseAry( FileInfo_In, CurLine, 'NStCfile', InputFileData%NStCfile, InputFileData%CompNStC, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;

      !  CompTStC  - Compute tower structural control damping {number of nacelle TMDs} (integer)
   call ParseVar( FileInfo_In, CurLine, 'CompTStC', InputFileData%CompTStC, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  TStCfile  - Name of the file for tower structural control damping (quoted strings) [unused when CompTStC==0]
   call AllocAry( InputFileData%TStCfile, InputFileData%CompTStC, 'TStCfile', ErrStat2, ErrMsg2 )
      if (Failed())  return;
   call ParseAry( FileInfo_In, CurLine, 'TStCfile', InputFileData%TStCfile, InputFileData%CompTStC, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;

      !  CompBStC  - Compute  blade structural control damping {number of nacelle tmds} (integer)
   call ParseVar( FileInfo_In, CurLine, 'CompBStC', InputFileData%CompBStC, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  BStCfile  - Name of the file for blade structural control damping (quoted strings) [unused when CompBStC==0]
   call AllocAry( InputFileData%BStCfile, InputFileData%CompBStC, 'BStCfile', ErrStat2, ErrMsg2 )
      if (Failed())  return;
   call ParseAry( FileInfo_In, CurLine, 'BStCfile', InputFileData%BStCfile, InputFileData%CompBStC, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;

      !  CompPtfmStC  - Compute platform structural control damping {number of nacelle TMDs} (integer)
   call ParseVar( FileInfo_In, CurLine, 'CompPtfmStC', InputFileData%CompPtfmStC, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  PtfmStCfile  - Name of the file for blade structural control damping (quoted strings) [unused when CompPtfmStC==0]
   call AllocAry( InputFileData%PtfmStCfile, InputFileData%CompPtfmStC, 'PtfmStCfile', ErrStat2, ErrMsg2 )
      if (Failed())  return;
   call ParseAry( FileInfo_In, CurLine, 'PtfmStCfile', InputFileData%PtfmStCfile, InputFileData%CompPtfmStC, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;


   !---------------------- BLADED INTERFACE ----------------------------------------         
   if ( InputFileData%Echo )   WRITE(UnEcho, '(A)') FileInfo_In%Lines(CurLine)    ! Write section break to echo
   CurLine = CurLine + 1
      !  DLL_FileName  - Name/location of the dynamic library {.dll [Windows] or .so [Linux]} in the Bladed-DLL format (-) [used only with Bladed Interface]
   call ParseVar( FileInfo_In, CurLine, 'DLL_FileName', InputFileData%DLL_FileName, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
   IF ( PathIsRelative( InputFileData%DLL_FileName ) ) InputFileData%DLL_FileName = TRIM(PriPath)//TRIM(InputFileData%DLL_FileName)
      !  DLL_InFile  - Name of input file sent to the DLL (-) [used only with Bladed Interface]
   call ParseVar( FileInfo_In, CurLine, 'DLL_InFile', InputFileData%DLL_InFile, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
   IF ( PathIsRelative( InputFileData%DLL_InFile ) ) InputFileData%DLL_InFile = TRIM(PriPath)//TRIM(InputFileData%DLL_InFile)   
      !  DLL_ProcName  - Name of procedure in DLL to be called (-) [case sensitive; used only with DLL Interface]
   call ParseVar( FileInfo_In, CurLine, 'DLL_ProcName', InputFileData%DLL_ProcName, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  DLL_DT  - Communication interval for dynamic library (s) (or "default") [used only with Bladed Interface]
   call ParseVarWDefault( FileInfo_In, CurLine, 'DLL_DT', InputFileData%DLL_DT, InputFileData%DT, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  DLL_Ramp  - Whether a linear ramp should be used between DLL_DT time steps [introduces time shift when true] (flag) [used only with Bladed Interface]
   call ParseVar( FileInfo_In, CurLine, 'DLL_Ramp', InputFileData%DLL_Ramp, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  BPCutoff  - Cuttoff frequency for low-pass filter on blade pitch from DLL (Hz) [used only with Bladed Interface]
   call ParseVar( FileInfo_In, CurLine, 'BPCutoff', InputFileData%BPCutoff, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  NacYaw_North  - Reference yaw angle of the nacelle when the upwind end points due North (deg) [used only with Bladed Interface]
   call ParseVar( FileInfo_In, CurLine, 'NacYaw_North', InputFileData%NacYaw_North, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
   InputFileData%NacYaw_North = InputFileData%NacYaw_North*D2R
      !  Ptch_Cntrl  - Record 28: Use individual pitch control {0: collective pitch; 1: individual pitch control} (switch) [used only with Bladed Interface]
   call ParseVar( FileInfo_In, CurLine, 'Ptch_Cntrl', InputFileData%Ptch_Cntrl, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  Ptch_SetPnt  - Record  5: Below-rated pitch angle set-point (deg) [used only with Bladed Interface]
   call ParseVar( FileInfo_In, CurLine, 'Ptch_SetPnt', InputFileData%Ptch_SetPnt, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
   InputFileData%Ptch_SetPnt = InputFileData%Ptch_SetPnt*D2R
      !  Ptch_Min  - Record  6: Minimum pitch angle (deg) [used only with Bladed Interface]
   call ParseVar( FileInfo_In, CurLine, 'Ptch_Min', InputFileData%Ptch_Min, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
   InputFileData%Ptch_Min = InputFileData%Ptch_Min*D2R
      !  Ptch_Max  - Record  7: Maximum pitch angle (deg) [used only with Bladed Interface]
   call ParseVar( FileInfo_In, CurLine, 'Ptch_Max', InputFileData%Ptch_Max, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
   InputFileData%Ptch_Max = InputFileData%Ptch_Max*D2R
      !  PtchRate_Min  - Record  8: Minimum pitch rate (most negative value allowed) (deg/s) [used only with Bladed Interface]
   call ParseVar( FileInfo_In, CurLine, 'PtchRate_Min', InputFileData%PtchRate_Min, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
   InputFileData%PtchRate_Min = InputFileData%PtchRate_Min*D2R
      !  PtchRate_Max  - Record  9: Maximum pitch rate  (deg/s) [used only with Bladed Interface]
   call ParseVar( FileInfo_In, CurLine, 'PtchRate_Max', InputFileData%PtchRate_Max, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
   InputFileData%PtchRate_Max = InputFileData%PtchRate_Max*D2R
      !  Gain_OM  - Record 16: Optimal mode gain (Nm/(rad/s)^2) [used only with Bladed Interface]
   call ParseVar( FileInfo_In, CurLine, 'Gain_OM', InputFileData%Gain_OM, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  GenSpd_MinOM  - Record 17: Minimum generator speed (rpm) [used only with Bladed Interface]
   call ParseVar( FileInfo_In, CurLine, 'GenSpd_MinOM', InputFileData%GenSpd_MinOM, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
   InputFileData%GenSpd_MinOM = InputFileData%GenSpd_MinOM*RPM2RPS
      !  GenSpd_MaxOM  - Record 18: Optimal mode maximum speed (rpm) [used only with Bladed Interface]
   call ParseVar( FileInfo_In, CurLine, 'GenSpd_MaxOM', InputFileData%GenSpd_MaxOM, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
   InputFileData%GenSpd_MaxOM = InputFileData%GenSpd_MaxOM*RPM2RPS
      !  GenSpd_Dem  - Record 19: Demanded generator speed above rated (rpm) [used only with Bladed Interface]
   call ParseVar( FileInfo_In, CurLine, 'GenSpd_Dem', InputFileData%GenSpd_Dem, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
   InputFileData%GenSpd_Dem = InputFileData%GenSpd_Dem*RPM2RPS
      !  GenTrq_Dem  - Record 22: Demanded generator torque above rated (Nm) [used only with Bladed Interface]
   call ParseVar( FileInfo_In, CurLine, 'GenTrq_Dem', InputFileData%GenTrq_Dem, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  GenPwr_Dem  - Record 13: Demanded power (W) [used only with Bladed Interface]
   call ParseVar( FileInfo_In, CurLine, 'GenPwr_Dem', InputFileData%GenPwr_Dem, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;


   !---------------------- BLADED INTERFACE TORQUE-SPEED LOOK-UP TABLE -------------         
   if ( InputFileData%Echo )   WRITE(UnEcho, '(A)') FileInfo_In%Lines(CurLine)    ! Write section break to echo
   CurLine = CurLine + 1
      ! NKInpSt      - Number of spring force input stations
   call ParseVar( FileInfo_In, CurLine, 'DLL_NumTrq', InputFileData%DLL_NumTrq, ErrStat2, ErrMsg2, UnEcho)
         if (Failed()) return
   ! Section break --  GenSpd_TLU   GenTrq_TLU
   if ( InputFileData%Echo )   WRITE(UnEcho, '(A)') ' Table Header: '//FileInfo_In%Lines(CurLine)    ! Write section break to echo
   CurLine = CurLine + 1
   if ( InputFileData%Echo )   WRITE(UnEcho, '(A)') ' Table Units: '//FileInfo_In%Lines(CurLine)    ! Write section break to echo
   CurLine = CurLine + 1

   if (InputFileData%DLL_NumTrq > 0) then
      CALL AllocAry( InputFileData%GenSpd_TLU,   InputFileData%DLL_NumTrq, 'GenSpd_TLU', ErrStat2, ErrMsg2 )
            if (Failed()) return;
      CALL AllocAry( InputFileData%GenTrq_TLU,   InputFileData%DLL_NumTrq, 'GenTrq_TLU',ErrStat2, ErrMsg2 )
            if (Failed()) return;
         ! TABLE read
      do i=1,InputFileData%DLL_NumTrq
         call ParseAry ( FileInfo_In, CurLine, 'Coordinates', TmpRe2, 2, ErrStat2, ErrMsg2, UnEcho )
               if (Failed()) return;
         InputFileData%GenSpd_TLU(i) = TmpRe2(1)*RPM2RPS  ! GenSpd_TLU - Records R:2:R+2*DLL_NumTrq-2: Generator speed values in look-up table (rpm) (read from file in rpm and converted to rad/s here)
         InputFileData%GenTrq_TLU(i) = TmpRe2(2)          ! GenTrq_TLU - Records R+1:2:R+2*DLL_NumTrq-1: Generator torque values in look-up table (Nm)
      enddo
   endif



   !---------------------- OUTPUT --------------------------------------------------         
   if ( InputFileData%Echo )   WRITE(UnEcho, '(A)') FileInfo_In%Lines(CurLine)    ! Write section break to echo
   CurLine = CurLine + 1
      !  SumPrint  - Print summary data to <RootName>.sum (flag) (currently unused)
   call ParseVar( FileInfo_In, CurLine, 'SumPrint', InputFileData%SumPrint, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  OutFile  - Switch to determine where output will be placed: {1: in module output file only; 2: in glue code output file only; 3: both} (currently unused)
   call ParseVar( FileInfo_In, CurLine, 'OutFile', InputFileData%OutFile, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
   !PLACEHOLDER: OutFileFmt - Format for module tabular (time-marching) output: (1: text file [<RootName>.out], 2: binary file [<RootName>.outb], 3: both):
      !  TabDelim  - Use tab delimiters in text tabular output file? (flag) (currently unused)
   call ParseVar( FileInfo_In, CurLine, 'TabDelim', InputFileData%TabDelim, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  OutFmt  - Format used for text tabular output (except time).  Resulting field should be 10 characters. (quoted string) (currently unused)
   call ParseVar( FileInfo_In, CurLine, 'OutFmt', InputFileData%OutFmt, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
      !  TStart  - Time to begin tabular output (s) (currently unused)
   call ParseVar( FileInfo_In, CurLine, 'TStart', InputFileData%TStart, ErrStat2, ErrMsg2, UnEcho )
      if (Failed())  return;
   !PLACEHOLDER: DecFact - Decimation factor for module's tabular output (1=output every step) (-):

   !---------------------- OUTLIST  --------------------------------------------
   if ( InputFileData%Echo )   WRITE(UnEcho, '(A)') FileInfo_In%Lines(CurLine)    ! Write section break to echo
   CurLine = CurLine + 1
   call ReadOutputListFromFileInfo( FileInfo_In, CurLine, InputFileData%OutList, &
            InputFileData%NumOuts, 'OutList', "List of user-requested output channels", ErrStat2, ErrMsg2, UnEcho )
         if (Failed()) return;


   call Cleanup()
   return

contains
   !-------------------------------------------------------------------------------------------------
   logical function Failed()
      CALL SetErrStat( ErrStat2, ErrMsg2, ErrStat, ErrMsg, RoutineName )
      Failed = ErrStat >= AbortErrLev
      ! This fixes a strange compile issue with gfortran 9.1.0 on Mac where the CurLine and ErrStat end up sharing stack
      ! space due to the -fstack_reuse="all" is set for any optimization.  Can workaround with -fstack_reuse="none", but
      ! have not found any other viable workaround other than using CurLine here in the Failed function
      CurLine = CurLine
      if (Failed) call Cleanup()
   end function Failed
   !-------------------------------------------------------------------------------------------------
   subroutine Cleanup()
      if (UnEcho  > -1_IntKi)     CLOSE( UnEcho  )
   end subroutine Cleanup
end subroutine ParseInputFileInfo
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine validates the inputs from the primary input file.
SUBROUTINE ValidatePrimaryData( InitInp, InputFileData, ErrStat, ErrMsg )
!..................................................................................................................................
      
      ! Passed variables:

   TYPE(SrvD_InitInputType), INTENT(IN   )  :: InitInp                     !< Input data for initialization routine
   TYPE(SrvD_InputFile),     INTENT(IN)     :: InputFileData               !< All the data in the ServoDyn input file
   INTEGER(IntKi),           INTENT(OUT)    :: ErrStat                     !< Error status
   CHARACTER(*),             INTENT(OUT)    :: ErrMsg                      !< Error message

   
      ! local variables
   INTEGER(IntKi)                           :: K                           ! Blade number
   CHARACTER(*), PARAMETER                  :: RoutineName = 'ValidatePrimaryData'
   INTEGER(IntKi)                           :: ErrStat2                    !< Error status
   CHARACTER(ErrMsgLen)                     :: ErrMsg2                     !<  temporary Error message if ErrStat /= ErrID_None
   

   ErrStat = ErrID_None
   ErrMsg  = ''
   
   CALL Pitch_ValidateData()
   CALL Yaw_ValidateData()
   CALL TipBrake_ValidateData()
   CALL Torque_ValidateData()
   CALL HSSBr_ValidateData()
!FIXME: add validation for StC inputs
!   CALL StC_ValidateData()

   !  Checks for linearization:
   if ( InitInp%Linearize ) then
   
      if ( InputFileData%PCMode /= ControlMode_NONE ) &
         call SetErrStat(ErrID_Fatal,"PCMode must be 0 for linearization.",ErrStat,ErrMsg,RoutineName)
      if ( InputFileData%VSContrl /= ControlMode_NONE .and. InputFileData%VSContrl /= ControlMode_SIMPLE ) &
         call SetErrStat(ErrID_Fatal,"VSContrl must be 0 or 1 for linearization.",ErrStat,ErrMsg,RoutineName)
      if ( InputFileData%GenModel /= ControlMode_SIMPLE .and. InputFileData%GenModel /= ControlMode_ADVANCED ) &
         call SetErrStat(ErrID_Fatal,"GenModel must be 1 or 2 for linearization.",ErrStat,ErrMsg,RoutineName)
      
      if ( .not. InputFileData%GenTiStr  ) &
         call SetErrStat(ErrID_Fatal,"GenTiStr must be TRUE for linearization.",ErrStat,ErrMsg,RoutineName)
      if ( .not. InputFileData%GenTiStp  ) &
         call SetErrStat(ErrID_Fatal,"GenTiStp must be TRUE for linearization.",ErrStat,ErrMsg,RoutineName)

      if (InputFileData%HSSBrMode /= ControlMode_NONE) &
         call SetErrStat(ErrID_Fatal,"HSSBrMode must be 0 for linearization.",ErrStat,ErrMsg,RoutineName)
      if (InputFileData%YCMode /= ControlMode_NONE) &
         call SetErrStat(ErrID_Fatal,"YCMode must be 0 for linearization.",ErrStat,ErrMsg,RoutineName)
      
      if ((InputFileData%CompNStC + InputFileData%CompTStC + InputFileData%CompBStC + InputFileData%CompPtfmStC) > 0_IntKi) &
         call SetErrStat(ErrID_Fatal,"StrucCtrl module is not currently allowed in linearization. CompNStC, CompTStC, CompBStC, and CompPtfmStC must all be ZERO.",ErrStat,ErrMsg,RoutineName)
      
      if (InitInp%TrimCase /= TrimCase_none) then
         if (InitInp%TrimCase /= TrimCase_yaw .and. InitInp%TrimCase /= TrimCase_torque .and. InitInp%TrimCase /=  TrimCase_pitch) then
            call SetErrStat(ErrID_Fatal,"Invalid value entered for TrimCase.",ErrStat,ErrMsg,RoutineName)
         else
            if (InitInp%TrimGain <= 0.0_ReKi) call SetErrStat(ErrID_Fatal,"TrimGain must be a positive number.",ErrStat,ErrMsg,RoutineName)
         end if
      end if

   end if
   
      
! this code was in FASTSimulink.f90 in FAST v7:
   IF (Cmpl4SFun) THEN !warn if ServoDyn isn't going to use the inputs from the Simulink interface
      IF (InputFileData%YCMode    /= ControlMode_EXTERN) CALL SetErrStat( ErrID_Info, 'Yaw angle and rate are not commanded from Simulink model.', ErrStat, ErrMsg, RoutineName )
      IF (InputFileData%PCMode    /= ControlMode_EXTERN) CALL SetErrStat( ErrID_Info, 'Pitch angles are not commanded from Simulink model.', ErrStat, ErrMsg, RoutineName )
      IF (InputFileData%VSContrl  /= ControlMode_EXTERN) CALL SetErrStat( ErrID_Info, 'Generator torque and power are not commanded from Simulink model.', ErrStat, ErrMsg, RoutineName )
      IF (InputFileData%HSSBrMode /= ControlMode_EXTERN) CALL SetErrStat( ErrID_Info, 'HSS brake is not commanded from Simulink model.', ErrStat, ErrMsg, RoutineName )
   END IF
   
   RETURN
   
CONTAINS
   !-------------------------------------------------------------------------------------------------------------------------------
   !> This routine performs the checks on inputs for the pitch controller.
   SUBROUTINE Pitch_ValidateData( )
   !...............................................................................................................................
   
         ! Check that the requested pitch control modes are valid:
   
      IF ( .NOT. Cmpl4SFun .AND. .NOT. Cmpl4LV ) THEN
         
         IF ( InputFileData%PCMode == ControlMode_EXTERN )  THEN
            CALL SetErrStat( ErrID_Fatal, 'PCMode can equal '//TRIM(Num2LStr(ControlMode_EXTERN))//' only when ServoDyn is interfaced with Simulink or LabVIEW.'// &
                      '  Set PCMode to 0, 3, or 5 or interface ServoDyn with Simulink or LabVIEW.', ErrStat, ErrMsg, RoutineName )          
         END IF
         
      END IF
   
   
      IF ( InputFileData%PCMode /= ControlMode_NONE .and. InputFileData%PCMode /= ControlMode_USER )  THEN
         IF ( InputFileData%PCMode /= ControlMode_EXTERN .and. InputFileData%PCMode /= ControlMode_DLL )  &
         CALL SetErrStat( ErrID_Fatal, 'PCMode must be 0, 3, 4, or 5.', ErrStat, ErrMsg, RoutineName )
      ENDIF
         

         ! Time that pitch control is enabled:
      
      IF ( InputFileData%TPCOn < 0.0_DbKi )  THEN
         CALL SetErrStat( ErrID_Fatal, 'TPCOn must not be negative.', ErrStat, ErrMsg, RoutineName )
      ENDIF

         ! Make sure the number of blades in the simulation doesn't exceed 3:

      IF ( InitInp%NumBl > SIZE(InputFileData%TPitManS,1) ) CALL SetErrStat( ErrID_Fatal, 'Number of blades exceeds input values.', ErrStat, ErrMsg, RoutineName )
      
         ! Check the pitch-maneuver start times and rates:
         
      DO K=1,MIN(InitInp%NumBl,SIZE(InputFileData%TPitManS))
      
         IF ( InputFileData%TPitManS(K) < 0.0_DbKi ) &
            CALL SetErrStat( ErrID_Fatal, 'TPitManS('//TRIM( Num2LStr( K ) )//') must not be negative.', ErrStat, ErrMsg, RoutineName )         
         IF ( EqualRealNos( InputFileData%PitManRat(K), 0.0_ReKi ) ) &
            CALL SetErrStat( ErrID_Fatal, 'PitManRat('//TRIM( Num2LStr(K) )//') must not be 0.', ErrStat, ErrMsg, RoutineName )

      ENDDO ! K   
      
      
!??? IF ( ANY( p%BlPitchInit <= -pi ) .OR. ANY( p%BlPitchInit > pi ) )  THEN
!      CALL SetErrStat( ErrID_Fatal, 'BlPitchInit('//TRIM( Num2LStr( K ) )//') must be in the range (-pi,pi] radians (i.e., (-180,180] degrees).' , ErrStat, ErrMsg, RoutineName )
      
      
               
   END SUBROUTINE Pitch_ValidateData
   !-------------------------------------------------------------------------------------------------------------------------------
   !> This routine performs the checks on inputs for the yaw controller.
   SUBROUTINE Yaw_ValidateData( )
   !...............................................................................................................................
   
            ! checks for yaw control mode:
      IF ( InputFileData%YCMode /= ControlMode_NONE .and. InputFileData%YCMode /= ControlMode_USER   )  THEN
         IF ( InputFileData%YCMode /= ControlMode_DLL .and. InputFileData%YCMode /= ControlMode_EXTERN )  &
         CALL SetErrStat( ErrID_Fatal, 'YCMode must be 0, 3, 4 or 5.', ErrStat, ErrMsg, RoutineName )
      ENDIF

            
         ! Some special checks based on whether inputs will come from external source (e.g., Simulink, LabVIEW)            
      IF ( .NOT. Cmpl4SFun .AND. .NOT. Cmpl4LV ) THEN
         
         IF ( InputFileData%YCMode == ControlMode_EXTERN )  THEN
            CALL SetErrStat( ErrID_Fatal, 'YCMode can equal '//TRIM(Num2LStr(ControlMode_EXTERN))//' only when ServoDyn is interfaced with Simulink or LabVIEW.'// &
                      '  Set YCMode to 0, 3, or 5 or interface ServoDyn with Simulink or LabVIEW.', ErrStat, ErrMsg, RoutineName )          
         END IF
   
     END IF
            

         ! Check the start time to enable yaw control mode:
      
      IF ( InputFileData%TYCOn < 0.0_DbKi )  THEN
         CALL SetErrStat( ErrID_Fatal, 'TYCOn must not be negative.', ErrStat, ErrMsg, RoutineName )
      ENDIF
   
   
         ! Check the nacelle-yaw-maneuver start times and rates:
      IF ( InputFileData%TYawManS < 0.0_DbKi )  CALL SetErrStat( ErrID_Fatal, 'TYawManS must not be negative.', ErrStat, ErrMsg, RoutineName )
      IF ( EqualRealNos( InputFileData%YawManRat, 0.0_ReKi ) ) CALL SetErrStat( ErrID_Fatal, 'YawManRat must not be 0.', ErrStat, ErrMsg, RoutineName )
   !   IF ( InputFileData%TYawManE < InputFileData%TYawManS ) CALL SetErrStat( ErrID_Fatal, 'TYawManE must not be less than TYawManS.', ErrStat, ErrMsg, RoutineName )


         ! Check the nacelle-yaw spring and damping constants:

      IF ( InputFileData%YawSpr  < 0.0_ReKi )  CALL SetErrStat( ErrID_Fatal, 'YawSpr must not be negative.' , ErrStat, ErrMsg, RoutineName )
      IF ( InputFileData%YawDamp < 0.0_ReKi )  CALL SetErrStat( ErrID_Fatal, 'YawDamp must not be negative.', ErrStat, ErrMsg, RoutineName )
   
         ! Check the neutral position:
      IF ( InputFileData%YawNeut <= -pi  .OR.  InputFileData%YawNeut > pi )  &
         CALL SetErrStat( ErrID_Fatal, 'YawNeut must be in the range (-pi, pi] radians (i.e., (-180,180] degrees).', ErrStat, ErrMsg, RoutineName )
   
   
   END SUBROUTINE Yaw_ValidateData
   !-------------------------------------------------------------------------------------------------------------------------------
   !> This routine performs the checks on inputs for the tip brakes.
   SUBROUTINE TipBrake_ValidateData( )
   !...............................................................................................................................
   
      !IF ( TBDrConN < 0.0 )  CALL ProgAbort ( ' TBDrConN must not be negative.' )
      !IF ( TBDrConD < TBDrConN )  CALL ProgAbort( ' TBDrConD must not be less than TBDrConN.' )
      !IF ( p%TpBrDT < 0.0_DbKi )  CALL ProgAbort ( ' TpBrDT must not be negative.' )
      
   
      !DO K=1,MIN(InitInp%NumBl,SIZE(InputFileData%TTpBrDp))
      !   IF ( InputFileData%TTpBrDp(K)  < 0.0_DbKi ) &
      !      CALL SetErrStat( ErrID_Fatal, 'TTpBrDp(' //TRIM( Num2LStr( K ) )//') must not be negative.', ErrStat, ErrMsg, RoutineName )
      !   IF ( InputFileData%TBDepISp(K) < 0.0_DbKi ) &
      !      CALL SetErrStat( ErrID_Fatal, 'TBDepISp('//TRIM( Num2LStr( K ) )//') must not be negative.', ErrStat, ErrMsg, RoutineName )      
      !ENDDO ! K   
   
   
   END SUBROUTINE TipBrake_ValidateData
   !-------------------------------------------------------------------------------------------------------------------------------
   !> This routine performs the checks on inputs for the torque controller.
   SUBROUTINE Torque_ValidateData( )
   !...............................................................................................................................
      IF ( .NOT. Cmpl4SFun .AND. .NOT. Cmpl4LV ) THEN
      
         IF ( InputFileData%VSContrl == ControlMode_EXTERN )  THEN
            CALL SetErrStat( ErrID_Fatal, 'VSContrl can equal '//TRIM(Num2LStr(ControlMode_EXTERN))//' only when ServoDyn is interfaced with Simulink or LabVIEW.'// &
                '  Set VSContrl to 0, 1, 3, or 5 or interface ServoDyn with Simulink or LabVIEW.', ErrStat, ErrMsg, RoutineName )
         END IF
      END IF
      
   
         ! checks for generator and torque control:           
      IF ( InputFileData%VSContrl /= ControlMode_NONE .and. &
              InputFileData%VSContrl /= ControlMode_SIMPLE .AND. InputFileData%VSContrl /= ControlMode_USER )  THEN
         IF ( InputFileData%VSContrl /= ControlMode_DLL .AND. InputFileData%VSContrl /=ControlMode_EXTERN )  &
         CALL SetErrStat( ErrID_Fatal, 'VSContrl must be either 0, 1, 3, 4, or 5.', ErrStat, ErrMsg, RoutineName )
      ENDIF
   
      IF ( InputFileData%SpdGenOn < 0.0_ReKi ) CALL SetErrStat( ErrID_Fatal, 'SpdGenOn must not be negative.', ErrStat, ErrMsg, RoutineName )
      IF ( InputFileData%TimGenOn < 0.0_DbKi ) CALL SetErrStat( ErrID_Fatal, 'TimGenOn must not be negative.', ErrStat, ErrMsg, RoutineName )
      IF ( InputFileData%TimGenOf < 0.0_DbKi ) CALL SetErrStat( ErrID_Fatal, 'TimGenOf must not be negative.', ErrStat, ErrMsg, RoutineName )
   !   IF ( InputFileData%TimGenOf < InputFileData%TimGenOn ) CALL SetErrStat( ErrID_Fatal, 'TimGenOf must not be before TimGenOn.', ErrStat, ErrMsg, RoutineName )
      IF ( InputFileData%GenEff   < 0.0_ReKi  .OR.  InputFileData%GenEff > 1.0_ReKi )  THEN
         CALL SetErrStat( ErrID_Fatal, 'GenEff must be in the range [0, 1] (i.e., [0, 100] percent)', ErrStat, ErrMsg, RoutineName )
      END IF
   
   
         ! checks for variable-speed torque control:           
      IF ( InputFileData%VSContrl == ControlMode_SIMPLE ) THEN
         IF ( InputFileData%VS_RtGnSp <= 0.0_ReKi )  CALL SetErrStat( ErrID_Fatal, 'VS_RtGnSp must be greater than zero.', ErrStat, ErrMsg, RoutineName )
         IF ( InputFileData%VS_RtTq   < 0.0_ReKi  )  CALL SetErrStat( ErrID_Fatal, 'VS_RtTq must not be negative.', ErrStat, ErrMsg, RoutineName )
         IF ( InputFileData%VS_Rgn2K  < 0.0_ReKi  )  CALL SetErrStat( ErrID_Fatal, 'VS_Rgn2K must not be negative.', ErrStat, ErrMsg, RoutineName )
         IF ( InputFileData%VS_Rgn2K*InputFileData%VS_RtGnSp**2 >  InputFileData%VS_RtTq )  &
            CALL SetErrStat( ErrID_Fatal, 'VS_Rgn2K*VS_RtGnSp^2 must not be greater than VS_RtTq.', ErrStat, ErrMsg, RoutineName )
         IF ( InputFileData%VS_SlPc  <= 0.0_ReKi  )  CALL SetErrStat( ErrID_Fatal, 'VS_SlPc must be greater than zero.', ErrStat, ErrMsg, RoutineName )
      
         ! checks for generator models (VSControl == 0):           
      ELSE IF ( InputFileData%VSContrl == ControlMode_NONE ) THEN
      
         IF ( InputFileData%GenModel /= ControlMode_SIMPLE .AND. InputFileData%GenModel /= ControlMode_ADVANCED .AND. InputFileData%GenModel /= ControlMode_USER )  THEN
            CALL SetErrStat( ErrID_Fatal, 'GenModel must be either 1, 2, or 3.', ErrStat, ErrMsg, RoutineName )
         ENDIF            
      
            ! checks for simple induction generator (VSControl=0 & GenModel=1):      
         IF ( InputFileData%GenModel == ControlMode_SIMPLE ) THEN
            IF ( InputFileData%SIG_SlPc <= 0.0_ReKi )  CALL SetErrStat( ErrID_Fatal, 'SIG_SlPc must be greater than zero.', ErrStat, ErrMsg, RoutineName )
            IF ( InputFileData%SIG_SySp <= 0.0_ReKi )  CALL SetErrStat( ErrID_Fatal, 'SIG_SySp must be greater than zero.', ErrStat, ErrMsg, RoutineName )
            IF ( InputFileData%SIG_RtTq <= 0.0_ReKi )  CALL SetErrStat( ErrID_Fatal, 'SIG_RtTq must be greater than zero.', ErrStat, ErrMsg, RoutineName )
            IF ( InputFileData%SIG_PORt <  1.0_ReKi )  CALL SetErrStat( ErrID_Fatal, 'SIG_PORt must not be less than 1.'  , ErrStat, ErrMsg, RoutineName )
         
            ! checks for Thevenin-equivalent induction generator (VSControl=0 & GenModel=2):
         ELSE IF ( InputFileData%GenModel == ControlMode_ADVANCED ) THEN
            IF ( InputFileData%TEC_Freq <= 0.0_ReKi ) CALL SetErrStat( ErrID_Fatal, 'TEC_Freq must be greater than zero.', ErrStat, ErrMsg, RoutineName )
            IF ( InputFileData%TEC_NPol <= 0_IntKi .OR. MOD( InputFileData%TEC_NPol, 2_IntKi ) /= 0_IntKi ) &
                                       CALL SetErrStat( ErrID_Fatal, 'TEC_NPol must be an even number greater than zero.', ErrStat, ErrMsg, RoutineName )
            IF ( InputFileData%TEC_SRes <= 0.0_ReKi ) CALL SetErrStat( ErrID_Fatal, 'TEC_SRes must be greater than zero.', ErrStat, ErrMsg, RoutineName )
            IF ( InputFileData%TEC_RRes <= 0.0_ReKi ) CALL SetErrStat( ErrID_Fatal, 'TEC_RRes must be greater than zero.', ErrStat, ErrMsg, RoutineName )
            IF ( InputFileData%TEC_VLL  <= 0.0_ReKi ) CALL SetErrStat( ErrID_Fatal, 'TEC_VLL must be greater than zero.' , ErrStat, ErrMsg, RoutineName )
            IF ( InputFileData%TEC_SLR  <= 0.0_ReKi ) CALL SetErrStat( ErrID_Fatal, 'TEC_SLR must be greater than zero.' , ErrStat, ErrMsg, RoutineName )
            IF ( InputFileData%TEC_RLR  <= 0.0_ReKi ) CALL SetErrStat( ErrID_Fatal, 'TEC_RLR must be greater than zero.' , ErrStat, ErrMsg, RoutineName )
            IF ( InputFileData%TEC_MR   <= 0.0_ReKi ) CALL SetErrStat( ErrID_Fatal, 'TEC_MR must be greater than zero.'  , ErrStat, ErrMsg, RoutineName )
         END IF      
      
      END IF
                        
   END SUBROUTINE Torque_ValidateData
   !-------------------------------------------------------------------------------------------------------------------------------
   !> This routine performs the checks on inputs for the high-speed shaft brake.   
   SUBROUTINE HSSBr_ValidateData( )
   
            ! Some special checks based on whether inputs will come from external source (e.g., Simulink, LabVIEW)
      IF ( .NOT. Cmpl4SFun .AND. .NOT. Cmpl4LV ) THEN
               
         IF ( InputFileData%HSSBrMode == ControlMode_EXTERN )  THEN
            CALL SetErrStat( ErrID_Fatal, 'HSSBrMode can be '//TRIM(Num2LStr(ControlMode_EXTERN))//' only when implemented in Simulink or LabVIEW.', ErrStat, ErrMsg, RoutineName )
         ENDIF
      
      END IF

         ! checks for high-speed shaft brake:       
      IF ( InputFileData%HSSBrMode /= ControlMode_NONE .and. &
              InputFileData%HSSBrMode /= ControlMode_SIMPLE .and. InputFileData%HSSBrMode /= ControlMode_USER )  THEN
         IF ( InputFileData%HSSBrMode /= ControlMode_DLL .and. InputFileData%HSSBrMode /= ControlMode_EXTERN ) &      
                                                CALL SetErrStat( ErrID_Fatal, 'HSSBrMode must be 0, 1, 3, 4, or 5.', ErrStat, ErrMsg, RoutineName )
      END IF
      IF ( InputFileData%THSSBrDp < 0.0_DbKi )  CALL SetErrStat( ErrID_Fatal, 'THSSBrDp must not be negative.', ErrStat, ErrMsg, RoutineName )
      IF ( InputFileData%HSSBrDT  < 0.0_ReKi )  CALL SetErrStat( ErrID_Fatal, 'HSSBrDT must not be negative.', ErrStat, ErrMsg, RoutineName )
      IF ( InputFileData%HSSBrTqF < 0.0_ReKi )  CALL SetErrStat( ErrID_Fatal, 'HSSBrTqF must not be negative.', ErrStat, ErrMsg, RoutineName )
            
   END SUBROUTINE HSSBr_ValidateData
   !-------------------------------------------------------------------------------------------------------------------------------
END SUBROUTINE ValidatePrimaryData
!----------------------------------------------------------------------------------------------------------------------------------
!> This subroutine sets the parameters, based on the data stored in InputFileData.
SUBROUTINE SrvD_SetParameters( InputFileData, p, ErrStat, ErrMsg )
!..................................................................................................................................

   TYPE(SrvD_InputFile),     INTENT(INOUT)    :: InputFileData  !< Data stored in the module's input file (intent OUT for MOVE_ALLOC)
   TYPE(SrvD_ParameterType), INTENT(INOUT)    :: p              !< The module's parameter data
   INTEGER(IntKi),           INTENT(OUT)      :: ErrStat        !< The error status code
   CHARACTER(*),             INTENT(OUT)      :: ErrMsg         !< The error message, if an error occurred

      ! Local variables
   REAL(ReKi)                                 :: ComDenom       ! Common denominator of variables used in the TEC model
   REAL(ReKi)                                 :: SIG_RtSp       ! Rated speed
   REAL(ReKi)                                 :: TEC_K1         ! K1 term for Thevenin-equivalent circuit
   REAL(ReKi)                                 :: TEC_K2         ! K2 term for Thevenin-equivalent circuit
   
   INTEGER(IntKi)                             :: ErrStat2       ! Temporary error ID   
   CHARACTER(ErrMsgLen)                       :: ErrMsg2        ! Temporary message describing error
   CHARACTER(*), PARAMETER                    :: RoutineName = 'SrvD_SetParameters'


   
      ! Initialize variables

   ErrStat = ErrID_None
   ErrMsg  = ''


   p%DT = InputFileData%DT
   
      !.............................................
      ! Pitch control parameters
      !.............................................
      
   p%PCMode   = InputFileData%PCMode
   p%TPCOn    = InputFileData%TPCOn      

   CALL AllocAry( p%TPitManS, p%NumBl, 'TPitManS', ErrStat2, ErrMsg2 ); CALL SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
   CALL AllocAry( p%BlPitchF, p%NumBl, 'BlPitchF', ErrStat2, ErrMsg2 ); CALL SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
   CALL AllocAry( p%PitManRat, p%NumBl, 'PitManRat', ErrStat2, ErrMsg2 ); CALL SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
      IF (ErrStat >= AbortErrLev) RETURN  
      
   p%TPitManS  = InputFileData%TPitManS(1:p%NumBl)
   p%BlPitchF  = InputFileData%BlPitchF(1:p%NumBl)
   p%PitManRat = InputFileData%PitManRat(1:p%NumBl)

      !.............................................
      ! Set generator and torque control parameters:
      !.............................................
   p%VSContrl  = InputFileData%VSContrl
   p%GenModel  = InputFileData%GenModel
   p%GenEff    = InputFileData%GenEff
   p%GenTiStr  = InputFileData%GenTiStr
   p%GenTiStp  = InputFileData%GenTiStp
   p%SpdGenOn  = InputFileData%SpdGenOn
   p%TimGenOn  = InputFileData%TimGenOn
   p%TimGenOf  = InputFileData%TimGenOf
   
   
   p%THSSBrFl  = InputFileData%THSSBrDp + InputFileData%HSSBrDT   ! Time at which shaft brake is fully deployed
   
   SELECT CASE ( p%VSContrl )      
   CASE ( ControlMode_NONE )  ! None
      
      IF ( p%GenModel == ControlMode_SIMPLE )     THEN   ! Simple induction generator

           SIG_RtSp  = InputFileData%SIG_SySp*( 1.0 + InputFileData%SIG_SlPc )                                      ! Rated speed
         p%SIG_POSl  = InputFileData%SIG_PORt*( SIG_RtSp - InputFileData%SIG_SySp )                                 ! Pullout slip
         p%SIG_POTq  = InputFileData%SIG_RtTq*InputFileData%SIG_PORt                                                ! Pullout torque
         p%SIG_Slop  = InputFileData%SIG_RtTq/( SIG_RtSp - InputFileData%SIG_SySp )                                 ! SIG torque/speed slope

         p%SIG_SySp = InputFileData%SIG_SySp
      ELSEIF ( p%GenModel == ControlMode_ADVANCED )  THEN   ! Thevenin-equivalent induction generator

         ComDenom    = InputFileData%TEC_SRes**2 + ( InputFileData%TEC_SLR + InputFileData%TEC_MR )**2   ! common denominator used in many of the following equations
         
         p%TEC_Re1   = InputFileData%TEC_SRes*( InputFileData%TEC_MR**2 )/ComDenom                       ! Thevenin's equivalent stator resistance (ohms)
         p%TEC_Xe1   = InputFileData%TEC_MR*( InputFileData%TEC_SRes**2 + InputFileData%TEC_SLR* &
                                    ( InputFileData%TEC_SLR + InputFileData%TEC_MR) )/ComDenom           ! Thevenin's equivalent stator leakage reactance (ohms)
         p%TEC_V1a   = InputFileData%TEC_MR*InputFileData%TEC_VLL/SQRT( 3.0*ComDenom )                   ! Thevenin equivalent source voltage
         p%TEC_SySp  = 4.0*Pi*InputFileData%TEC_Freq/InputFileData%TEC_NPol                              ! Thevenin equivalent synchronous speed
           TEC_K1    = ( p%TEC_Xe1 + InputFileData%TEC_RLR )**2                                          ! Thevenin equivalent K1 term
           TEC_K2    = ( InputFileData%TEC_MR**2 )/ComDenom                                              ! Thevenin equivalent K2 term
         p%TEC_A0    = InputFileData%TEC_RRes*TEC_K2/p%TEC_SySp                                          ! Thevenin equivalent A0 term
         p%TEC_C0    = InputFileData%TEC_RRes**2                                                         ! Thevenin equivalent C0 term
         p%TEC_C1    = -2.0*p%TEC_Re1*InputFileData%TEC_RRes                                             ! Thevenin equivalent C1 term
         p%TEC_C2    = p%TEC_Re1**2 + TEC_K1                                                             ! Thevenin equivalent C2 term

         p%TEC_MR    = InputFileData%TEC_MR
         p%TEC_RLR   = InputFileData%TEC_RLR
         p%TEC_RRes  = InputFileData%TEC_RRes
         p%TEC_SRes  = InputFileData%TEC_SRes
         p%TEC_VLL   = InputFileData%TEC_VLL

      ENDIF
         
      
   CASE ( ControlMode_SIMPLE ) ! Simple variable-speed control
      
      p%VS_SySp   = InputFileData%VS_RtGnSp/( 1.0 +  InputFileData%VS_SlPc )                                            ! Synchronous speed of region 2 1/2 induction generator.
      IF ( InputFileData%VS_SlPc < SQRT(EPSILON(InputFileData%VS_SlPc) ) ) THEN                                         ! We don't have a region 2 so we'll use VS_TrGnSp = VS_RtGnSp
         p%VS_Slope = 9999.9
         p%VS_TrGnSp = InputFileData%VS_RtGnSp
      ELSE
         p%VS_Slope  = InputFileData%VS_RtTq  /( InputFileData%VS_RtGnSp - p%VS_SySp )                                  ! Torque/speed slope of region 2 1/2 induction generator.
         IF ( ABS(InputFileData%VS_Rgn2K) < EPSILON(InputFileData%VS_SlPc) )  THEN  ! .TRUE. if the Region 2 torque is flat, and thus, the denominator in the ELSE condition is zero
            p%VS_TrGnSp = p%VS_SySp                                                                                     ! Transitional generator speed between regions 2 and 2 1/2.
         ELSE                          ! .TRUE. if the Region 2 torque is quadratic with speed
            p%VS_TrGnSp = ( p%VS_Slope - SQRT( p%VS_Slope*( p%VS_Slope - 4.0*InputFileData%VS_Rgn2K*p%VS_SySp ) ) ) &
                              / ( 2.0*InputFileData%VS_Rgn2K )                                                          ! Transitional generator speed between regions 2 and 2 1/2.
         ENDIF
      END IF
   
      p%VS_Rgn2K   = InputFileData%VS_Rgn2K
      p%VS_RtGnSp  = InputFileData%VS_RtGnSp
      p%VS_RtTq    = InputFileData%VS_RtTq
      
   END SELECT 
      
      !.............................................
      ! High-speed shaft brake parameters
      !.............................................   
   p%HSSBrMode = InputFileData%HSSBrMode
   p%THSSBrDp  = InputFileData%THSSBrDp
   p%HSSBrDT   = InputFileData%HSSBrDT
   p%HSSBrTqF  = InputFileData%HSSBrTqF
         
      !.............................................
      ! Nacelle-yaw control parameters
      !.............................................
   p%YCMode    = InputFileData%YCMode
   p%TYCOn     = InputFileData%TYCOn
   p%YawNeut   = InputFileData%YawNeut !bjj: this should be renamed...
   p%YawSpr    = InputFileData%YawSpr
   p%YawDamp   = InputFileData%YawDamp

   p%TYawManS  = InputFileData%TYawManS   
   p%NacYawF   = InputFileData%NacYawF   
   p%YawManRat = InputFileData%YawManRat              ! we change the sign of this variable later
      
      !.............................................
      ! tip-brake parameters (not used in this version)
      !.............................................
   CALL AllocAry( p%TBDepISp, p%NumBl, 'TBDepISp', ErrStat2, ErrMsg2 )  ! Deployment-initiation speed for the tip brakes
      CALL SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
      IF (ErrStat >= AbortErrLev) RETURN  
   
   p%TBDepISp = HUGE(p%TBDepISp) ! Deployment-initiation speed for the tip brakes: basically never deploy them. Eventually this will be added back?
   !p%TBDepISp  = InputFileData%TBDepISp*RPM2RPS

   p%TpBrDT   = HUGE(p%TpBrDT)   ! Time for tip brakes to reach full deployment, once deployed
   p%TBDrConN = 0.0_ReKi         ! tip-drag constant during normal operation
   p%TBDrConD = 0.0_ReKi         ! tip-drag constant during fully deployed operation
   
      
      !.............................................
      ! Tuned-mass damper parameters
      !.............................................   
   p%CompNStC     = InputFileData%CompNStC
   p%CompTStC     = InputFileData%CompTStC
   p%CompBStC     = InputFileData%CompBStC
   p%CompPtfmStC  = InputFileData%CompPtfmStC

      !.............................................
      ! Determine if the BladedDLL should be called
      !.............................................
   
   IF ( p%PCMode    == ControlMode_DLL .OR. &
        p%YCMode    == ControlMode_DLL .OR. &        
        p%VSContrl  == ControlMode_DLL .OR. &
        p%HSSBrMode == ControlMode_DLL      ) THEN
      
      p%UseBladedInterface = .TRUE.   
      
   ELSE
      p%UseBladedInterface = .FALSE. 
   END IF
   
      !.............................................
      ! Parameters for file output (not including Bladed DLL logging outputs)
      !.............................................
   p%NumOuts = InputFileData%NumOuts
   p%NumOuts_DLL = 0 ! set to zero and overwritten if/when the DLL uses it
      
   CALL SetOutParam(InputFileData%OutList, p, ErrStat2, ErrMsg2 ) ! requires: p%NumOuts, p%NumBl; sets: p%OutParam.
      CALL SetErrStat(ErrStat2,ErrMsg2,ErrStat,ErrMsg,RoutineName)
      IF (ErrStat >= AbortErrLev) RETURN  
      
   IF ( InputFileData%TabDelim ) THEN
      p%Delim = TAB
   ELSE
      p%Delim = ' '
   END IF           
             

END SUBROUTINE SrvD_SetParameters
!----------------------------------------------------------------------------------------------------------------------------------
!> Routine for computing the yaw output: a yaw moment. This routine is used in both loose and tight coupling.
SUBROUTINE Yaw_CalcOutput( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg )
!..................................................................................................................................

   REAL(DbKi),                     INTENT(IN   )  :: t           !< Current simulation time in seconds
   TYPE(SrvD_InputType),           INTENT(IN   )  :: u           !< Inputs at t
   TYPE(SrvD_ParameterType),       INTENT(IN   )  :: p           !< Parameters
   TYPE(SrvD_ContinuousStateType), INTENT(IN   )  :: x           !< Continuous states at t
   TYPE(SrvD_DiscreteStateType),   INTENT(IN   )  :: xd          !< Discrete states at t
   TYPE(SrvD_ConstraintStateType), INTENT(IN   )  :: z           !< Constraint states at t
   TYPE(SrvD_OtherStateType),      INTENT(IN   )  :: OtherState  !< Other states at t
   TYPE(SrvD_OutputType),          INTENT(INOUT)  :: y           !< Outputs computed at t (Input only so that mesh con-
                                                                 !!   nectivity information does not have to be recalculated)
   TYPE(SrvD_MiscVarType),         INTENT(INOUT)  :: m           !< Misc (optimization) variables
   INTEGER(IntKi),                 INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                   INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None
  
      ! local variables      
   REAL(ReKi)                                     :: YawPosCom   ! Commanded yaw angle from user-defined routines, rad.
   REAL(ReKi)                                     :: YawRateCom  ! Commanded yaw rate  from user-defined routines, rad/s.
   REAL(ReKi)                                     :: YawPosComInt ! Integrated yaw commanded (from DLL), rad

      ! Initialize ErrStat

   ErrStat = ErrID_None
   ErrMsg  = ""

   !...................................................................
   ! Override standard yaw control with a linear maneuver if necessary:
   !...................................................................

   IF ( OtherState%BegYawMan )  THEN  ! Override yaw maneuver is occuring.
      
      IF ( t >= OtherState%TYawManE )  THEN   ! Override yaw maneuver has ended; yaw command is fixed at NacYawF

         YawPosCom     = p%NacYawF
         YawRateCom    = 0.0_ReKi

      ELSE                             ! Override yaw maneuver in linear ramp

            ! Increment the command yaw and rate using YawManRat         
         YawRateCom    = SIGN( p%YawManRat, p%NacYawF - OtherState%NacYawI )             ! Modify the sign of p%YawManRat based on the direction of the yaw maneuever
         YawPosCom     = OtherState%NacYawI + YawRateCom*( t - p%TYawManS )

      ENDIF
      
   ELSE
      
      if (p%YCMode == ControlMode_DLL) then
         if (m%dll_data%Yaw_Cntrl == GH_DISCON_YAW_CONTROL_TORQUE .or. m%dll_data%OverrideYawRateWithTorque) then
       
            y%YawMom = m%dll_data%YawTorqueDemand

            return
         end if
      end if
      
      !...................................................................
      ! Calculate standard yaw position and rate commands:
      !...................................................................

      YawPosComInt = OtherState%YawPosComInt    ! get state value.  We don't update the state here.
      CALL CalculateStandardYaw(t, u, p, m, YawPosCom, YawRateCom, YawPosComInt, ErrStat, ErrMsg)
      
   END IF
   !...................................................................
   ! Calculate the yaw moment:
   !...................................................................
      
   y%YawMom = - p%YawSpr *( u%Yaw     - YawPosCom  )     &          ! {-f(qd,q,t)}SpringYaw
              - p%YawDamp*( u%YawRate - YawRateCom )                ! {-f(qd,q,t)}DampYaw;
   
   
   !...................................................................
   ! Apply trim case for linearization:
   ! prescribed yaw will be wrong in this case.....
   !...................................................................
   if (p%TrimCase==TrimCase_yaw) then
      y%YawMom = y%YawMom + xd%CtrlOffset * p%YawSpr
   end if
      
   
END SUBROUTINE Yaw_CalcOutput
!----------------------------------------------------------------------------------------------------------------------------------
!> Routine that calculates standard yaw position and rate commands: YawPosCom and YawRateCom.
SUBROUTINE CalculateStandardYaw(t, u, p, m, YawPosCom, YawRateCom, YawPosComInt, ErrStat, ErrMsg)

   REAL(DbKi),                     INTENT(IN   )  :: t            !< Current simulation time in seconds
   TYPE(SrvD_InputType),           INTENT(IN   )  :: u            !< Inputs at t
   TYPE(SrvD_ParameterType),       INTENT(IN   )  :: p            !< Parameters
   TYPE(SrvD_MiscVarType),         INTENT(INOUT)  :: m            !< Misc (optimization) variables
   REAL(ReKi),                     INTENT(  OUT)  :: YawPosCom    !< Commanded yaw angle from user-defined routines, rad.
   REAL(ReKi),                     INTENT(  OUT)  :: YawRateCom   !< Commanded yaw rate  from user-defined routines, rad/s.
   REAL(ReKi),                     INTENT(INOUT)  :: YawPosComInt !< Internal variable that integrates the commanded yaw rate and passes it to YawPosCom
   INTEGER(IntKi),                 INTENT(  OUT)  :: ErrStat      !< Error status of the operation
   CHARACTER(*),                   INTENT(  OUT)  :: ErrMsg       !< Error message if ErrStat /= ErrID_None

   ErrStat = ErrID_None
   ErrMsg  = ""

   !...................................................................
   ! Calculate standard yaw position and rate commands:
   !...................................................................

         
   IF ( t >= p%TYCOn  .AND.  p%YCMode /= ControlMode_NONE )  THEN   ! Time now to enable active yaw control.


      SELECT CASE ( p%YCMode )  ! Which yaw control mode are we using? (we already took care of ControlMode_None)
            
         CASE ( ControlMode_SIMPLE )            ! Simple ... BJJ: THIS will be NEW

            
         CASE ( ControlMode_USER )              ! User-defined from routine UserYawCont().
         
            CALL UserYawCont ( u%Yaw, u%YawRate, u%WindDir, u%YawErr, p%NumBl, t, p%DT, p%RootName, YawPosCom, YawRateCom )         

         CASE ( ControlMode_EXTERN )              ! User-defined from Simulink or LabVIEW

            YawPosCom  = u%ExternalYawPosCom
            YawRateCom = u%ExternalYawRateCom

         CASE ( ControlMode_DLL )                                ! User-defined yaw control from Bladed-style DLL
            
            YawPosComInt   = YawPosComInt + m%dll_data%YawRateCom*p%DT     ! Integrated yaw position
            YawPosCom      = YawPosComInt !bjj: was this: LastYawPosCom + YawRateCom*( ZTime - LastTime )
            YawRateCom     =                m%dll_data%YawRateCom
            
            if (m%dll_data%OverrideYawRateWithTorque .or. m%dll_data%Yaw_Cntrl == GH_DISCON_YAW_CONTROL_TORQUE) then
               call SetErrStat(ErrID_Fatal, "Unable to calculate yaw rate control because yaw torque control (or override) was requested from DLL.", ErrStat, ErrMsg, "CalculateStandardYaw")
               return
            end if
            
      END SELECT


   ELSE  ! Do not control yaw, maintain initial (neutral) yaw angles
      
         YawPosCom  = p%YawNeut
         YawRateCom = 0.0_ReKi

   ENDIF     
   
END SUBROUTINE CalculateStandardYaw
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine updates the other states associated with the yaw controller: BegYawMan, NacYawI, and TYawManE.
SUBROUTINE Yaw_UpdateStates( t, u, p, x, xd, z, OtherState, m, ErrStat, ErrMsg )
!..................................................................................................................................

   REAL(DbKi),                      INTENT(IN   ) :: t           !< t+dt
   TYPE(SrvD_InputType),            INTENT(IN   ) :: u           !< Inputs at t+dt
   TYPE(SrvD_ParameterType),        INTENT(IN   ) :: p           !< Parameters
   TYPE(SrvD_ContinuousStateType),  INTENT(INOUT) :: x           !< Input: Continuous states at t;
                                                                 !!   Output: Continuous states at t + dt
   TYPE(SrvD_DiscreteStateType),    INTENT(INOUT) :: xd          !< Input: Discrete states at t;
                                                                 !!   Output: Discrete states at t + dt
   TYPE(SrvD_ConstraintStateType),  INTENT(INOUT) :: z           !< Input: Constraint states at t;
                                                                 !!   Output: Constraint states at t + dt
   TYPE(SrvD_OtherStateType),       INTENT(INOUT) :: OtherState  !< Other states: Other states at t;
                                                                 !!   Output: Other states at t + dt
   TYPE(SrvD_MiscVarType),         INTENT(INOUT)  :: m           !< Misc (optimization) variables
   INTEGER(IntKi),                 INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                   INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None
  
      ! local variables      
   REAL(ReKi)                                     :: YawPosCom   ! Commanded yaw angle from user-defined routines, rad.
   REAL(ReKi)                                     :: YawRateCom  ! Commanded yaw rate  from user-defined routines, rad/s.
   REAL(ReKi)                                     :: YawManRat   ! Yaw maneuver rate, rad/s
   

         ! Initialize ErrStat

      ErrStat = ErrID_None
      ErrMsg  = ""


   !...................................................................
   ! Determine if override of standard yaw control with a linear maneuver is necessary:
   !...................................................................

   IF ( t >= p%TYawManS )  THEN  ! Override yaw maneuver is occuring.


      IF ( .not. OtherState%BegYawMan )  THEN  ! Override yaw maneuver is just beginning (possibly again).

         CALL CalculateStandardYaw(t, u, p, m, YawPosCom, YawRateCom, OtherState%YawPosComInt, ErrStat, ErrMsg)
         
         OtherState%NacYawI   = YawPosCom  !bjj: was u%Yaw                                    ! Store the initial (current) yaw, at the start of the yaw maneuver
         YawManRat            = SIGN( p%YawManRat, p%NacYawF - OtherState%NacYawI )           ! Modify the sign of YawManRat based on the direction of the yaw maneuever
         OtherState%TYawManE  = p%TYawManS + ( p%NacYawF - OtherState%NacYawI ) / YawManRat   ! Calculate the end time of the override yaw maneuver         

         OtherState%BegYawMan = .TRUE.                                                        ! Let's remember when we stored this these values

      ENDIF

   ELSE

      !...................................................................
      ! Update OtherState%YawPosComInt:
      !...................................................................
      CALL CalculateStandardYaw(t, u, p, m, YawPosCom, YawRateCom, OtherState%YawPosComInt, ErrStat, ErrMsg)
   
   ENDIF
                
   
END SUBROUTINE Yaw_UpdateStates
!----------------------------------------------------------------------------------------------------------------------------------
!> Routine for computing the pitch output: blade pitch commands. This routine is used in both loose and tight coupling.
SUBROUTINE Pitch_CalcOutput( t, u, p, x, xd, z, OtherState, BlPitchCom, ElecPwr, m, ErrStat, ErrMsg )
!..................................................................................................................................

   REAL(DbKi),                     INTENT(IN   )  :: t           !< Current simulation time in seconds
   TYPE(SrvD_InputType),           INTENT(IN   )  :: u           !< Inputs at t
   TYPE(SrvD_ParameterType),       INTENT(IN   )  :: p           !< Parameters
   TYPE(SrvD_ContinuousStateType), INTENT(IN   )  :: x           !< Continuous states at t
   TYPE(SrvD_DiscreteStateType),   INTENT(IN   )  :: xd          !< Discrete states at t
   TYPE(SrvD_ConstraintStateType), INTENT(IN   )  :: z           !< Constraint states at t
   TYPE(SrvD_OtherStateType),      INTENT(IN   )  :: OtherState  !< Other states at t
   REAL(ReKi),                     INTENT(INOUT)  :: BlPitchCom(:) !< pitch outputs computed at t (Input only so that mesh con-
                                                                 !!   nectivity information does not have to be recalculated)
   REAL(ReKi),                     INTENT(IN )    :: ElecPwr     !< Electrical power (watts)
   TYPE(SrvD_MiscVarType),         INTENT(INOUT)  :: m           !< Misc (optimization) variables
   INTEGER(IntKi),                 INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                   INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None
  
      ! local variables      
   REAL(ReKi)                                     :: factor
   REAL(ReKi)                                     :: PitManRat
   INTEGER(IntKi)                                 :: K           ! counter for blades

   

         ! Initialize ErrStat

      ErrStat = ErrID_None
      ErrMsg  = ""


   !...................................................................
   ! Calculate standard pitch position and rate commands:
   !...................................................................
      ! Control pitch if requested:                  
      
   IF ( t >= p%TPCOn .AND.  p%PCMode /= ControlMode_NONE )  THEN   ! Time now to enable active pitch control.


      SELECT CASE ( p%PCMode )  ! Which pitch control mode are we using?

         CASE ( ControlMode_SIMPLE )            ! Simple, built-in pitch-control routine.
         
            ! bjj: add this!
            
         CASE ( ControlMode_USER )              ! User-defined from routine PitchCntrl().

            CALL PitchCntrl ( u%BlPitch, ElecPwr, u%LSS_Spd, u%TwrAccel, p%NumBl, t, p%DT, p%RootName, BlPitchCom )

         CASE ( ControlMode_EXTERN )              ! User-defined from Simulink or LabVIEW.

            BlPitchCom = u%ExternalBlPitchCom                ! copy entire array
         
         CASE ( ControlMode_DLL )                                ! User-defined pitch control from Bladed-style DLL
            
            
            if (p%DLL_Ramp) then
               factor = (t - m%LastTimeCalled) / m%dll_data%DLL_DT
               BlPitchCom = m%dll_data%PrevBlPitch(1:p%NumBl) + &
                                 factor * ( m%dll_data%BlPitchCom(1:p%NumBl) - m%dll_data%PrevBlPitch(1:p%NumBl) )
            else
               BlPitchCom = m%dll_data%BlPitchCom(1:p%NumBl)
            end if
            
               ! update the filter state once per time step
            IF ( EqualRealNos( t - p%DT, m%LastTimeFiltered ) ) THEN
               m%xd_BlPitchFilter = p%BlAlpha * m%xd_BlPitchFilter + (1.0_ReKi - p%BlAlpha) * BlPitchCom
               m%LastTimeFiltered = t
            END IF
            
            BlPitchCom = p%BlAlpha * m%xd_BlPitchFilter + (1.0_ReKi - p%BlAlpha) * BlPitchCom
            
      END SELECT

   ELSE                          ! Do not control pitch yet, maintain initial pitch angles.

      ! Use the initial blade pitch angles:

      BlPitchCom = p%BlPitchInit

   ENDIF


   !...................................................................
   ! Override standard pitch control with a linear maneuver if necessary:
   !...................................................................

   DO K = 1,p%NumBl ! Loop through all blades


      IF ( OtherState%BegPitMan(K) )  THEN  ! Override pitch maneuver is occuring for this blade.
      
         IF ( t >= OtherState%TPitManE(K) )  THEN      ! Override pitch maneuver has ended, blade is locked at BlPitchF.

            BlPitchCom(K) = p%BlPitchF(K)

         ELSE  

            PitManRat     = SIGN( p%PitManRat(K), p%BlPitchF(K) - OtherState%BlPitchI(K) )   ! Modify the sign of PitManRat based on the direction of the pitch maneuever
            BlPitchCom(K) = OtherState%BlPitchI(K) + PitManRat*( t - p%TPitManS(K) )         ! Increment the blade pitch using PitManRat
         
         END IF                  
      
      ENDIF
 
   
   ENDDO ! K - blades   
         
   !...................................................................
   ! Apply trim case for linearization:
   !...................................................................
   if (p%TrimCase==TrimCase_pitch) then
      BlPitchCom = BlPitchCom + xd%CtrlOffset
   end if
   
   
END SUBROUTINE Pitch_CalcOutput
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine updates the continuous and other states associated with the pitch controller: BegPitMan, BlPitchI, and TPitManE.
SUBROUTINE Pitch_UpdateStates( t, u, p, x, xd, z, OtherState, m, ErrStat, ErrMsg )
!..................................................................................................................................

   REAL(DbKi),                      INTENT(IN   ) :: t           !< t+dt
   TYPE(SrvD_InputType),            INTENT(IN   ) :: u           !< Inputs at t+dt
   TYPE(SrvD_ParameterType),        INTENT(IN   ) :: p           !< Parameters
   TYPE(SrvD_ContinuousStateType),  INTENT(INOUT) :: x           !< Input: Continuous states at t;
                                                                 !!   Output: Continuous states at t + dt
   TYPE(SrvD_DiscreteStateType),    INTENT(INOUT) :: xd          !< Input: Discrete states at t;
                                                                 !!   Output: Discrete states at t + dt
   TYPE(SrvD_ConstraintStateType),  INTENT(INOUT) :: z           !< Input: Constraint states at t;
                                                                 !!   Output: Constraint states at t + dt
   TYPE(SrvD_OtherStateType),       INTENT(INOUT) :: OtherState  !< Other states: Other states at t;
                                                                 !!   Output: Other states at t + dt
   TYPE(SrvD_MiscVarType),         INTENT(INOUT)  :: m           !< Misc (optimization) variables
   INTEGER(IntKi),                 INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                   INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None
  
      ! local variables      
   REAL(ReKi)                                     :: PitManRat
   INTEGER(IntKi)                                 :: K           ! counter for blades

   

      ! Initialize ErrStat

   ErrStat = ErrID_None
   ErrMsg  = ""


   !...................................................................
   ! Override standard pitch control with a linear maneuver if necessary:
   !...................................................................

   DO K = 1,p%NumBl ! Loop through all blades


      IF ( t >= p%TPitManS(K) )  THEN  ! Override pitch maneuver is occuring for this blade.


         IF ( .not. OtherState%BegPitMan(K) )  THEN  ! Override pitch maneuver is just beginning.

            OtherState%BlPitchI (K) = u%BlPitch(K)                                                                ! Store the initial (current) pitch, at the start of the pitch maneuver.

            PitManRat               = SIGN( p%PitManRat(K), p%BlPitchF(K) - OtherState%BlPitchI(K) )              ! Modify the sign of PitManRat based on the direction of the pitch maneuever
            OtherState%TPitManE (K) = p%TPitManS(K) + ( p%BlPitchF(K) - OtherState%BlPitchI(K) )/PitManRat        ! Calculate the end time of the override pitch maneuver      
         
            OtherState%BegPitMan(K) = .TRUE.

         ENDIF
                              
      ENDIF
    
   ENDDO ! K - blades   
      
      
END SUBROUTINE Pitch_UpdateStates
!----------------------------------------------------------------------------------------------------------------------------------

!**********************************************************************************************************************************
! NOTE: The following lines of code were generated by a Matlab script called "Write_ChckOutLst.m"
!      using the parameters listed in the "OutListParameters.xlsx" Excel file. Any changes to these 
!      lines should be modified in the Matlab script and/or Excel worksheet as necessary. 
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine checks to see if any requested output channel names (stored in the OutList(:)) are invalid. It returns a 
!! warning if any of the channels are not available outputs from the module.
!!  It assigns the settings for OutParam(:) (i.e, the index, name, and units of the output channels, WriteOutput(:)).
!!  the sign is set to 0 if the channel is invalid.
!! It sets assumes the value p%NumOuts has been set before this routine has been called, and it sets the values of p%OutParam here.
!! 
!! This routine was generated by Write_ChckOutLst.m using the parameters listed in OutListParameters.xlsx at 05-Dec-2020 09:46:04.
SUBROUTINE SetOutParam(OutList, p, ErrStat, ErrMsg )
!..................................................................................................................................

   IMPLICIT                        NONE

      ! Passed variables

   CHARACTER(ChanLen),        INTENT(IN)     :: OutList(:)                        !< The list out user-requested outputs
   TYPE(SrvD_ParameterType),    INTENT(INOUT)  :: p                                 !< The module parameters
   INTEGER(IntKi),            INTENT(OUT)    :: ErrStat                           !< The error status code
   CHARACTER(*),              INTENT(OUT)    :: ErrMsg                            !< The error message, if an error occurred

      ! Local variables

   INTEGER                      :: ErrStat2                                        ! temporary (local) error status
   INTEGER                      :: I                                               ! Generic loop-counting index
   INTEGER                      :: J                                               ! Generic loop-counting index
   INTEGER                      :: INDX                                            ! Index for valid arrays

   LOGICAL                      :: CheckOutListAgain                               ! Flag used to determine if output parameter starting with "M" is valid (or the negative of another parameter)
   LOGICAL                      :: InvalidOutput(0:MaxOutPts)                      ! This array determines if the output channel is valid for this configuration
   CHARACTER(ChanLen)           :: OutListTmp                                      ! A string to temporarily hold OutList(I)
   CHARACTER(*), PARAMETER      :: RoutineName = "SetOutParam"

   CHARACTER(OutStrLenM1), PARAMETER  :: ValidParamAry(518) =  (/  &   ! This lists the names of the allowed parameters, which must be sorted alphabetically
                               "BLAIRFLC1   ","BLAIRFLC2   ","BLAIRFLC3   ","BLFLAP1     ","BLFLAP2     ","BLFLAP3     ", &
                               "BLPITCHC1   ","BLPITCHC2   ","BLPITCHC3   ","BSTC1_B1_FXI","BSTC1_B1_FXN","BSTC1_B1_FYI", &
                               "BSTC1_B1_FYN","BSTC1_B1_FZI","BSTC1_B1_FZN","BSTC1_B1_MXI","BSTC1_B1_MXN","BSTC1_B1_MYI", &
                               "BSTC1_B1_MYN","BSTC1_B1_MZI","BSTC1_B1_MZN","BSTC1_B1_XQ ","BSTC1_B1_XQD","BSTC1_B1_YQ ", &
                               "BSTC1_B1_YQD","BSTC1_B1_ZQ ","BSTC1_B1_ZQD","BSTC1_B2_FXI","BSTC1_B2_FXN","BSTC1_B2_FYI", &
                               "BSTC1_B2_FYN","BSTC1_B2_FZI","BSTC1_B2_FZN","BSTC1_B2_MXI","BSTC1_B2_MXN","BSTC1_B2_MYI", &
                               "BSTC1_B2_MYN","BSTC1_B2_MZI","BSTC1_B2_MZN","BSTC1_B2_XQ ","BSTC1_B2_XQD","BSTC1_B2_YQ ", &
                               "BSTC1_B2_YQD","BSTC1_B2_ZQ ","BSTC1_B2_ZQD","BSTC1_B3_FXI","BSTC1_B3_FXN","BSTC1_B3_FYI", &
                               "BSTC1_B3_FYN","BSTC1_B3_FZI","BSTC1_B3_FZN","BSTC1_B3_MXI","BSTC1_B3_MXN","BSTC1_B3_MYI", &
                               "BSTC1_B3_MYN","BSTC1_B3_MZI","BSTC1_B3_MZN","BSTC1_B3_XQ ","BSTC1_B3_XQD","BSTC1_B3_YQ ", &
                               "BSTC1_B3_YQD","BSTC1_B3_ZQ ","BSTC1_B3_ZQD","BSTC1_B4_FXI","BSTC1_B4_FXN","BSTC1_B4_FYI", &
                               "BSTC1_B4_FYN","BSTC1_B4_FZI","BSTC1_B4_FZN","BSTC1_B4_MXI","BSTC1_B4_MXN","BSTC1_B4_MYI", &
                               "BSTC1_B4_MYN","BSTC1_B4_MZI","BSTC1_B4_MZN","BSTC1_B4_XQ ","BSTC1_B4_XQD","BSTC1_B4_YQ ", &
                               "BSTC1_B4_YQD","BSTC1_B4_ZQ ","BSTC1_B4_ZQD","BSTC2_B1_FXI","BSTC2_B1_FXN","BSTC2_B1_FYI", &
                               "BSTC2_B1_FYN","BSTC2_B1_FZI","BSTC2_B1_FZN","BSTC2_B1_MXI","BSTC2_B1_MXN","BSTC2_B1_MYI", &
                               "BSTC2_B1_MYN","BSTC2_B1_MZI","BSTC2_B1_MZN","BSTC2_B1_XQ ","BSTC2_B1_XQD","BSTC2_B1_YQ ", &
                               "BSTC2_B1_YQD","BSTC2_B1_ZQ ","BSTC2_B1_ZQD","BSTC2_B2_FXI","BSTC2_B2_FXN","BSTC2_B2_FYI", &
                               "BSTC2_B2_FYN","BSTC2_B2_FZI","BSTC2_B2_FZN","BSTC2_B2_MXI","BSTC2_B2_MXN","BSTC2_B2_MYI", &
                               "BSTC2_B2_MYN","BSTC2_B2_MZI","BSTC2_B2_MZN","BSTC2_B2_XQ ","BSTC2_B2_XQD","BSTC2_B2_YQ ", &
                               "BSTC2_B2_YQD","BSTC2_B2_ZQ ","BSTC2_B2_ZQD","BSTC2_B3_FXI","BSTC2_B3_FXN","BSTC2_B3_FYI", &
                               "BSTC2_B3_FYN","BSTC2_B3_FZI","BSTC2_B3_FZN","BSTC2_B3_MXI","BSTC2_B3_MXN","BSTC2_B3_MYI", &
                               "BSTC2_B3_MYN","BSTC2_B3_MZI","BSTC2_B3_MZN","BSTC2_B3_XQ ","BSTC2_B3_XQD","BSTC2_B3_YQ ", &
                               "BSTC2_B3_YQD","BSTC2_B3_ZQ ","BSTC2_B3_ZQD","BSTC2_B4_FXI","BSTC2_B4_FXN","BSTC2_B4_FYI", &
                               "BSTC2_B4_FYN","BSTC2_B4_FZI","BSTC2_B4_FZN","BSTC2_B4_MXI","BSTC2_B4_MXN","BSTC2_B4_MYI", &
                               "BSTC2_B4_MYN","BSTC2_B4_MZI","BSTC2_B4_MZN","BSTC2_B4_XQ ","BSTC2_B4_XQD","BSTC2_B4_YQ ", &
                               "BSTC2_B4_YQD","BSTC2_B4_ZQ ","BSTC2_B4_ZQD","BSTC3_B1_FXI","BSTC3_B1_FXN","BSTC3_B1_FYI", &
                               "BSTC3_B1_FYN","BSTC3_B1_FZI","BSTC3_B1_FZN","BSTC3_B1_MXI","BSTC3_B1_MXN","BSTC3_B1_MYI", &
                               "BSTC3_B1_MYN","BSTC3_B1_MZI","BSTC3_B1_MZN","BSTC3_B1_XQ ","BSTC3_B1_XQD","BSTC3_B1_YQ ", &
                               "BSTC3_B1_YQD","BSTC3_B1_ZQ ","BSTC3_B1_ZQD","BSTC3_B2_FXI","BSTC3_B2_FXN","BSTC3_B2_FYI", &
                               "BSTC3_B2_FYN","BSTC3_B2_FZI","BSTC3_B2_FZN","BSTC3_B2_MXI","BSTC3_B2_MXN","BSTC3_B2_MYI", &
                               "BSTC3_B2_MYN","BSTC3_B2_MZI","BSTC3_B2_MZN","BSTC3_B2_XQ ","BSTC3_B2_XQD","BSTC3_B2_YQ ", &
                               "BSTC3_B2_YQD","BSTC3_B2_ZQ ","BSTC3_B2_ZQD","BSTC3_B3_FXI","BSTC3_B3_FXN","BSTC3_B3_FYI", &
                               "BSTC3_B3_FYN","BSTC3_B3_FZI","BSTC3_B3_FZN","BSTC3_B3_MXI","BSTC3_B3_MXN","BSTC3_B3_MYI", &
                               "BSTC3_B3_MYN","BSTC3_B3_MZI","BSTC3_B3_MZN","BSTC3_B3_XQ ","BSTC3_B3_XQD","BSTC3_B3_YQ ", &
                               "BSTC3_B3_YQD","BSTC3_B3_ZQ ","BSTC3_B3_ZQD","BSTC3_B4_FXI","BSTC3_B4_FXN","BSTC3_B4_FYI", &
                               "BSTC3_B4_FYN","BSTC3_B4_FZI","BSTC3_B4_FZN","BSTC3_B4_MXI","BSTC3_B4_MXN","BSTC3_B4_MYI", &
                               "BSTC3_B4_MYN","BSTC3_B4_MZI","BSTC3_B4_MZN","BSTC3_B4_XQ ","BSTC3_B4_XQD","BSTC3_B4_YQ ", &
                               "BSTC3_B4_YQD","BSTC3_B4_ZQ ","BSTC3_B4_ZQD","BSTC4_B1_FXI","BSTC4_B1_FXN","BSTC4_B1_FYI", &
                               "BSTC4_B1_FYN","BSTC4_B1_FZI","BSTC4_B1_FZN","BSTC4_B1_MXI","BSTC4_B1_MXN","BSTC4_B1_MYI", &
                               "BSTC4_B1_MYN","BSTC4_B1_MZI","BSTC4_B1_MZN","BSTC4_B1_XQ ","BSTC4_B1_XQD","BSTC4_B1_YQ ", &
                               "BSTC4_B1_YQD","BSTC4_B1_ZQ ","BSTC4_B1_ZQD","BSTC4_B2_FXI","BSTC4_B2_FXN","BSTC4_B2_FYI", &
                               "BSTC4_B2_FYN","BSTC4_B2_FZI","BSTC4_B2_FZN","BSTC4_B2_MXI","BSTC4_B2_MXN","BSTC4_B2_MYI", &
                               "BSTC4_B2_MYN","BSTC4_B2_MZI","BSTC4_B2_MZN","BSTC4_B2_XQ ","BSTC4_B2_XQD","BSTC4_B2_YQ ", &
                               "BSTC4_B2_YQD","BSTC4_B2_ZQ ","BSTC4_B2_ZQD","BSTC4_B3_FXI","BSTC4_B3_FXN","BSTC4_B3_FYI", &
                               "BSTC4_B3_FYN","BSTC4_B3_FZI","BSTC4_B3_FZN","BSTC4_B3_MXI","BSTC4_B3_MXN","BSTC4_B3_MYI", &
                               "BSTC4_B3_MYN","BSTC4_B3_MZI","BSTC4_B3_MZN","BSTC4_B3_XQ ","BSTC4_B3_XQD","BSTC4_B3_YQ ", &
                               "BSTC4_B3_YQD","BSTC4_B3_ZQ ","BSTC4_B3_ZQD","BSTC4_B4_FXI","BSTC4_B4_FXN","BSTC4_B4_FYI", &
                               "BSTC4_B4_FYN","BSTC4_B4_FZI","BSTC4_B4_FZN","BSTC4_B4_MXI","BSTC4_B4_MXN","BSTC4_B4_MYI", &
                               "BSTC4_B4_MYN","BSTC4_B4_MZI","BSTC4_B4_MZN","BSTC4_B4_XQ ","BSTC4_B4_XQD","BSTC4_B4_YQ ", &
                               "BSTC4_B4_YQD","BSTC4_B4_ZQ ","BSTC4_B4_ZQD","GENPWR      ","GENTQ       ","HSSBRTQC    ", &
                               "NSTC1_FXI   ","NSTC1_FXN   ","NSTC1_FYI   ","NSTC1_FYN   ","NSTC1_FZI   ","NSTC1_FZN   ", &
                               "NSTC1_MXI   ","NSTC1_MXN   ","NSTC1_MYI   ","NSTC1_MYN   ","NSTC1_MZI   ","NSTC1_MZN   ", &
                               "NSTC1_XQ    ","NSTC1_XQD   ","NSTC1_YQ    ","NSTC1_YQD   ","NSTC1_ZQ    ","NSTC1_ZQD   ", &
                               "NSTC2_FXI   ","NSTC2_FXN   ","NSTC2_FYI   ","NSTC2_FYN   ","NSTC2_FZI   ","NSTC2_FZN   ", &
                               "NSTC2_MXI   ","NSTC2_MXN   ","NSTC2_MYI   ","NSTC2_MYN   ","NSTC2_MZI   ","NSTC2_MZN   ", &
                               "NSTC2_XQ    ","NSTC2_XQD   ","NSTC2_YQ    ","NSTC2_YQD   ","NSTC2_ZQ    ","NSTC2_ZQD   ", &
                               "NSTC3_FXI   ","NSTC3_FXN   ","NSTC3_FYI   ","NSTC3_FYN   ","NSTC3_FZI   ","NSTC3_FZN   ", &
                               "NSTC3_MXI   ","NSTC3_MXN   ","NSTC3_MYI   ","NSTC3_MYN   ","NSTC3_MZI   ","NSTC3_MZN   ", &
                               "NSTC3_XQ    ","NSTC3_XQD   ","NSTC3_YQ    ","NSTC3_YQD   ","NSTC3_ZQ    ","NSTC3_ZQD   ", &
                               "NSTC4_FXI   ","NSTC4_FXN   ","NSTC4_FYI   ","NSTC4_FYN   ","NSTC4_FZI   ","NSTC4_FZN   ", &
                               "NSTC4_MXI   ","NSTC4_MXN   ","NSTC4_MYI   ","NSTC4_MYN   ","NSTC4_MZI   ","NSTC4_MZN   ", &
                               "NSTC4_XQ    ","NSTC4_XQD   ","NSTC4_YQ    ","NSTC4_YQD   ","NSTC4_ZQ    ","NSTC4_ZQD   ", &
                               "PTFMSTC1_FXI","PTFMSTC1_FXN","PTFMSTC1_FYI","PTFMSTC1_FYN","PTFMSTC1_FZI","PTFMSTC1_FZN", &
                               "PTFMSTC1_MXI","PTFMSTC1_MXN","PTFMSTC1_MYI","PTFMSTC1_MYN","PTFMSTC1_MZI","PTFMSTC1_MZN", &
                               "PTFMSTC1_XQ ","PTFMSTC1_XQD","PTFMSTC1_YQ ","PTFMSTC1_YQD","PTFMSTC1_ZQ ","PTFMSTC1_ZQD", &
                               "PTFMSTC2_FXI","PTFMSTC2_FXN","PTFMSTC2_FYI","PTFMSTC2_FYN","PTFMSTC2_FZI","PTFMSTC2_FZN", &
                               "PTFMSTC2_MXI","PTFMSTC2_MXN","PTFMSTC2_MYI","PTFMSTC2_MYN","PTFMSTC2_MZI","PTFMSTC2_MZN", &
                               "PTFMSTC2_XQ ","PTFMSTC2_XQD","PTFMSTC2_YQ ","PTFMSTC2_YQD","PTFMSTC2_ZQ ","PTFMSTC2_ZQD", &
                               "PTFMSTC3_FXI","PTFMSTC3_FXN","PTFMSTC3_FYI","PTFMSTC3_FYN","PTFMSTC3_FZI","PTFMSTC3_FZN", &
                               "PTFMSTC3_MXI","PTFMSTC3_MXN","PTFMSTC3_MYI","PTFMSTC3_MYN","PTFMSTC3_MZI","PTFMSTC3_MZN", &
                               "PTFMSTC3_XQ ","PTFMSTC3_XQD","PTFMSTC3_YQ ","PTFMSTC3_YQD","PTFMSTC3_ZQ ","PTFMSTC3_ZQD", &
                               "PTFMSTC4_FXI","PTFMSTC4_FXN","PTFMSTC4_FYI","PTFMSTC4_FYN","PTFMSTC4_FZI","PTFMSTC4_FZN", &
                               "PTFMSTC4_MXI","PTFMSTC4_MXN","PTFMSTC4_MYI","PTFMSTC4_MYN","PTFMSTC4_MZI","PTFMSTC4_MZN", &
                               "PTFMSTC4_XQ ","PTFMSTC4_XQD","PTFMSTC4_YQ ","PTFMSTC4_YQD","PTFMSTC4_ZQ ","PTFMSTC4_ZQD", &
                               "TSTC1_FXI   ","TSTC1_FXN   ","TSTC1_FYI   ","TSTC1_FYN   ","TSTC1_FZI   ","TSTC1_FZN   ", &
                               "TSTC1_MXI   ","TSTC1_MXN   ","TSTC1_MYI   ","TSTC1_MYN   ","TSTC1_MZI   ","TSTC1_MZN   ", &
                               "TSTC1_XQ    ","TSTC1_XQD   ","TSTC1_YQ    ","TSTC1_YQD   ","TSTC1_ZQ    ","TSTC1_ZQD   ", &
                               "TSTC2_FXI   ","TSTC2_FXN   ","TSTC2_FYI   ","TSTC2_FYN   ","TSTC2_FZI   ","TSTC2_FZN   ", &
                               "TSTC2_MXI   ","TSTC2_MXN   ","TSTC2_MYI   ","TSTC2_MYN   ","TSTC2_MZI   ","TSTC2_MZN   ", &
                               "TSTC2_XQ    ","TSTC2_XQD   ","TSTC2_YQ    ","TSTC2_YQD   ","TSTC2_ZQ    ","TSTC2_ZQD   ", &
                               "TSTC3_FXI   ","TSTC3_FXN   ","TSTC3_FYI   ","TSTC3_FYN   ","TSTC3_FZI   ","TSTC3_FZN   ", &
                               "TSTC3_MXI   ","TSTC3_MXN   ","TSTC3_MYI   ","TSTC3_MYN   ","TSTC3_MZI   ","TSTC3_MZN   ", &
                               "TSTC3_XQ    ","TSTC3_XQD   ","TSTC3_YQ    ","TSTC3_YQD   ","TSTC3_ZQ    ","TSTC3_ZQD   ", &
                               "TSTC4_FXI   ","TSTC4_FXN   ","TSTC4_FYI   ","TSTC4_FYN   ","TSTC4_FZI   ","TSTC4_FZN   ", &
                               "TSTC4_MXI   ","TSTC4_MXN   ","TSTC4_MYI   ","TSTC4_MYN   ","TSTC4_MZI   ","TSTC4_MZN   ", &
                               "TSTC4_XQ    ","TSTC4_XQD   ","TSTC4_YQ    ","TSTC4_YQD   ","TSTC4_ZQ    ","TSTC4_ZQD   ", &
                               "YAWMOM      ","YAWMOMCOM   "/)
   INTEGER(IntKi), PARAMETER :: ParamIndxAry(518) =  (/ &                            ! This lists the index into AllOuts(:) of the allowed parameters ValidParamAry(:)
                                   BlAirFlC1 ,    BlAirFlC2 ,    BlAirFlC3 ,    BlAirFlC1 ,    BlAirFlC2 ,    BlAirFlC3 , &
                                   BlPitchC1 ,    BlPitchC2 ,    BlPitchC3 , BStC1_B1_Fxi , BStC1_B1_Fxn , BStC1_B1_Fyi , &
                                BStC1_B1_Fyn , BStC1_B1_Fzi , BStC1_B1_Fzn , BStC1_B1_Mxi , BStC1_B1_Mxn , BStC1_B1_Myi , &
                                BStC1_B1_Myn , BStC1_B1_Mzi , BStC1_B1_Mzn ,  BStC1_B1_XQ , BStC1_B1_XQD ,  BStC1_B1_YQ , &
                                BStC1_B1_YQD ,  BStC1_B1_ZQ , BStC1_B1_ZQD , BStC1_B2_Fxi , BStC1_B2_Fxn , BStC1_B2_Fyi , &
                                BStC1_B2_Fyn , BStC1_B2_Fzi , BStC1_B2_Fzn , BStC1_B2_Mxi , BStC1_B2_Mxn , BStC1_B2_Myi , &
                                BStC1_B2_Myn , BStC1_B2_Mzi , BStC1_B2_Mzn ,  BStC1_B2_XQ , BStC1_B2_XQD ,  BStC1_B2_YQ , &
                                BStC1_B2_YQD ,  BStC1_B2_ZQ , BStC1_B2_ZQD , BStC1_B3_Fxi , BStC1_B3_Fxn , BStC1_B3_Fyi , &
                                BStC1_B3_Fyn , BStC1_B3_Fzi , BStC1_B3_Fzn , BStC1_B3_Mxi , BStC1_B3_Mxn , BStC1_B3_Myi , &
                                BStC1_B3_Myn , BStC1_B3_Mzi , BStC1_B3_Mzn ,  BStC1_B3_XQ , BStC1_B3_XQD ,  BStC1_B3_YQ , &
                                BStC1_B3_YQD ,  BStC1_B3_ZQ , BStC1_B3_ZQD , BStC1_B4_Fxi , BStC1_B4_Fxn , BStC1_B4_Fyi , &
                                BStC1_B4_Fyn , BStC1_B4_Fzi , BStC1_B4_Fzn , BStC1_B4_Mxi , BStC1_B4_Mxn , BStC1_B4_Myi , &
                                BStC1_B4_Myn , BStC1_B4_Mzi , BStC1_B4_Mzn ,  BStC1_B4_XQ , BStC1_B4_XQD ,  BStC1_B4_YQ , &
                                BStC1_B4_YQD ,  BStC1_B4_ZQ , BStC1_B4_ZQD , BStC2_B1_Fxi , BStC2_B1_Fxn , BStC2_B1_Fyi , &
                                BStC2_B1_Fyn , BStC2_B1_Fzi , BStC2_B1_Fzn , BStC2_B1_Mxi , BStC2_B1_Mxn , BStC2_B1_Myi , &
                                BStC2_B1_Myn , BStC2_B1_Mzi , BStC2_B1_Mzn ,  BStC2_B1_XQ , BStC2_B1_XQD ,  BStC2_B1_YQ , &
                                BStC2_B1_YQD ,  BStC2_B1_ZQ , BStC2_B1_ZQD , BStC2_B2_Fxi , BStC2_B2_Fxn , BStC2_B2_Fyi , &
                                BStC2_B2_Fyn , BStC2_B2_Fzi , BStC2_B2_Fzn , BStC2_B2_Mxi , BStC2_B2_Mxn , BStC2_B2_Myi , &
                                BStC2_B2_Myn , BStC2_B2_Mzi , BStC2_B2_Mzn ,  BStC2_B2_XQ , BStC2_B2_XQD ,  BStC2_B2_YQ , &
                                BStC2_B2_YQD ,  BStC2_B2_ZQ , BStC2_B2_ZQD , BStC2_B3_Fxi , BStC2_B3_Fxn , BStC2_B3_Fyi , &
                                BStC2_B3_Fyn , BStC2_B3_Fzi , BStC2_B3_Fzn , BStC2_B3_Mxi , BStC2_B3_Mxn , BStC2_B3_Myi , &
                                BStC2_B3_Myn , BStC2_B3_Mzi , BStC2_B3_Mzn ,  BStC2_B3_XQ , BStC2_B3_XQD ,  BStC2_B3_YQ , &
                                BStC2_B3_YQD ,  BStC2_B3_ZQ , BStC2_B3_ZQD , BStC2_B4_Fxi , BStC2_B4_Fxn , BStC2_B4_Fyi , &
                                BStC2_B4_Fyn , BStC2_B4_Fzi , BStC2_B4_Fzn , BStC2_B4_Mxi , BStC2_B4_Mxn , BStC2_B4_Myi , &
                                BStC2_B4_Myn , BStC2_B4_Mzi , BStC2_B4_Mzn ,  BStC2_B4_XQ , BStC2_B4_XQD ,  BStC2_B4_YQ , &
                                BStC2_B4_YQD ,  BStC2_B4_ZQ , BStC2_B4_ZQD , BStC3_B1_Fxi , BStC3_B1_Fxn , BStC3_B1_Fyi , &
                                BStC3_B1_Fyn , BStC3_B1_Fzi , BStC3_B1_Fzn , BStC3_B1_Mxi , BStC3_B1_Mxn , BStC3_B1_Myi , &
                                BStC3_B1_Myn , BStC3_B1_Mzi , BStC3_B1_Mzn ,  BStC3_B1_XQ , BStC3_B1_XQD ,  BStC3_B1_YQ , &
                                BStC3_B1_YQD ,  BStC3_B1_ZQ , BStC3_B1_ZQD , BStC3_B2_Fxi , BStC3_B2_Fxn , BStC3_B2_Fyi , &
                                BStC3_B2_Fyn , BStC3_B2_Fzi , BStC3_B2_Fzn , BStC3_B2_Mxi , BStC3_B2_Mxn , BStC3_B2_Myi , &
                                BStC3_B2_Myn , BStC3_B2_Mzi , BStC3_B2_Mzn ,  BStC3_B2_XQ , BStC3_B2_XQD ,  BStC3_B2_YQ , &
                                BStC3_B2_YQD ,  BStC3_B2_ZQ , BStC3_B2_ZQD , BStC3_B3_Fxi , BStC3_B3_Fxn , BStC3_B3_Fyi , &
                                BStC3_B3_Fyn , BStC3_B3_Fzi , BStC3_B3_Fzn , BStC3_B3_Mxi , BStC3_B3_Mxn , BStC3_B3_Myi , &
                                BStC3_B3_Myn , BStC3_B3_Mzi , BStC3_B3_Mzn ,  BStC3_B3_XQ , BStC3_B3_XQD ,  BStC3_B3_YQ , &
                                BStC3_B3_YQD ,  BStC3_B3_ZQ , BStC3_B3_ZQD , BStC3_B4_Fxi , BStC3_B4_Fxn , BStC3_B4_Fyi , &
                                BStC3_B4_Fyn , BStC3_B4_Fzi , BStC3_B4_Fzn , BStC3_B4_Mxi , BStC3_B4_Mxn , BStC3_B4_Myi , &
                                BStC3_B4_Myn , BStC3_B4_Mzi , BStC3_B4_Mzn ,  BStC3_B4_XQ , BStC3_B4_XQD ,  BStC3_B4_YQ , &
                                BStC3_B4_YQD ,  BStC3_B4_ZQ , BStC3_B4_ZQD , BStC4_B1_Fxi , BStC4_B1_Fxn , BStC4_B1_Fyi , &
                                BStC4_B1_Fyn , BStC4_B1_Fzi , BStC4_B1_Fzn , BStC4_B1_Mxi , BStC4_B1_Mxn , BStC4_B1_Myi , &
                                BStC4_B1_Myn , BStC4_B1_Mzi , BStC4_B1_Mzn ,  BStC4_B1_XQ , BStC4_B1_XQD ,  BStC4_B1_YQ , &
                                BStC4_B1_YQD ,  BStC4_B1_ZQ , BStC4_B1_ZQD , BStC4_B2_Fxi , BStC4_B2_Fxn , BStC4_B2_Fyi , &
                                BStC4_B2_Fyn , BStC4_B2_Fzi , BStC4_B2_Fzn , BStC4_B2_Mxi , BStC4_B2_Mxn , BStC4_B2_Myi , &
                                BStC4_B2_Myn , BStC4_B2_Mzi , BStC4_B2_Mzn ,  BStC4_B2_XQ , BStC4_B2_XQD ,  BStC4_B2_YQ , &
                                BStC4_B2_YQD ,  BStC4_B2_ZQ , BStC4_B2_ZQD , BStC4_B3_Fxi , BStC4_B3_Fxn , BStC4_B3_Fyi , &
                                BStC4_B3_Fyn , BStC4_B3_Fzi , BStC4_B3_Fzn , BStC4_B3_Mxi , BStC4_B3_Mxn , BStC4_B3_Myi , &
                                BStC4_B3_Myn , BStC4_B3_Mzi , BStC4_B3_Mzn ,  BStC4_B3_XQ , BStC4_B3_XQD ,  BStC4_B3_YQ , &
                                BStC4_B3_YQD ,  BStC4_B3_ZQ , BStC4_B3_ZQD , BStC4_B4_Fxi , BStC4_B4_Fxn , BStC4_B4_Fyi , &
                                BStC4_B4_Fyn , BStC4_B4_Fzi , BStC4_B4_Fzn , BStC4_B4_Mxi , BStC4_B4_Mxn , BStC4_B4_Myi , &
                                BStC4_B4_Myn , BStC4_B4_Mzi , BStC4_B4_Mzn ,  BStC4_B4_XQ , BStC4_B4_XQD ,  BStC4_B4_YQ , &
                                BStC4_B4_YQD ,  BStC4_B4_ZQ , BStC4_B4_ZQD ,       GenPwr ,        GenTq ,     HSSBrTqC , &
                                   NStC1_Fxi ,    NStC1_Fxn ,    NStC1_Fyi ,    NStC1_Fyn ,    NStC1_Fzi ,    NStC1_Fzn , &
                                   NStC1_Mxi ,    NStC1_Mxn ,    NStC1_Myi ,    NStC1_Myn ,    NStC1_Mzi ,    NStC1_Mzn , &
                                    NStC1_XQ ,    NStC1_XQD ,     NStC1_YQ ,    NStC1_YQD ,     NStC1_ZQ ,    NStC1_ZQD , &
                                   NStC2_Fxi ,    NStC2_Fxn ,    NStC2_Fyi ,    NStC2_Fyn ,    NStC2_Fzi ,    NStC2_Fzn , &
                                   NStC2_Mxi ,    NStC2_Mxn ,    NStC2_Myi ,    NStC2_Myn ,    NStC2_Mzi ,    NStC2_Mzn , &
                                    NStC2_XQ ,    NStC2_XQD ,     NStC2_YQ ,    NStC2_YQD ,     NStC2_ZQ ,    NStC2_ZQD , &
                                   NStC3_Fxi ,    NStC3_Fxn ,    NStC3_Fyi ,    NStC3_Fyn ,    NStC3_Fzi ,    NStC3_Fzn , &
                                   NStC3_Mxi ,    NStC3_Mxn ,    NStC3_Myi ,    NStC3_Myn ,    NStC3_Mzi ,    NStC3_Mzn , &
                                    NStC3_XQ ,    NStC3_XQD ,     NStC3_YQ ,    NStC3_YQD ,     NStC3_ZQ ,    NStC3_ZQD , &
                                   NStC4_Fxi ,    NStC4_Fxn ,    NStC4_Fyi ,    NStC4_Fyn ,    NStC4_Fzi ,    NStC4_Fzn , &
                                   NStC4_Mxi ,    NStC4_Mxn ,    NStC4_Myi ,    NStC4_Myn ,    NStC4_Mzi ,    NStC4_Mzn , &
                                    NStC4_XQ ,    NStC4_XQD ,     NStC4_YQ ,    NStC4_YQD ,     NStC4_ZQ ,    NStC4_ZQD , &
                                PtfmStC1_Fxi , PtfmStC1_Fxn , PtfmStC1_Fyi , PtfmStC1_Fyn , PtfmStC1_Fzi , PtfmStC1_Fzn , &
                                PtfmStC1_Mxi , PtfmStC1_Mxn , PtfmStC1_Myi , PtfmStC1_Myn , PtfmStC1_Mzi , PtfmStC1_Mzn , &
                                 PtfmStC1_XQ , PtfmStC1_XQD ,  PtfmStC1_YQ , PtfmStC1_YQD ,  PtfmStC1_ZQ , PtfmStC1_ZQD , &
                                PtfmStC2_Fxi , PtfmStC2_Fxn , PtfmStC2_Fyi , PtfmStC2_Fyn , PtfmStC2_Fzi , PtfmStC2_Fzn , &
                                PtfmStC2_Mxi , PtfmStC2_Mxn , PtfmStC2_Myi , PtfmStC2_Myn , PtfmStC2_Mzi , PtfmStC2_Mzn , &
                                 PtfmStC2_XQ , PtfmStC2_XQD ,  PtfmStC2_YQ , PtfmStC2_YQD ,  PtfmStC2_ZQ , PtfmStC2_ZQD , &
                                PtfmStC3_Fxi , PtfmStC3_Fxn , PtfmStC3_Fyi , PtfmStC3_Fyn , PtfmStC3_Fzi , PtfmStC3_Fzn , &
                                PtfmStC3_Mxi , PtfmStC3_Mxn , PtfmStC3_Myi , PtfmStC3_Myn , PtfmStC3_Mzi , PtfmStC3_Mzn , &
                                 PtfmStC3_XQ , PtfmStC3_XQD ,  PtfmStC3_YQ , PtfmStC3_YQD ,  PtfmStC3_ZQ , PtfmStC3_ZQD , &
                                PtfmStC4_Fxi , PtfmStC4_Fxn , PtfmStC4_Fyi , PtfmStC4_Fyn , PtfmStC4_Fzi , PtfmStC4_Fzn , &
                                PtfmStC4_Mxi , PtfmStC4_Mxn , PtfmStC4_Myi , PtfmStC4_Myn , PtfmStC4_Mzi , PtfmStC4_Mzn , &
                                 PtfmStC4_XQ , PtfmStC4_XQD ,  PtfmStC4_YQ , PtfmStC4_YQD ,  PtfmStC4_ZQ , PtfmStC4_ZQD , &
                                   TStC1_Fxi ,    TStC1_Fxn ,    TStC1_Fyi ,    TStC1_Fyn ,    TStC1_Fzi ,    TStC1_Fzn , &
                                   TStC1_Mxi ,    TStC1_Mxn ,    TStC1_Myi ,    TStC1_Myn ,    TStC1_Mzi ,    TStC1_Mzn , &
                                    TStC1_XQ ,    TStC1_XQD ,     TStC1_YQ ,    TStC1_YQD ,     TStC1_ZQ ,    TStC1_ZQD , &
                                   TStC2_Fxi ,    TStC2_Fxn ,    TStC2_Fyi ,    TStC2_Fyn ,    TStC2_Fzi ,    TStC2_Fzn , &
                                   TStC2_Mxi ,    TStC2_Mxn ,    TStC2_Myi ,    TStC2_Myn ,    TStC2_Mzi ,    TStC2_Mzn , &
                                    TStC2_XQ ,    TStC2_XQD ,     TStC2_YQ ,    TStC2_YQD ,     TStC2_ZQ ,    TStC2_ZQD , &
                                   TStC3_Fxi ,    TStC3_Fxn ,    TStC3_Fyi ,    TStC3_Fyn ,    TStC3_Fzi ,    TStC3_Fzn , &
                                   TStC3_Mxi ,    TStC3_Mxn ,    TStC3_Myi ,    TStC3_Myn ,    TStC3_Mzi ,    TStC3_Mzn , &
                                    TStC3_XQ ,    TStC3_XQD ,     TStC3_YQ ,    TStC3_YQD ,     TStC3_ZQ ,    TStC3_ZQD , &
                                   TStC4_Fxi ,    TStC4_Fxn ,    TStC4_Fyi ,    TStC4_Fyn ,    TStC4_Fzi ,    TStC4_Fzn , &
                                   TStC4_Mxi ,    TStC4_Mxn ,    TStC4_Myi ,    TStC4_Myn ,    TStC4_Mzi ,    TStC4_Mzn , &
                                    TStC4_XQ ,    TStC4_XQD ,     TStC4_YQ ,    TStC4_YQD ,     TStC4_ZQ ,    TStC4_ZQD , &
                                   YawMomCom ,    YawMomCom /)
   CHARACTER(ChanLen), PARAMETER :: ParamUnitsAry(518) =  (/  &  ! This lists the units corresponding to the allowed parameters
                               "(-)   ","(-)   ","(-)   ","(-)   ","(-)   ","(-)   ", &
                               "(deg) ","(deg) ","(deg) ","(kN)  ","(kN)  ","(kN)  ", &
                               "(kN)  ","(kN)  ","(kN)  ","(kN-m)","(kN-m)","(kN-m)", &
                               "(kN-m)","(kN-m)","(kN-m)","(m)   ","(m/s) ","(m)   ", &
                               "(m/s) ","(m)   ","(m/s) ","(kN)  ","(kN)  ","(kN)  ", &
                               "(kN)  ","(kN)  ","(kN)  ","(kN-m)","(kN-m)","(kN-m)", &
                               "(kN-m)","(kN-m)","(kN-m)","(m)   ","(m/s) ","(m)   ", &
                               "(m/s) ","(m)   ","(m/s) ","(kN)  ","(kN)  ","(kN)  ", &
                               "(kN)  ","(kN)  ","(kN)  ","(kN-m)","(kN-m)","(kN-m)", &
                               "(kN-m)","(kN-m)","(kN-m)","(m)   ","(m/s) ","(m)   ", &
                               "(m/s) ","(m)   ","(m/s) ","(kN)  ","(kN)  ","(kN)  ", &
                               "(kN)  ","(kN)  ","(kN)  ","(kN-m)","(kN-m)","(kN-m)", &
                               "(kN-m)","(kN-m)","(kN-m)","(m)   ","(m/s) ","(m)   ", &
                               "(m/s) ","(m)   ","(m/s) ","(kN)  ","(kN)  ","(kN)  ", &
                               "(kN)  ","(kN)  ","(kN)  ","(kN-m)","(kN-m)","(kN-m)", &
                               "(kN-m)","(kN-m)","(kN-m)","(m)   ","(m/s) ","(m)   ", &
                               "(m/s) ","(m)   ","(m/s) ","(kN)  ","(kN)  ","(kN)  ", &
                               "(kN)  ","(kN)  ","(kN)  ","(kN-m)","(kN-m)","(kN-m)", &
                               "(kN-m)","(kN-m)","(kN-m)","(m)   ","(m/s) ","(m)   ", &
                               "(m/s) ","(m)   ","(m/s) ","(kN)  ","(kN)  ","(kN)  ", &
                               "(kN)  ","(kN)  ","(kN)  ","(kN-m)","(kN-m)","(kN-m)", &
                               "(kN-m)","(kN-m)","(kN-m)","(m)   ","(m/s) ","(m)   ", &
                               "(m/s) ","(m)   ","(m/s) ","(kN)  ","(kN)  ","(kN)  ", &
                               "(kN)  ","(kN)  ","(kN)  ","(kN-m)","(kN-m)","(kN-m)", &
                               "(kN-m)","(kN-m)","(kN-m)","(m)   ","(m/s) ","(m)   ", &
                               "(m/s) ","(m)   ","(m/s) ","(kN)  ","(kN)  ","(kN)  ", &
                               "(kN)  ","(kN)  ","(kN)  ","(kN-m)","(kN-m)","(kN-m)", &
                               "(kN-m)","(kN-m)","(kN-m)","(m)   ","(m/s) ","(m)   ", &
                               "(m/s) ","(m)   ","(m/s) ","(kN)  ","(kN)  ","(kN)  ", &
                               "(kN)  ","(kN)  ","(kN)  ","(kN-m)","(kN-m)","(kN-m)", &
                               "(kN-m)","(kN-m)","(kN-m)","(m)   ","(m/s) ","(m)   ", &
                               "(m/s) ","(m)   ","(m/s) ","(kN)  ","(kN)  ","(kN)  ", &
                               "(kN)  ","(kN)  ","(kN)  ","(kN-m)","(kN-m)","(kN-m)", &
                               "(kN-m)","(kN-m)","(kN-m)","(m)   ","(m/s) ","(m)   ", &
                               "(m/s) ","(m)   ","(m/s) ","(kN)  ","(kN)  ","(kN)  ", &
                               "(kN)  ","(kN)  ","(kN)  ","(kN-m)","(kN-m)","(kN-m)", &
                               "(kN-m)","(kN-m)","(kN-m)","(m)   ","(m/s) ","(m)   ", &
                               "(m/s) ","(m)   ","(m/s) ","(kN)  ","(kN)  ","(kN)  ", &
                               "(kN)  ","(kN)  ","(kN)  ","(kN-m)","(kN-m)","(kN-m)", &
                               "(kN-m)","(kN-m)","(kN-m)","(m)   ","(m/s) ","(m)   ", &
                               "(m/s) ","(m)   ","(m/s) ","(kN)  ","(kN)  ","(kN)  ", &
                               "(kN)  ","(kN)  ","(kN)  ","(kN-m)","(kN-m)","(kN-m)", &
                               "(kN-m)","(kN-m)","(kN-m)","(m)   ","(m/s) ","(m)   ", &
                               "(m/s) ","(m)   ","(m/s) ","(kN)  ","(kN)  ","(kN)  ", &
                               "(kN)  ","(kN)  ","(kN)  ","(kN-m)","(kN-m)","(kN-m)", &
                               "(kN-m)","(kN-m)","(kN-m)","(m)   ","(m/s) ","(m)   ", &
                               "(m/s) ","(m)   ","(m/s) ","(kN)  ","(kN)  ","(kN)  ", &
                               "(kN)  ","(kN)  ","(kN)  ","(kN-m)","(kN-m)","(kN-m)", &
                               "(kN-m)","(kN-m)","(kN-m)","(m)   ","(m/s) ","(m)   ", &
                               "(m/s) ","(m)   ","(m/s) ","(kW)  ","(kN-m)","(kN-m)", &
                               "(kN)  ","(kN)  ","(kN)  ","(kN)  ","(kN)  ","(kN)  ", &
                               "(kN-m)","(kN-m)","(kN-m)","(kN-m)","(kN-m)","(kN-m)", &
                               "(m)   ","(m/s) ","(m)   ","(m/s) ","(m)   ","(m/s) ", &
                               "(kN)  ","(kN)  ","(kN)  ","(kN)  ","(kN)  ","(kN)  ", &
                               "(kN-m)","(kN-m)","(kN-m)","(kN-m)","(kN-m)","(kN-m)", &
                               "(m)   ","(m/s) ","(m)   ","(m/s) ","(m)   ","(m/s) ", &
                               "(kN)  ","(kN)  ","(kN)  ","(kN)  ","(kN)  ","(kN)  ", &
                               "(kN-m)","(kN-m)","(kN-m)","(kN-m)","(kN-m)","(kN-m)", &
                               "(m)   ","(m/s) ","(m)   ","(m/s) ","(m)   ","(m/s) ", &
                               "(kN)  ","(kN)  ","(kN)  ","(kN)  ","(kN)  ","(kN)  ", &
                               "(kN-m)","(kN-m)","(kN-m)","(kN-m)","(kN-m)","(kN-m)", &
                               "(m)   ","(m/s) ","(m)   ","(m/s) ","(m)   ","(m/s) ", &
                               "(kN)  ","(kN)  ","(kN)  ","(kN)  ","(kN)  ","(kN)  ", &
                               "(kN-m)","(kN-m)","(kN-m)","(kN-m)","(kN-m)","(kN-m)", &
                               "(m)   ","(m/s) ","(m)   ","(m/s) ","(m)   ","(m/s) ", &
                               "(kN)  ","(kN)  ","(kN)  ","(kN)  ","(kN)  ","(kN)  ", &
                               "(kN-m)","(kN-m)","(kN-m)","(kN-m)","(kN-m)","(kN-m)", &
                               "(m)   ","(m/s) ","(m)   ","(m/s) ","(m)   ","(m/s) ", &
                               "(kN)  ","(kN)  ","(kN)  ","(kN)  ","(kN)  ","(kN)  ", &
                               "(kN-m)","(kN-m)","(kN-m)","(kN-m)","(kN-m)","(kN-m)", &
                               "(m)   ","(m/s) ","(m)   ","(m/s) ","(m)   ","(m/s) ", &
                               "(kN)  ","(kN)  ","(kN)  ","(kN)  ","(kN)  ","(kN)  ", &
                               "(kN-m)","(kN-m)","(kN-m)","(kN-m)","(kN-m)","(kN-m)", &
                               "(m)   ","(m/s) ","(m)   ","(m/s) ","(m)   ","(m/s) ", &
                               "(kN)  ","(kN)  ","(kN)  ","(kN)  ","(kN)  ","(kN)  ", &
                               "(kN-m)","(kN-m)","(kN-m)","(kN-m)","(kN-m)","(kN-m)", &
                               "(m)   ","(m/s) ","(m)   ","(m/s) ","(m)   ","(m/s) ", &
                               "(kN)  ","(kN)  ","(kN)  ","(kN)  ","(kN)  ","(kN)  ", &
                               "(kN-m)","(kN-m)","(kN-m)","(kN-m)","(kN-m)","(kN-m)", &
                               "(m)   ","(m/s) ","(m)   ","(m/s) ","(m)   ","(m/s) ", &
                               "(kN)  ","(kN)  ","(kN)  ","(kN)  ","(kN)  ","(kN)  ", &
                               "(kN-m)","(kN-m)","(kN-m)","(kN-m)","(kN-m)","(kN-m)", &
                               "(m)   ","(m/s) ","(m)   ","(m/s) ","(m)   ","(m/s) ", &
                               "(kN)  ","(kN)  ","(kN)  ","(kN)  ","(kN)  ","(kN)  ", &
                               "(kN-m)","(kN-m)","(kN-m)","(kN-m)","(kN-m)","(kN-m)", &
                               "(m)   ","(m/s) ","(m)   ","(m/s) ","(m)   ","(m/s) ", &
                               "(kN-m)","(kN-m)"/)


      ! Initialize values
   ErrStat = ErrID_None
   ErrMsg = ""
   InvalidOutput = .FALSE.


      ! Determine which inputs are not valid

   InvalidOutput(   BlAirFlC3) = ( p%NumBl < 3 )
   InvalidOutput(   BlPitchC3) = ( p%NumBl < 3 )
   InvalidOutput(    NStC1_XQ) = ( p%CompNStC<1 )
   InvalidOutput(   NStC1_XQD) = ( p%CompNStC<1 )
   InvalidOutput(    NStC1_YQ) = ( p%CompNStC<1 )
   InvalidOutput(   NStC1_YQD) = ( p%CompNStC<1 )
   InvalidOutput(    NStC1_ZQ) = ( p%CompNStC<1 )
   InvalidOutput(   NStC1_ZQD) = ( p%CompNStC<1 )
   InvalidOutput(   NStC1_Fxi) = ( p%CompNStC<1 )
   InvalidOutput(   NStC1_Fyi) = ( p%CompNStC<1 )
   InvalidOutput(   NStC1_Fzi) = ( p%CompNStC<1 )
   InvalidOutput(   NStC1_Mxi) = ( p%CompNStC<1 )
   InvalidOutput(   NStC1_Myi) = ( p%CompNStC<1 )
   InvalidOutput(   NStC1_Mzi) = ( p%CompNStC<1 )
   InvalidOutput(   NStC1_Fxn) = ( p%CompNStC<1 )
   InvalidOutput(   NStC1_Fyn) = ( p%CompNStC<1 )
   InvalidOutput(   NStC1_Fzn) = ( p%CompNStC<1 )
   InvalidOutput(   NStC1_Mxn) = ( p%CompNStC<1 )
   InvalidOutput(   NStC1_Myn) = ( p%CompNStC<1 )
   InvalidOutput(   NStC1_Mzn) = ( p%CompNStC<1 )
   InvalidOutput(    NStC2_XQ) = ( p%CompNStC<2 )
   InvalidOutput(   NStC2_XQD) = ( p%CompNStC<2 )
   InvalidOutput(    NStC2_YQ) = ( p%CompNStC<2 )
   InvalidOutput(   NStC2_YQD) = ( p%CompNStC<2 )
   InvalidOutput(    NStC2_ZQ) = ( p%CompNStC<2 )
   InvalidOutput(   NStC2_ZQD) = ( p%CompNStC<2 )
   InvalidOutput(   NStC2_Fxi) = ( p%CompNStC<2 )
   InvalidOutput(   NStC2_Fyi) = ( p%CompNStC<2 )
   InvalidOutput(   NStC2_Fzi) = ( p%CompNStC<2 )
   InvalidOutput(   NStC2_Mxi) = ( p%CompNStC<2 )
   InvalidOutput(   NStC2_Myi) = ( p%CompNStC<2 )
   InvalidOutput(   NStC2_Mzi) = ( p%CompNStC<2 )
   InvalidOutput(   NStC2_Fxn) = ( p%CompNStC<2 )
   InvalidOutput(   NStC2_Fyn) = ( p%CompNStC<2 )
   InvalidOutput(   NStC2_Fzn) = ( p%CompNStC<2 )
   InvalidOutput(   NStC2_Mxn) = ( p%CompNStC<2 )
   InvalidOutput(   NStC2_Myn) = ( p%CompNStC<2 )
   InvalidOutput(   NStC2_Mzn) = ( p%CompNStC<2 )
   InvalidOutput(    NStC3_XQ) = ( p%CompNStC<3 )
   InvalidOutput(   NStC3_XQD) = ( p%CompNStC<3 )
   InvalidOutput(    NStC3_YQ) = ( p%CompNStC<3 )
   InvalidOutput(   NStC3_YQD) = ( p%CompNStC<3 )
   InvalidOutput(    NStC3_ZQ) = ( p%CompNStC<3 )
   InvalidOutput(   NStC3_ZQD) = ( p%CompNStC<3 )
   InvalidOutput(   NStC3_Fxi) = ( p%CompNStC<3 )
   InvalidOutput(   NStC3_Fyi) = ( p%CompNStC<3 )
   InvalidOutput(   NStC3_Fzi) = ( p%CompNStC<3 )
   InvalidOutput(   NStC3_Mxi) = ( p%CompNStC<3 )
   InvalidOutput(   NStC3_Myi) = ( p%CompNStC<3 )
   InvalidOutput(   NStC3_Mzi) = ( p%CompNStC<3 )
   InvalidOutput(   NStC3_Fxn) = ( p%CompNStC<3 )
   InvalidOutput(   NStC3_Fyn) = ( p%CompNStC<3 )
   InvalidOutput(   NStC3_Fzn) = ( p%CompNStC<3 )
   InvalidOutput(   NStC3_Mxn) = ( p%CompNStC<3 )
   InvalidOutput(   NStC3_Myn) = ( p%CompNStC<3 )
   InvalidOutput(   NStC3_Mzn) = ( p%CompNStC<3 )
   InvalidOutput(    NStC4_XQ) = ( p%CompNStC<4 )
   InvalidOutput(   NStC4_XQD) = ( p%CompNStC<4 )
   InvalidOutput(    NStC4_YQ) = ( p%CompNStC<4 )
   InvalidOutput(   NStC4_YQD) = ( p%CompNStC<4 )
   InvalidOutput(    NStC4_ZQ) = ( p%CompNStC<4 )
   InvalidOutput(   NStC4_ZQD) = ( p%CompNStC<4 )
   InvalidOutput(   NStC4_Fxi) = ( p%CompNStC<4 )
   InvalidOutput(   NStC4_Fyi) = ( p%CompNStC<4 )
   InvalidOutput(   NStC4_Fzi) = ( p%CompNStC<4 )
   InvalidOutput(   NStC4_Mxi) = ( p%CompNStC<4 )
   InvalidOutput(   NStC4_Myi) = ( p%CompNStC<4 )
   InvalidOutput(   NStC4_Mzi) = ( p%CompNStC<4 )
   InvalidOutput(   NStC4_Fxn) = ( p%CompNStC<4 )
   InvalidOutput(   NStC4_Fyn) = ( p%CompNStC<4 )
   InvalidOutput(   NStC4_Fzn) = ( p%CompNStC<4 )
   InvalidOutput(   NStC4_Mxn) = ( p%CompNStC<4 )
   InvalidOutput(   NStC4_Myn) = ( p%CompNStC<4 )
   InvalidOutput(   NStC4_Mzn) = ( p%CompNStC<4 )
   InvalidOutput(    TStC1_XQ) = ( p%CompTStC<1 )
   InvalidOutput(   TStC1_XQD) = ( p%CompTStC<1 )
   InvalidOutput(    TStC1_YQ) = ( p%CompTStC<1 )
   InvalidOutput(   TStC1_YQD) = ( p%CompTStC<1 )
   InvalidOutput(    TStC1_ZQ) = ( p%CompTStC<1 )
   InvalidOutput(   TStC1_ZQD) = ( p%CompTStC<1 )
   InvalidOutput(   TStC1_Fxi) = ( p%CompTStC<1 )
   InvalidOutput(   TStC1_Fyi) = ( p%CompTStC<1 )
   InvalidOutput(   TStC1_Fzi) = ( p%CompTStC<1 )
   InvalidOutput(   TStC1_Mxi) = ( p%CompTStC<1 )
   InvalidOutput(   TStC1_Myi) = ( p%CompTStC<1 )
   InvalidOutput(   TStC1_Mzi) = ( p%CompTStC<1 )
   InvalidOutput(   TStC1_Fxn) = ( p%CompTStC<1 )
   InvalidOutput(   TStC1_Fyn) = ( p%CompTStC<1 )
   InvalidOutput(   TStC1_Fzn) = ( p%CompTStC<1 )
   InvalidOutput(   TStC1_Mxn) = ( p%CompTStC<1 )
   InvalidOutput(   TStC1_Myn) = ( p%CompTStC<1 )
   InvalidOutput(   TStC1_Mzn) = ( p%CompTStC<1 )
   InvalidOutput(    TStC2_XQ) = ( p%CompTStC<2 )
   InvalidOutput(   TStC2_XQD) = ( p%CompTStC<2 )
   InvalidOutput(    TStC2_YQ) = ( p%CompTStC<2 )
   InvalidOutput(   TStC2_YQD) = ( p%CompTStC<2 )
   InvalidOutput(    TStC2_ZQ) = ( p%CompTStC<2 )
   InvalidOutput(   TStC2_ZQD) = ( p%CompTStC<2 )
   InvalidOutput(   TStC2_Fxi) = ( p%CompTStC<2 )
   InvalidOutput(   TStC2_Fyi) = ( p%CompTStC<2 )
   InvalidOutput(   TStC2_Fzi) = ( p%CompTStC<2 )
   InvalidOutput(   TStC2_Mxi) = ( p%CompTStC<2 )
   InvalidOutput(   TStC2_Myi) = ( p%CompTStC<2 )
   InvalidOutput(   TStC2_Mzi) = ( p%CompTStC<2 )
   InvalidOutput(   TStC2_Fxn) = ( p%CompTStC<2 )
   InvalidOutput(   TStC2_Fyn) = ( p%CompTStC<2 )
   InvalidOutput(   TStC2_Fzn) = ( p%CompTStC<2 )
   InvalidOutput(   TStC2_Mxn) = ( p%CompTStC<2 )
   InvalidOutput(   TStC2_Myn) = ( p%CompTStC<2 )
   InvalidOutput(   TStC2_Mzn) = ( p%CompTStC<2 )
   InvalidOutput(    TStC3_XQ) = ( p%CompTStC<3 )
   InvalidOutput(   TStC3_XQD) = ( p%CompTStC<3 )
   InvalidOutput(    TStC3_YQ) = ( p%CompTStC<3 )
   InvalidOutput(   TStC3_YQD) = ( p%CompTStC<3 )
   InvalidOutput(    TStC3_ZQ) = ( p%CompTStC<3 )
   InvalidOutput(   TStC3_ZQD) = ( p%CompTStC<3 )
   InvalidOutput(   TStC3_Fxi) = ( p%CompTStC<3 )
   InvalidOutput(   TStC3_Fyi) = ( p%CompTStC<3 )
   InvalidOutput(   TStC3_Fzi) = ( p%CompTStC<3 )
   InvalidOutput(   TStC3_Mxi) = ( p%CompTStC<3 )
   InvalidOutput(   TStC3_Myi) = ( p%CompTStC<3 )
   InvalidOutput(   TStC3_Mzi) = ( p%CompTStC<3 )
   InvalidOutput(   TStC3_Fxn) = ( p%CompTStC<3 )
   InvalidOutput(   TStC3_Fyn) = ( p%CompTStC<3 )
   InvalidOutput(   TStC3_Fzn) = ( p%CompTStC<3 )
   InvalidOutput(   TStC3_Mxn) = ( p%CompTStC<3 )
   InvalidOutput(   TStC3_Myn) = ( p%CompTStC<3 )
   InvalidOutput(   TStC3_Mzn) = ( p%CompTStC<3 )
   InvalidOutput(    TStC4_XQ) = ( p%CompTStC<4 )
   InvalidOutput(   TStC4_XQD) = ( p%CompTStC<4 )
   InvalidOutput(    TStC4_YQ) = ( p%CompTStC<4 )
   InvalidOutput(   TStC4_YQD) = ( p%CompTStC<4 )
   InvalidOutput(    TStC4_ZQ) = ( p%CompTStC<4 )
   InvalidOutput(   TStC4_ZQD) = ( p%CompTStC<4 )
   InvalidOutput(   TStC4_Fxi) = ( p%CompTStC<4 )
   InvalidOutput(   TStC4_Fyi) = ( p%CompTStC<4 )
   InvalidOutput(   TStC4_Fzi) = ( p%CompTStC<4 )
   InvalidOutput(   TStC4_Mxi) = ( p%CompTStC<4 )
   InvalidOutput(   TStC4_Myi) = ( p%CompTStC<4 )
   InvalidOutput(   TStC4_Mzi) = ( p%CompTStC<4 )
   InvalidOutput(   TStC4_Fxn) = ( p%CompTStC<4 )
   InvalidOutput(   TStC4_Fyn) = ( p%CompTStC<4 )
   InvalidOutput(   TStC4_Fzn) = ( p%CompTStC<4 )
   InvalidOutput(   TStC4_Mxn) = ( p%CompTStC<4 )
   InvalidOutput(   TStC4_Myn) = ( p%CompTStC<4 )
   InvalidOutput(   TStC4_Mzn) = ( p%CompTStC<4 )
   InvalidOutput( BStC1_B1_XQ) = ( p%CompBStC<1 .or. p%NumBl<1 )
   InvalidOutput(BStC1_B1_XQD) = ( p%CompBStC<1 .or. p%NumBl<1 )
   InvalidOutput( BStC1_B1_YQ) = ( p%CompBStC<1 .or. p%NumBl<1 )
   InvalidOutput(BStC1_B1_YQD) = ( p%CompBStC<1 .or. p%NumBl<1 )
   InvalidOutput( BStC1_B1_ZQ) = ( p%CompBStC<1 .or. p%NumBl<1 )
   InvalidOutput(BStC1_B1_ZQD) = ( p%CompBStC<1 .or. p%NumBl<1 )
   InvalidOutput(BStC1_B1_Fxi) = ( p%CompBStC<1 .or. p%NumBl<1 )
   InvalidOutput(BStC1_B1_Fyi) = ( p%CompBStC<1 .or. p%NumBl<1 )
   InvalidOutput(BStC1_B1_Fzi) = ( p%CompBStC<1 .or. p%NumBl<1 )
   InvalidOutput(BStC1_B1_Mxi) = ( p%CompBStC<1 .or. p%NumBl<1 )
   InvalidOutput(BStC1_B1_Myi) = ( p%CompBStC<1 .or. p%NumBl<1 )
   InvalidOutput(BStC1_B1_Mzi) = ( p%CompBStC<1 .or. p%NumBl<1 )
   InvalidOutput(BStC1_B1_Fxn) = ( p%CompBStC<1 .or. p%NumBl<1 )
   InvalidOutput(BStC1_B1_Fyn) = ( p%CompBStC<1 .or. p%NumBl<1 )
   InvalidOutput(BStC1_B1_Fzn) = ( p%CompBStC<1 .or. p%NumBl<1 )
   InvalidOutput(BStC1_B1_Mxn) = ( p%CompBStC<1 .or. p%NumBl<1 )
   InvalidOutput(BStC1_B1_Myn) = ( p%CompBStC<1 .or. p%NumBl<1 )
   InvalidOutput(BStC1_B1_Mzn) = ( p%CompBStC<1 .or. p%NumBl<1 )
   InvalidOutput( BStC2_B1_XQ) = ( p%CompBStC<2 .or. p%NumBl<1 )
   InvalidOutput(BStC2_B1_XQD) = ( p%CompBStC<2 .or. p%NumBl<1 )
   InvalidOutput( BStC2_B1_YQ) = ( p%CompBStC<2 .or. p%NumBl<1 )
   InvalidOutput(BStC2_B1_YQD) = ( p%CompBStC<2 .or. p%NumBl<1 )
   InvalidOutput( BStC2_B1_ZQ) = ( p%CompBStC<2 .or. p%NumBl<1 )
   InvalidOutput(BStC2_B1_ZQD) = ( p%CompBStC<2 .or. p%NumBl<1 )
   InvalidOutput(BStC2_B1_Fxi) = ( p%CompBStC<2 .or. p%NumBl<1 )
   InvalidOutput(BStC2_B1_Fyi) = ( p%CompBStC<2 .or. p%NumBl<1 )
   InvalidOutput(BStC2_B1_Fzi) = ( p%CompBStC<2 .or. p%NumBl<1 )
   InvalidOutput(BStC2_B1_Mxi) = ( p%CompBStC<2 .or. p%NumBl<1 )
   InvalidOutput(BStC2_B1_Myi) = ( p%CompBStC<2 .or. p%NumBl<1 )
   InvalidOutput(BStC2_B1_Mzi) = ( p%CompBStC<2 .or. p%NumBl<1 )
   InvalidOutput(BStC2_B1_Fxn) = ( p%CompBStC<2 .or. p%NumBl<1 )
   InvalidOutput(BStC2_B1_Fyn) = ( p%CompBStC<2 .or. p%NumBl<1 )
   InvalidOutput(BStC2_B1_Fzn) = ( p%CompBStC<2 .or. p%NumBl<1 )
   InvalidOutput(BStC2_B1_Mxn) = ( p%CompBStC<2 .or. p%NumBl<1 )
   InvalidOutput(BStC2_B1_Myn) = ( p%CompBStC<2 .or. p%NumBl<1 )
   InvalidOutput(BStC2_B1_Mzn) = ( p%CompBStC<2 .or. p%NumBl<1 )
   InvalidOutput( BStC3_B1_XQ) = ( p%CompBStC<3 .or. p%NumBl<1 )
   InvalidOutput(BStC3_B1_XQD) = ( p%CompBStC<3 .or. p%NumBl<1 )
   InvalidOutput( BStC3_B1_YQ) = ( p%CompBStC<3 .or. p%NumBl<1 )
   InvalidOutput(BStC3_B1_YQD) = ( p%CompBStC<3 .or. p%NumBl<1 )
   InvalidOutput( BStC3_B1_ZQ) = ( p%CompBStC<3 .or. p%NumBl<1 )
   InvalidOutput(BStC3_B1_ZQD) = ( p%CompBStC<3 .or. p%NumBl<1 )
   InvalidOutput(BStC3_B1_Fxi) = ( p%CompBStC<3 .or. p%NumBl<1 )
   InvalidOutput(BStC3_B1_Fyi) = ( p%CompBStC<3 .or. p%NumBl<1 )
   InvalidOutput(BStC3_B1_Fzi) = ( p%CompBStC<3 .or. p%NumBl<1 )
   InvalidOutput(BStC3_B1_Mxi) = ( p%CompBStC<3 .or. p%NumBl<1 )
   InvalidOutput(BStC3_B1_Myi) = ( p%CompBStC<3 .or. p%NumBl<1 )
   InvalidOutput(BStC3_B1_Mzi) = ( p%CompBStC<3 .or. p%NumBl<1 )
   InvalidOutput(BStC3_B1_Fxn) = ( p%CompBStC<3 .or. p%NumBl<1 )
   InvalidOutput(BStC3_B1_Fyn) = ( p%CompBStC<3 .or. p%NumBl<1 )
   InvalidOutput(BStC3_B1_Fzn) = ( p%CompBStC<3 .or. p%NumBl<1 )
   InvalidOutput(BStC3_B1_Mxn) = ( p%CompBStC<3 .or. p%NumBl<1 )
   InvalidOutput(BStC3_B1_Myn) = ( p%CompBStC<3 .or. p%NumBl<1 )
   InvalidOutput(BStC3_B1_Mzn) = ( p%CompBStC<3 .or. p%NumBl<1 )
   InvalidOutput( BStC4_B1_XQ) = ( p%CompBStC<4 .or. p%NumBl<1 )
   InvalidOutput(BStC4_B1_XQD) = ( p%CompBStC<4 .or. p%NumBl<1 )
   InvalidOutput( BStC4_B1_YQ) = ( p%CompBStC<4 .or. p%NumBl<1 )
   InvalidOutput(BStC4_B1_YQD) = ( p%CompBStC<4 .or. p%NumBl<1 )
   InvalidOutput( BStC4_B1_ZQ) = ( p%CompBStC<4 .or. p%NumBl<1 )
   InvalidOutput(BStC4_B1_ZQD) = ( p%CompBStC<4 .or. p%NumBl<1 )
   InvalidOutput(BStC4_B1_Fxi) = ( p%CompBStC<4 .or. p%NumBl<1 )
   InvalidOutput(BStC4_B1_Fyi) = ( p%CompBStC<4 .or. p%NumBl<1 )
   InvalidOutput(BStC4_B1_Fzi) = ( p%CompBStC<4 .or. p%NumBl<1 )
   InvalidOutput(BStC4_B1_Mxi) = ( p%CompBStC<4 .or. p%NumBl<1 )
   InvalidOutput(BStC4_B1_Myi) = ( p%CompBStC<4 .or. p%NumBl<1 )
   InvalidOutput(BStC4_B1_Mzi) = ( p%CompBStC<4 .or. p%NumBl<1 )
   InvalidOutput(BStC4_B1_Fxn) = ( p%CompBStC<4 .or. p%NumBl<1 )
   InvalidOutput(BStC4_B1_Fyn) = ( p%CompBStC<4 .or. p%NumBl<1 )
   InvalidOutput(BStC4_B1_Fzn) = ( p%CompBStC<4 .or. p%NumBl<1 )
   InvalidOutput(BStC4_B1_Mxn) = ( p%CompBStC<4 .or. p%NumBl<1 )
   InvalidOutput(BStC4_B1_Myn) = ( p%CompBStC<4 .or. p%NumBl<1 )
   InvalidOutput(BStC4_B1_Mzn) = ( p%CompBStC<4 .or. p%NumBl<1 )
   InvalidOutput( BStC1_B2_XQ) = ( p%CompBStC<1 .or. p%NumBl<2 )
   InvalidOutput(BStC1_B2_XQD) = ( p%CompBStC<1 .or. p%NumBl<2 )
   InvalidOutput( BStC1_B2_YQ) = ( p%CompBStC<1 .or. p%NumBl<2 )
   InvalidOutput(BStC1_B2_YQD) = ( p%CompBStC<1 .or. p%NumBl<2 )
   InvalidOutput( BStC1_B2_ZQ) = ( p%CompBStC<1 .or. p%NumBl<2 )
   InvalidOutput(BStC1_B2_ZQD) = ( p%CompBStC<1 .or. p%NumBl<2 )
   InvalidOutput(BStC1_B2_Fxi) = ( p%CompBStC<1 .or. p%NumBl<2 )
   InvalidOutput(BStC1_B2_Fyi) = ( p%CompBStC<1 .or. p%NumBl<2 )
   InvalidOutput(BStC1_B2_Fzi) = ( p%CompBStC<1 .or. p%NumBl<2 )
   InvalidOutput(BStC1_B2_Mxi) = ( p%CompBStC<1 .or. p%NumBl<2 )
   InvalidOutput(BStC1_B2_Myi) = ( p%CompBStC<1 .or. p%NumBl<2 )
   InvalidOutput(BStC1_B2_Mzi) = ( p%CompBStC<1 .or. p%NumBl<2 )
   InvalidOutput(BStC1_B2_Fxn) = ( p%CompBStC<1 .or. p%NumBl<2 )
   InvalidOutput(BStC1_B2_Fyn) = ( p%CompBStC<1 .or. p%NumBl<2 )
   InvalidOutput(BStC1_B2_Fzn) = ( p%CompBStC<1 .or. p%NumBl<2 )
   InvalidOutput(BStC1_B2_Mxn) = ( p%CompBStC<1 .or. p%NumBl<2 )
   InvalidOutput(BStC1_B2_Myn) = ( p%CompBStC<1 .or. p%NumBl<2 )
   InvalidOutput(BStC1_B2_Mzn) = ( p%CompBStC<1 .or. p%NumBl<2 )
   InvalidOutput( BStC2_B2_XQ) = ( p%CompBStC<2 .or. p%NumBl<2 )
   InvalidOutput(BStC2_B2_XQD) = ( p%CompBStC<2 .or. p%NumBl<2 )
   InvalidOutput( BStC2_B2_YQ) = ( p%CompBStC<2 .or. p%NumBl<2 )
   InvalidOutput(BStC2_B2_YQD) = ( p%CompBStC<2 .or. p%NumBl<2 )
   InvalidOutput( BStC2_B2_ZQ) = ( p%CompBStC<2 .or. p%NumBl<2 )
   InvalidOutput(BStC2_B2_ZQD) = ( p%CompBStC<2 .or. p%NumBl<2 )
   InvalidOutput(BStC2_B2_Fxi) = ( p%CompBStC<2 .or. p%NumBl<2 )
   InvalidOutput(BStC2_B2_Fyi) = ( p%CompBStC<2 .or. p%NumBl<2 )
   InvalidOutput(BStC2_B2_Fzi) = ( p%CompBStC<2 .or. p%NumBl<2 )
   InvalidOutput(BStC2_B2_Mxi) = ( p%CompBStC<2 .or. p%NumBl<2 )
   InvalidOutput(BStC2_B2_Myi) = ( p%CompBStC<2 .or. p%NumBl<2 )
   InvalidOutput(BStC2_B2_Mzi) = ( p%CompBStC<2 .or. p%NumBl<2 )
   InvalidOutput(BStC2_B2_Fxn) = ( p%CompBStC<2 .or. p%NumBl<2 )
   InvalidOutput(BStC2_B2_Fyn) = ( p%CompBStC<2 .or. p%NumBl<2 )
   InvalidOutput(BStC2_B2_Fzn) = ( p%CompBStC<2 .or. p%NumBl<2 )
   InvalidOutput(BStC2_B2_Mxn) = ( p%CompBStC<2 .or. p%NumBl<2 )
   InvalidOutput(BStC2_B2_Myn) = ( p%CompBStC<2 .or. p%NumBl<2 )
   InvalidOutput(BStC2_B2_Mzn) = ( p%CompBStC<2 .or. p%NumBl<2 )
   InvalidOutput( BStC3_B2_XQ) = ( p%CompBStC<3 .or. p%NumBl<2 )
   InvalidOutput(BStC3_B2_XQD) = ( p%CompBStC<3 .or. p%NumBl<2 )
   InvalidOutput( BStC3_B2_YQ) = ( p%CompBStC<3 .or. p%NumBl<2 )
   InvalidOutput(BStC3_B2_YQD) = ( p%CompBStC<3 .or. p%NumBl<2 )
   InvalidOutput( BStC3_B2_ZQ) = ( p%CompBStC<3 .or. p%NumBl<2 )
   InvalidOutput(BStC3_B2_ZQD) = ( p%CompBStC<3 .or. p%NumBl<2 )
   InvalidOutput(BStC3_B2_Fxi) = ( p%CompBStC<3 .or. p%NumBl<2 )
   InvalidOutput(BStC3_B2_Fyi) = ( p%CompBStC<3 .or. p%NumBl<2 )
   InvalidOutput(BStC3_B2_Fzi) = ( p%CompBStC<3 .or. p%NumBl<2 )
   InvalidOutput(BStC3_B2_Mxi) = ( p%CompBStC<3 .or. p%NumBl<2 )
   InvalidOutput(BStC3_B2_Myi) = ( p%CompBStC<3 .or. p%NumBl<2 )
   InvalidOutput(BStC3_B2_Mzi) = ( p%CompBStC<3 .or. p%NumBl<2 )
   InvalidOutput(BStC3_B2_Fxn) = ( p%CompBStC<3 .or. p%NumBl<2 )
   InvalidOutput(BStC3_B2_Fyn) = ( p%CompBStC<3 .or. p%NumBl<2 )
   InvalidOutput(BStC3_B2_Fzn) = ( p%CompBStC<3 .or. p%NumBl<2 )
   InvalidOutput(BStC3_B2_Mxn) = ( p%CompBStC<3 .or. p%NumBl<2 )
   InvalidOutput(BStC3_B2_Myn) = ( p%CompBStC<3 .or. p%NumBl<2 )
   InvalidOutput(BStC3_B2_Mzn) = ( p%CompBStC<3 .or. p%NumBl<2 )
   InvalidOutput( BStC4_B2_XQ) = ( p%CompBStC<4 .or. p%NumBl<2 )
   InvalidOutput(BStC4_B2_XQD) = ( p%CompBStC<4 .or. p%NumBl<2 )
   InvalidOutput( BStC4_B2_YQ) = ( p%CompBStC<4 .or. p%NumBl<2 )
   InvalidOutput(BStC4_B2_YQD) = ( p%CompBStC<4 .or. p%NumBl<2 )
   InvalidOutput( BStC4_B2_ZQ) = ( p%CompBStC<4 .or. p%NumBl<2 )
   InvalidOutput(BStC4_B2_ZQD) = ( p%CompBStC<4 .or. p%NumBl<2 )
   InvalidOutput(BStC4_B2_Fxi) = ( p%CompBStC<4 .or. p%NumBl<2 )
   InvalidOutput(BStC4_B2_Fyi) = ( p%CompBStC<4 .or. p%NumBl<2 )
   InvalidOutput(BStC4_B2_Fzi) = ( p%CompBStC<4 .or. p%NumBl<2 )
   InvalidOutput(BStC4_B2_Mxi) = ( p%CompBStC<4 .or. p%NumBl<2 )
   InvalidOutput(BStC4_B2_Myi) = ( p%CompBStC<4 .or. p%NumBl<2 )
   InvalidOutput(BStC4_B2_Mzi) = ( p%CompBStC<4 .or. p%NumBl<2 )
   InvalidOutput(BStC4_B2_Fxn) = ( p%CompBStC<4 .or. p%NumBl<2 )
   InvalidOutput(BStC4_B2_Fyn) = ( p%CompBStC<4 .or. p%NumBl<2 )
   InvalidOutput(BStC4_B2_Fzn) = ( p%CompBStC<4 .or. p%NumBl<2 )
   InvalidOutput(BStC4_B2_Mxn) = ( p%CompBStC<4 .or. p%NumBl<2 )
   InvalidOutput(BStC4_B2_Myn) = ( p%CompBStC<4 .or. p%NumBl<2 )
   InvalidOutput(BStC4_B2_Mzn) = ( p%CompBStC<4 .or. p%NumBl<2 )
   InvalidOutput( BStC1_B3_XQ) = ( p%CompBStC<1 .or. p%NumBl<3 )
   InvalidOutput(BStC1_B3_XQD) = ( p%CompBStC<1 .or. p%NumBl<3 )
   InvalidOutput( BStC1_B3_YQ) = ( p%CompBStC<1 .or. p%NumBl<3 )
   InvalidOutput(BStC1_B3_YQD) = ( p%CompBStC<1 .or. p%NumBl<3 )
   InvalidOutput( BStC1_B3_ZQ) = ( p%CompBStC<1 .or. p%NumBl<3 )
   InvalidOutput(BStC1_B3_ZQD) = ( p%CompBStC<1 .or. p%NumBl<3 )
   InvalidOutput(BStC1_B3_Fxi) = ( p%CompBStC<1 .or. p%NumBl<3 )
   InvalidOutput(BStC1_B3_Fyi) = ( p%CompBStC<1 .or. p%NumBl<3 )
   InvalidOutput(BStC1_B3_Fzi) = ( p%CompBStC<1 .or. p%NumBl<3 )
   InvalidOutput(BStC1_B3_Mxi) = ( p%CompBStC<1 .or. p%NumBl<3 )
   InvalidOutput(BStC1_B3_Myi) = ( p%CompBStC<1 .or. p%NumBl<3 )
   InvalidOutput(BStC1_B3_Mzi) = ( p%CompBStC<1 .or. p%NumBl<3 )
   InvalidOutput(BStC1_B3_Fxn) = ( p%CompBStC<1 .or. p%NumBl<3 )
   InvalidOutput(BStC1_B3_Fyn) = ( p%CompBStC<1 .or. p%NumBl<3 )
   InvalidOutput(BStC1_B3_Fzn) = ( p%CompBStC<1 .or. p%NumBl<3 )
   InvalidOutput(BStC1_B3_Mxn) = ( p%CompBStC<1 .or. p%NumBl<3 )
   InvalidOutput(BStC1_B3_Myn) = ( p%CompBStC<1 .or. p%NumBl<3 )
   InvalidOutput(BStC1_B3_Mzn) = ( p%CompBStC<1 .or. p%NumBl<3 )
   InvalidOutput( BStC2_B3_XQ) = ( p%CompBStC<2 .or. p%NumBl<3 )
   InvalidOutput(BStC2_B3_XQD) = ( p%CompBStC<2 .or. p%NumBl<3 )
   InvalidOutput( BStC2_B3_YQ) = ( p%CompBStC<2 .or. p%NumBl<3 )
   InvalidOutput(BStC2_B3_YQD) = ( p%CompBStC<2 .or. p%NumBl<3 )
   InvalidOutput( BStC2_B3_ZQ) = ( p%CompBStC<2 .or. p%NumBl<3 )
   InvalidOutput(BStC2_B3_ZQD) = ( p%CompBStC<2 .or. p%NumBl<3 )
   InvalidOutput(BStC2_B3_Fxi) = ( p%CompBStC<2 .or. p%NumBl<3 )
   InvalidOutput(BStC2_B3_Fyi) = ( p%CompBStC<2 .or. p%NumBl<3 )
   InvalidOutput(BStC2_B3_Fzi) = ( p%CompBStC<2 .or. p%NumBl<3 )
   InvalidOutput(BStC2_B3_Mxi) = ( p%CompBStC<2 .or. p%NumBl<3 )
   InvalidOutput(BStC2_B3_Myi) = ( p%CompBStC<2 .or. p%NumBl<3 )
   InvalidOutput(BStC2_B3_Mzi) = ( p%CompBStC<2 .or. p%NumBl<3 )
   InvalidOutput(BStC2_B3_Fxn) = ( p%CompBStC<2 .or. p%NumBl<3 )
   InvalidOutput(BStC2_B3_Fyn) = ( p%CompBStC<2 .or. p%NumBl<3 )
   InvalidOutput(BStC2_B3_Fzn) = ( p%CompBStC<2 .or. p%NumBl<3 )
   InvalidOutput(BStC2_B3_Mxn) = ( p%CompBStC<2 .or. p%NumBl<3 )
   InvalidOutput(BStC2_B3_Myn) = ( p%CompBStC<2 .or. p%NumBl<3 )
   InvalidOutput(BStC2_B3_Mzn) = ( p%CompBStC<2 .or. p%NumBl<3 )
   InvalidOutput( BStC3_B3_XQ) = ( p%CompBStC<3 .or. p%NumBl<3 )
   InvalidOutput(BStC3_B3_XQD) = ( p%CompBStC<3 .or. p%NumBl<3 )
   InvalidOutput( BStC3_B3_YQ) = ( p%CompBStC<3 .or. p%NumBl<3 )
   InvalidOutput(BStC3_B3_YQD) = ( p%CompBStC<3 .or. p%NumBl<3 )
   InvalidOutput( BStC3_B3_ZQ) = ( p%CompBStC<3 .or. p%NumBl<3 )
   InvalidOutput(BStC3_B3_ZQD) = ( p%CompBStC<3 .or. p%NumBl<3 )
   InvalidOutput(BStC3_B3_Fxi) = ( p%CompBStC<3 .or. p%NumBl<3 )
   InvalidOutput(BStC3_B3_Fyi) = ( p%CompBStC<3 .or. p%NumBl<3 )
   InvalidOutput(BStC3_B3_Fzi) = ( p%CompBStC<3 .or. p%NumBl<3 )
   InvalidOutput(BStC3_B3_Mxi) = ( p%CompBStC<3 .or. p%NumBl<3 )
   InvalidOutput(BStC3_B3_Myi) = ( p%CompBStC<3 .or. p%NumBl<3 )
   InvalidOutput(BStC3_B3_Mzi) = ( p%CompBStC<3 .or. p%NumBl<3 )
   InvalidOutput(BStC3_B3_Fxn) = ( p%CompBStC<3 .or. p%NumBl<3 )
   InvalidOutput(BStC3_B3_Fyn) = ( p%CompBStC<3 .or. p%NumBl<3 )
   InvalidOutput(BStC3_B3_Fzn) = ( p%CompBStC<3 .or. p%NumBl<3 )
   InvalidOutput(BStC3_B3_Mxn) = ( p%CompBStC<3 .or. p%NumBl<3 )
   InvalidOutput(BStC3_B3_Myn) = ( p%CompBStC<3 .or. p%NumBl<3 )
   InvalidOutput(BStC3_B3_Mzn) = ( p%CompBStC<3 .or. p%NumBl<3 )
   InvalidOutput( BStC4_B3_XQ) = ( p%CompBStC<4 .or. p%NumBl<3 )
   InvalidOutput(BStC4_B3_XQD) = ( p%CompBStC<4 .or. p%NumBl<3 )
   InvalidOutput( BStC4_B3_YQ) = ( p%CompBStC<4 .or. p%NumBl<3 )
   InvalidOutput(BStC4_B3_YQD) = ( p%CompBStC<4 .or. p%NumBl<3 )
   InvalidOutput( BStC4_B3_ZQ) = ( p%CompBStC<4 .or. p%NumBl<3 )
   InvalidOutput(BStC4_B3_ZQD) = ( p%CompBStC<4 .or. p%NumBl<3 )
   InvalidOutput(BStC4_B3_Fxi) = ( p%CompBStC<4 .or. p%NumBl<3 )
   InvalidOutput(BStC4_B3_Fyi) = ( p%CompBStC<4 .or. p%NumBl<3 )
   InvalidOutput(BStC4_B3_Fzi) = ( p%CompBStC<4 .or. p%NumBl<3 )
   InvalidOutput(BStC4_B3_Mxi) = ( p%CompBStC<4 .or. p%NumBl<3 )
   InvalidOutput(BStC4_B3_Myi) = ( p%CompBStC<4 .or. p%NumBl<3 )
   InvalidOutput(BStC4_B3_Mzi) = ( p%CompBStC<4 .or. p%NumBl<3 )
   InvalidOutput(BStC4_B3_Fxn) = ( p%CompBStC<4 .or. p%NumBl<3 )
   InvalidOutput(BStC4_B3_Fyn) = ( p%CompBStC<4 .or. p%NumBl<3 )
   InvalidOutput(BStC4_B3_Fzn) = ( p%CompBStC<4 .or. p%NumBl<3 )
   InvalidOutput(BStC4_B3_Mxn) = ( p%CompBStC<4 .or. p%NumBl<3 )
   InvalidOutput(BStC4_B3_Myn) = ( p%CompBStC<4 .or. p%NumBl<3 )
   InvalidOutput(BStC4_B3_Mzn) = ( p%CompBStC<4 .or. p%NumBl<3 )
   InvalidOutput( BStC1_B4_XQ) = ( p%CompBStC<1 .or. p%NumBl<4 )
   InvalidOutput(BStC1_B4_XQD) = ( p%CompBStC<1 .or. p%NumBl<4 )
   InvalidOutput( BStC1_B4_YQ) = ( p%CompBStC<1 .or. p%NumBl<4 )
   InvalidOutput(BStC1_B4_YQD) = ( p%CompBStC<1 .or. p%NumBl<4 )
   InvalidOutput( BStC1_B4_ZQ) = ( p%CompBStC<1 .or. p%NumBl<4 )
   InvalidOutput(BStC1_B4_ZQD) = ( p%CompBStC<1 .or. p%NumBl<4 )
   InvalidOutput(BStC1_B4_Fxi) = ( p%CompBStC<1 .or. p%NumBl<4 )
   InvalidOutput(BStC1_B4_Fyi) = ( p%CompBStC<1 .or. p%NumBl<4 )
   InvalidOutput(BStC1_B4_Fzi) = ( p%CompBStC<1 .or. p%NumBl<4 )
   InvalidOutput(BStC1_B4_Mxi) = ( p%CompBStC<1 .or. p%NumBl<4 )
   InvalidOutput(BStC1_B4_Myi) = ( p%CompBStC<1 .or. p%NumBl<4 )
   InvalidOutput(BStC1_B4_Mzi) = ( p%CompBStC<1 .or. p%NumBl<4 )
   InvalidOutput(BStC1_B4_Fxn) = ( p%CompBStC<1 .or. p%NumBl<4 )
   InvalidOutput(BStC1_B4_Fyn) = ( p%CompBStC<1 .or. p%NumBl<4 )
   InvalidOutput(BStC1_B4_Fzn) = ( p%CompBStC<1 .or. p%NumBl<4 )
   InvalidOutput(BStC1_B4_Mxn) = ( p%CompBStC<1 .or. p%NumBl<4 )
   InvalidOutput(BStC1_B4_Myn) = ( p%CompBStC<1 .or. p%NumBl<4 )
   InvalidOutput(BStC1_B4_Mzn) = ( p%CompBStC<1 .or. p%NumBl<4 )
   InvalidOutput( BStC2_B4_XQ) = ( p%CompBStC<2 .or. p%NumBl<4 )
   InvalidOutput(BStC2_B4_XQD) = ( p%CompBStC<2 .or. p%NumBl<4 )
   InvalidOutput( BStC2_B4_YQ) = ( p%CompBStC<2 .or. p%NumBl<4 )
   InvalidOutput(BStC2_B4_YQD) = ( p%CompBStC<2 .or. p%NumBl<4 )
   InvalidOutput( BStC2_B4_ZQ) = ( p%CompBStC<2 .or. p%NumBl<4 )
   InvalidOutput(BStC2_B4_ZQD) = ( p%CompBStC<2 .or. p%NumBl<4 )
   InvalidOutput(BStC2_B4_Fxi) = ( p%CompBStC<2 .or. p%NumBl<4 )
   InvalidOutput(BStC2_B4_Fyi) = ( p%CompBStC<2 .or. p%NumBl<4 )
   InvalidOutput(BStC2_B4_Fzi) = ( p%CompBStC<2 .or. p%NumBl<4 )
   InvalidOutput(BStC2_B4_Mxi) = ( p%CompBStC<2 .or. p%NumBl<4 )
   InvalidOutput(BStC2_B4_Myi) = ( p%CompBStC<2 .or. p%NumBl<4 )
   InvalidOutput(BStC2_B4_Mzi) = ( p%CompBStC<2 .or. p%NumBl<4 )
   InvalidOutput(BStC2_B4_Fxn) = ( p%CompBStC<2 .or. p%NumBl<4 )
   InvalidOutput(BStC2_B4_Fyn) = ( p%CompBStC<2 .or. p%NumBl<4 )
   InvalidOutput(BStC2_B4_Fzn) = ( p%CompBStC<2 .or. p%NumBl<4 )
   InvalidOutput(BStC2_B4_Mxn) = ( p%CompBStC<2 .or. p%NumBl<4 )
   InvalidOutput(BStC2_B4_Myn) = ( p%CompBStC<2 .or. p%NumBl<4 )
   InvalidOutput(BStC2_B4_Mzn) = ( p%CompBStC<2 .or. p%NumBl<4 )
   InvalidOutput( BStC3_B4_XQ) = ( p%CompBStC<3 .or. p%NumBl<4 )
   InvalidOutput(BStC3_B4_XQD) = ( p%CompBStC<3 .or. p%NumBl<4 )
   InvalidOutput( BStC3_B4_YQ) = ( p%CompBStC<3 .or. p%NumBl<4 )
   InvalidOutput(BStC3_B4_YQD) = ( p%CompBStC<3 .or. p%NumBl<4 )
   InvalidOutput( BStC3_B4_ZQ) = ( p%CompBStC<3 .or. p%NumBl<4 )
   InvalidOutput(BStC3_B4_ZQD) = ( p%CompBStC<3 .or. p%NumBl<4 )
   InvalidOutput(BStC3_B4_Fxi) = ( p%CompBStC<3 .or. p%NumBl<4 )
   InvalidOutput(BStC3_B4_Fyi) = ( p%CompBStC<3 .or. p%NumBl<4 )
   InvalidOutput(BStC3_B4_Fzi) = ( p%CompBStC<3 .or. p%NumBl<4 )
   InvalidOutput(BStC3_B4_Mxi) = ( p%CompBStC<3 .or. p%NumBl<4 )
   InvalidOutput(BStC3_B4_Myi) = ( p%CompBStC<3 .or. p%NumBl<4 )
   InvalidOutput(BStC3_B4_Mzi) = ( p%CompBStC<3 .or. p%NumBl<4 )
   InvalidOutput(BStC3_B4_Fxn) = ( p%CompBStC<3 .or. p%NumBl<4 )
   InvalidOutput(BStC3_B4_Fyn) = ( p%CompBStC<3 .or. p%NumBl<4 )
   InvalidOutput(BStC3_B4_Fzn) = ( p%CompBStC<3 .or. p%NumBl<4 )
   InvalidOutput(BStC3_B4_Mxn) = ( p%CompBStC<3 .or. p%NumBl<4 )
   InvalidOutput(BStC3_B4_Myn) = ( p%CompBStC<3 .or. p%NumBl<4 )
   InvalidOutput(BStC3_B4_Mzn) = ( p%CompBStC<3 .or. p%NumBl<4 )
   InvalidOutput( BStC4_B4_XQ) = ( p%CompBStC<4 .or. p%NumBl<4 )
   InvalidOutput(BStC4_B4_XQD) = ( p%CompBStC<4 .or. p%NumBl<4 )
   InvalidOutput( BStC4_B4_YQ) = ( p%CompBStC<4 .or. p%NumBl<4 )
   InvalidOutput(BStC4_B4_YQD) = ( p%CompBStC<4 .or. p%NumBl<4 )
   InvalidOutput( BStC4_B4_ZQ) = ( p%CompBStC<4 .or. p%NumBl<4 )
   InvalidOutput(BStC4_B4_ZQD) = ( p%CompBStC<4 .or. p%NumBl<4 )
   InvalidOutput(BStC4_B4_Fxi) = ( p%CompBStC<4 .or. p%NumBl<4 )
   InvalidOutput(BStC4_B4_Fyi) = ( p%CompBStC<4 .or. p%NumBl<4 )
   InvalidOutput(BStC4_B4_Fzi) = ( p%CompBStC<4 .or. p%NumBl<4 )
   InvalidOutput(BStC4_B4_Mxi) = ( p%CompBStC<4 .or. p%NumBl<4 )
   InvalidOutput(BStC4_B4_Myi) = ( p%CompBStC<4 .or. p%NumBl<4 )
   InvalidOutput(BStC4_B4_Mzi) = ( p%CompBStC<4 .or. p%NumBl<4 )
   InvalidOutput(BStC4_B4_Fxn) = ( p%CompBStC<4 .or. p%NumBl<4 )
   InvalidOutput(BStC4_B4_Fyn) = ( p%CompBStC<4 .or. p%NumBl<4 )
   InvalidOutput(BStC4_B4_Fzn) = ( p%CompBStC<4 .or. p%NumBl<4 )
   InvalidOutput(BStC4_B4_Mxn) = ( p%CompBStC<4 .or. p%NumBl<4 )
   InvalidOutput(BStC4_B4_Myn) = ( p%CompBStC<4 .or. p%NumBl<4 )
   InvalidOutput(BStC4_B4_Mzn) = ( p%CompBStC<4 .or. p%NumBl<4 )
   InvalidOutput( PtfmStC1_XQ) = ( p%CompPtfmStC<1 )
   InvalidOutput(PtfmStC1_XQD) = ( p%CompPtfmStC<1 )
   InvalidOutput( PtfmStC1_YQ) = ( p%CompPtfmStC<1 )
   InvalidOutput(PtfmStC1_YQD) = ( p%CompPtfmStC<1 )
   InvalidOutput( PtfmStC1_ZQ) = ( p%CompPtfmStC<1 )
   InvalidOutput(PtfmStC1_ZQD) = ( p%CompPtfmStC<1 )
   InvalidOutput(PtfmStC1_Fxi) = ( p%CompPtfmStC<1 )
   InvalidOutput(PtfmStC1_Fyi) = ( p%CompPtfmStC<1 )
   InvalidOutput(PtfmStC1_Fzi) = ( p%CompPtfmStC<1 )
   InvalidOutput(PtfmStC1_Mxi) = ( p%CompPtfmStC<1 )
   InvalidOutput(PtfmStC1_Myi) = ( p%CompPtfmStC<1 )
   InvalidOutput(PtfmStC1_Mzi) = ( p%CompPtfmStC<1 )
   InvalidOutput(PtfmStC1_Fxn) = ( p%CompPtfmStC<1 )
   InvalidOutput(PtfmStC1_Fyn) = ( p%CompPtfmStC<1 )
   InvalidOutput(PtfmStC1_Fzn) = ( p%CompPtfmStC<1 )
   InvalidOutput(PtfmStC1_Mxn) = ( p%CompPtfmStC<1 )
   InvalidOutput(PtfmStC1_Myn) = ( p%CompPtfmStC<1 )
   InvalidOutput(PtfmStC1_Mzn) = ( p%CompPtfmStC<1 )
   InvalidOutput( PtfmStC2_XQ) = ( p%CompPtfmStC<2 )
   InvalidOutput(PtfmStC2_XQD) = ( p%CompPtfmStC<2 )
   InvalidOutput( PtfmStC2_YQ) = ( p%CompPtfmStC<2 )
   InvalidOutput(PtfmStC2_YQD) = ( p%CompPtfmStC<2 )
   InvalidOutput( PtfmStC2_ZQ) = ( p%CompPtfmStC<2 )
   InvalidOutput(PtfmStC2_ZQD) = ( p%CompPtfmStC<2 )
   InvalidOutput(PtfmStC2_Fxi) = ( p%CompPtfmStC<2 )
   InvalidOutput(PtfmStC2_Fyi) = ( p%CompPtfmStC<2 )
   InvalidOutput(PtfmStC2_Fzi) = ( p%CompPtfmStC<2 )
   InvalidOutput(PtfmStC2_Mxi) = ( p%CompPtfmStC<2 )
   InvalidOutput(PtfmStC2_Myi) = ( p%CompPtfmStC<2 )
   InvalidOutput(PtfmStC2_Mzi) = ( p%CompPtfmStC<2 )
   InvalidOutput(PtfmStC2_Fxn) = ( p%CompPtfmStC<2 )
   InvalidOutput(PtfmStC2_Fyn) = ( p%CompPtfmStC<2 )
   InvalidOutput(PtfmStC2_Fzn) = ( p%CompPtfmStC<2 )
   InvalidOutput(PtfmStC2_Mxn) = ( p%CompPtfmStC<2 )
   InvalidOutput(PtfmStC2_Myn) = ( p%CompPtfmStC<2 )
   InvalidOutput(PtfmStC2_Mzn) = ( p%CompPtfmStC<2 )
   InvalidOutput( PtfmStC3_XQ) = ( p%CompPtfmStC<3 )
   InvalidOutput(PtfmStC3_XQD) = ( p%CompPtfmStC<3 )
   InvalidOutput( PtfmStC3_YQ) = ( p%CompPtfmStC<3 )
   InvalidOutput(PtfmStC3_YQD) = ( p%CompPtfmStC<3 )
   InvalidOutput( PtfmStC3_ZQ) = ( p%CompPtfmStC<3 )
   InvalidOutput(PtfmStC3_ZQD) = ( p%CompPtfmStC<3 )
   InvalidOutput(PtfmStC3_Fxi) = ( p%CompPtfmStC<3 )
   InvalidOutput(PtfmStC3_Fyi) = ( p%CompPtfmStC<3 )
   InvalidOutput(PtfmStC3_Fzi) = ( p%CompPtfmStC<3 )
   InvalidOutput(PtfmStC3_Mxi) = ( p%CompPtfmStC<3 )
   InvalidOutput(PtfmStC3_Myi) = ( p%CompPtfmStC<3 )
   InvalidOutput(PtfmStC3_Mzi) = ( p%CompPtfmStC<3 )
   InvalidOutput(PtfmStC3_Fxn) = ( p%CompPtfmStC<3 )
   InvalidOutput(PtfmStC3_Fyn) = ( p%CompPtfmStC<3 )
   InvalidOutput(PtfmStC3_Fzn) = ( p%CompPtfmStC<3 )
   InvalidOutput(PtfmStC3_Mxn) = ( p%CompPtfmStC<3 )
   InvalidOutput(PtfmStC3_Myn) = ( p%CompPtfmStC<3 )
   InvalidOutput(PtfmStC3_Mzn) = ( p%CompPtfmStC<3 )
   InvalidOutput( PtfmStC4_XQ) = ( p%CompPtfmStC<4 )
   InvalidOutput(PtfmStC4_XQD) = ( p%CompPtfmStC<4 )
   InvalidOutput( PtfmStC4_YQ) = ( p%CompPtfmStC<4 )
   InvalidOutput(PtfmStC4_YQD) = ( p%CompPtfmStC<4 )
   InvalidOutput( PtfmStC4_ZQ) = ( p%CompPtfmStC<4 )
   InvalidOutput(PtfmStC4_ZQD) = ( p%CompPtfmStC<4 )
   InvalidOutput(PtfmStC4_Fxi) = ( p%CompPtfmStC<4 )
   InvalidOutput(PtfmStC4_Fyi) = ( p%CompPtfmStC<4 )
   InvalidOutput(PtfmStC4_Fzi) = ( p%CompPtfmStC<4 )
   InvalidOutput(PtfmStC4_Mxi) = ( p%CompPtfmStC<4 )
   InvalidOutput(PtfmStC4_Myi) = ( p%CompPtfmStC<4 )
   InvalidOutput(PtfmStC4_Mzi) = ( p%CompPtfmStC<4 )
   InvalidOutput(PtfmStC4_Fxn) = ( p%CompPtfmStC<4 )
   InvalidOutput(PtfmStC4_Fyn) = ( p%CompPtfmStC<4 )
   InvalidOutput(PtfmStC4_Fzn) = ( p%CompPtfmStC<4 )
   InvalidOutput(PtfmStC4_Mxn) = ( p%CompPtfmStC<4 )
   InvalidOutput(PtfmStC4_Myn) = ( p%CompPtfmStC<4 )
   InvalidOutput(PtfmStC4_Mzn) = ( p%CompPtfmStC<4 )


   !-------------------------------------------------------------------------------------------------
   ! Allocate and set index, name, and units for the output channels
   ! If a selected output channel is not available in this module, set error flag.
   !-------------------------------------------------------------------------------------------------

   ALLOCATE ( p%OutParam(0:p%NumOuts) , STAT=ErrStat2 )
   IF ( ErrStat2 /= 0_IntKi )  THEN
      CALL SetErrStat( ErrID_Fatal,"Error allocating memory for the ServoDyn OutParam array.", ErrStat, ErrMsg, RoutineName )
      RETURN
   ENDIF

      ! Set index, name, and units for the time output channel:

   p%OutParam(0)%Indx  = Time
   p%OutParam(0)%Name  = "Time"    ! OutParam(0) is the time channel by default.
   p%OutParam(0)%Units = "(s)"
   p%OutParam(0)%SignM = 1


      ! Set index, name, and units for all of the output channels.
      ! If a selected output channel is not available by this module set ErrStat = ErrID_Warn.

   DO I = 1,p%NumOuts

      p%OutParam(I)%Name  = OutList(I)
      OutListTmp          = OutList(I)

      ! Reverse the sign (+/-) of the output channel if the user prefixed the
      !   channel name with a "-", "_", "m", or "M" character indicating "minus".


      CheckOutListAgain = .FALSE.

      IF      ( INDEX( "-_", OutListTmp(1:1) ) > 0 ) THEN
         p%OutParam(I)%SignM = -1                         ! ex, "-TipDxc1" causes the sign of TipDxc1 to be switched.
         OutListTmp          = OutListTmp(2:)
      ELSE IF ( INDEX( "mM", OutListTmp(1:1) ) > 0 ) THEN ! We'll assume this is a variable name for now, (if not, we will check later if OutListTmp(2:) is also a variable name)
         CheckOutListAgain   = .TRUE.
         p%OutParam(I)%SignM = 1
      ELSE
         p%OutParam(I)%SignM = 1
      END IF

      CALL Conv2UC( OutListTmp )    ! Convert OutListTmp to upper case


      Indx = IndexCharAry( OutListTmp(1:OutStrLenM1), ValidParamAry )


         ! If it started with an "M" (CheckOutListAgain) we didn't find the value in our list (Indx < 1)

      IF ( CheckOutListAgain .AND. Indx < 1 ) THEN    ! Let's assume that "M" really meant "minus" and then test again
         p%OutParam(I)%SignM = -1                     ! ex, "MTipDxc1" causes the sign of TipDxc1 to be switched.
         OutListTmp          = OutListTmp(2:)

         Indx = IndexCharAry( OutListTmp(1:OutStrLenM1), ValidParamAry )
      END IF


      IF ( Indx > 0 ) THEN ! we found the channel name
         IF ( InvalidOutput( ParamIndxAry(Indx) ) ) THEN  ! but, it isn't valid for these settings
            p%OutParam(I)%Indx  = 0                 ! pick any valid channel (I just picked "Time=0" here because it's universal)
            p%OutParam(I)%Units = "INVALID"
            p%OutParam(I)%SignM = 0
         ELSE
            p%OutParam(I)%Indx  = ParamIndxAry(Indx)
            p%OutParam(I)%Units = ParamUnitsAry(Indx) ! it's a valid output
         END IF
      ELSE ! this channel isn't valid
         p%OutParam(I)%Indx  = 0                    ! pick any valid channel (I just picked "Time=0" here because it's universal)
         p%OutParam(I)%Units = "INVALID"
         p%OutParam(I)%SignM = 0                    ! multiply all results by zero

         CALL SetErrStat(ErrID_Fatal, TRIM(p%OutParam(I)%Name)//" is not an available output channel.",ErrStat,ErrMsg,RoutineName)
      END IF

   END DO

   RETURN
END SUBROUTINE SetOutParam
!----------------------------------------------------------------------------------------------------------------------------------
!End of code generated by Matlab script
!**********************************************************************************************************************************
!----------------------------------------------------------------------------------------------------------------------------------  
!> Routine for computing the tip-brake output: TBDrCon. This routine is used in both loose and tight coupling.
SUBROUTINE TipBrake_CalcOutput( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg )
!..................................................................................................................................

   REAL(DbKi),                     INTENT(IN   )  :: t           !< Current simulation time in seconds
   TYPE(SrvD_InputType),           INTENT(IN   )  :: u           !< Inputs at t
   TYPE(SrvD_ParameterType),       INTENT(IN   )  :: p           !< Parameters
   TYPE(SrvD_ContinuousStateType), INTENT(IN   )  :: x           !< Continuous states at t
   TYPE(SrvD_DiscreteStateType),   INTENT(IN   )  :: xd          !< Discrete states at t
   TYPE(SrvD_ConstraintStateType), INTENT(IN   )  :: z           !< Constraint states at t
   TYPE(SrvD_OtherStateType),      INTENT(IN   )  :: OtherState  !< Other states at t
   TYPE(SrvD_OutputType),          INTENT(INOUT)  :: y           !< Outputs computed at t (Input only so that mesh con-
                                                                 !!   nectivity information does not have to be recalculated)
   TYPE(SrvD_MiscVarType),         INTENT(INOUT)  :: m           !< Misc (optimization) variables
   INTEGER(IntKi),                 INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                   INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None
  
      ! local variables      
   INTEGER(IntKi)                                 :: K           ! counter for blades


      ! Initialize ErrStat

   ErrStat = ErrID_None
   ErrMsg  = ""


   !...................................................................
   ! Calculate standard tip brake commands:
   !...................................................................
      
   DO K = 1,p%NumBl
      
      IF ( OtherState%BegTpBr(K) )  THEN                       ! The tip brakes have been deployed.

         y%TBDrCon(K) = p%TBDrConN + ( p%TBDrConD - p%TBDrConN ) * TBFract( t, OtherState%TTpBrDp(K), OtherState%TTpBrFl(K) )

      ELSE                                                     ! The tip brakes haven't been deployed yet.

         y%TBDrCon(K) = p%TBDrConN

      ENDIF
      
   END DO      
!returns TBDrCon, or N and D part of ElastoDyn, return 0<=TBFrac<=1, consistant with other controllers

END SUBROUTINE TipBrake_CalcOutput
!-------------------------------------------------------------------------------------------------------------------------------
!> A math S-function for the fraction of tip brake drag between normal and fully deployed operation.
!! (This function was formerly part of RtHS.)
FUNCTION TBFract( t, BrakStrt, BrakEnd )
!...............................................................................................................................

   IMPLICIT                        NONE

      ! Passed Variables:

   REAL(DbKi), INTENT(IN )      :: t                                               !< Current time
   REAL(DbKi), INTENT(IN )      :: BrakEnd                                         !< Time at which brakes are fully deployed
   REAL(DbKi), INTENT(IN )      :: BrakStrt                                        !< Time at which brakes are first deployed
   REAL(ReKi)                   :: TBFract                                         !< This function.


      ! Local Variables.

   REAL(DbKi)                   :: TmpVar                                          ! A temporary variable

      
      
   IF ( t <= BrakStrt )  THEN

      TBFract = 0.0

   ELSEIF ( t < BrakEnd )  THEN

      TmpVar  = ( ( t - BrakStrt )/( BrakStrt - BrakEnd ) )**2
      TBFract = TmpVar*( 2.0 - TmpVar )

   ELSE

      TBFract = 1.0

   ENDIF

   RETURN
END FUNCTION TBFract
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine updates the other states of the tip brakes: BegTpBr, TTpBrDp, and TTpBrFl
SUBROUTINE TipBrake_UpdateStates( t, u, p, x, xd, z, OtherState, m, ErrStat, ErrMsg )
!..................................................................................................................................

   REAL(DbKi),                      INTENT(IN   ) :: t           !< t+dt
   TYPE(SrvD_InputType),            INTENT(IN   ) :: u           !< Inputs at t+dt
   TYPE(SrvD_ParameterType),        INTENT(IN   ) :: p           !< Parameters
   TYPE(SrvD_ContinuousStateType),  INTENT(INOUT) :: x           !< Input: Continuous states at t;
                                                                 !!   Output: Continuous states at t + dt
   TYPE(SrvD_DiscreteStateType),    INTENT(INOUT) :: xd          !< Input: Discrete states at t;
                                                                 !!   Output: Discrete states at t + dt
   TYPE(SrvD_ConstraintStateType),  INTENT(INOUT) :: z           !< Input: Constraint states at t;
                                                                 !!   Output: Constraint states at t + dt
   TYPE(SrvD_OtherStateType),       INTENT(INOUT) :: OtherState  !< Other states: Other states at t;
                                                                 !!   Output: Other states at t + dt
   TYPE(SrvD_MiscVarType),          INTENT(INOUT) :: m           !< Misc (optimization) variables
   INTEGER(IntKi),                  INTENT(  OUT) :: ErrStat     !< Error status of the operation
   CHARACTER(*),                    INTENT(  OUT) :: ErrMsg      !< Error message if ErrStat /= ErrID_None
  
      ! local variables      
   INTEGER(IntKi)                                 :: K           ! counter for blades


      ! Initialize ErrStat

   ErrStat = ErrID_None
   ErrMsg  = ""


   !...................................................................
   ! Determine if tip brakes should be deployed:
   !...................................................................
 
   DO K = 1,p%NumBl
      
      IF ( .not. OtherState%BegTpBr(k) )  THEN        ! The tip brakes have not been deployed yet

         IF ( u%RotSpeed >= p%TBDepISp(K) )  THEN     ! The tip brakes deploy due to speed

            OtherState%BegTpBr(k) = .true.
            OtherState%TTpBrDp(K) = t                 ! time first deployed (0%)
            OtherState%TTpBrFl(K) = t + p%TpBrDT      ! time fully deployed (100%)

         ENDIF
      
      END IF
      
   END DO      

END SUBROUTINE TipBrake_UpdateStates
!-------------------------------------------------------------------------------------------------------------------------------
!> This routine calculates the drive-train torque outputs: GenTrq, ElecPwr, and HSSBrTrqC
SUBROUTINE Torque_CalcOutput( t, u, p, x, xd, z, OtherState, y, m, ErrStat, ErrMsg )
!..................................................................................................................................

   REAL(DbKi),                     INTENT(IN   )  :: t           !< Current simulation time in seconds
   TYPE(SrvD_InputType),           INTENT(IN   )  :: u           !< Inputs at t
   TYPE(SrvD_ParameterType),       INTENT(IN   )  :: p           !< Parameters
   TYPE(SrvD_ContinuousStateType), INTENT(IN   )  :: x           !< Continuous states at t
   TYPE(SrvD_DiscreteStateType),   INTENT(IN   )  :: xd          !< Discrete states at t
   TYPE(SrvD_ConstraintStateType), INTENT(IN   )  :: z           !< Constraint states at t
   TYPE(SrvD_OtherStateType),      INTENT(IN   )  :: OtherState  !< Other states at t
   TYPE(SrvD_OutputType),          INTENT(INOUT)  :: y           !< Outputs computed at t (Input only so that mesh con-
                                                                 !!   nectivity information does not have to be recalculated)
   TYPE(SrvD_MiscVarType),         INTENT(INOUT)  :: m           !< Misc (optimization) variables
   INTEGER(IntKi),                 INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                   INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None

      ! Local variables:

   REAL(ReKi)                   :: HSSBrFrac                     ! Fraction of full braking torque {0 (off) <= HSSBrFrac <= 1 (full)} (-)



      ! Initialize variables
   ErrStat = ErrID_None
   ErrMsg  = ''


   
   !.................................................................................
   ! Calculate generator torque (y%GenTrq) and electrical power (y%ElecPwr):
   !.................................................................................
   
   IF ( OtherState%GenOnLine .and. .not. OtherState%Off4Good )  THEN    ! Generator is on line.
      CALL CalculateTorque( t, u, p, m, y%GenTrq, y%ElecPwr, ErrStat, ErrMsg )
      if (ErrStat >= AbortErrLev) return
   ELSE                                                                 ! Generator is off line.
      y%GenTrq  = 0.0_ReKi
      y%ElecPwr = 0.0_ReKi
   ENDIF

   !...................................................................
   ! Apply trim case for linearization:
   !...................................................................
   if (p%TrimCase == TrimCase_torque) then
      y%GenTrq = y%GenTrq + xd%CtrlOffset
   end if

   !.................................................................................
   ! Calculate the magnitude of HSS brake torque from DLL controller
   !.................................................................................
   IF (p%HSSBrMode == ControlMode_DLL) THEN

      y%HSSBrTrqC = m%dll_data%HSSBrTrqDemand

   ELSE

      !.................................................................................
      ! Calculate the fraction of applied HSS-brake torque, HSSBrFrac:
      !.................................................................................
      IF ( t <= p%THSSBrDp )  THEN    ! HSS brake not deployed yet.

         HSSBrFrac = 0.0_ReKi

      ELSE                             ! HSS brake deployed.


         SELECT CASE ( p%HSSBrMode )                 ! Which HSS brake model are we using?
         
         CASE ( ControlMode_NONE)                    ! None
         
            HSSBrFrac = 0.0_ReKi
         
         CASE ( ControlMode_SIMPLE )                 ! Simple built-in HSS brake model with linear ramp.

            IF ( t < p%THSSBrFl )  THEN ! Linear ramp
               HSSBrFrac = ( t - p%THSSBrDp )/p%HSSBrDT
            ELSE                        ! Full braking torque
               HSSBrFrac = 1.0
            ENDIF

         CASE ( ControlMode_USER )                   ! User-defined HSS brake model.

            CALL UserHSSBr ( y%GenTrq, y%ElecPwr, u%HSS_Spd, p%NumBl, t, p%DT, p%RootName, HSSBrFrac )

            IF ( ( HSSBrFrac < 0.0_ReKi ) .OR. ( HSSBrFrac > 1.0_ReKi ) )  THEN   ! 0 (off) <= HSSBrFrac <= 1 (full); else Abort.
               ErrStat = ErrID_Fatal
               ErrMsg  = 'HSSBrFrac must be between 0.0 (off) and 1.0 (full) (inclusive). Fix logic in routine UserHSSBr().'
               RETURN
            END IF

         !!!CASE ( ControlMode_DLL )                    ! User-defined HSS brake model from Bladed-style DLL
         !!!
         !!!   HSSBrFrac = 1.0_ReKi !   just a placeholder, since it never reaches this case
         
         CASE ( ControlMode_EXTERN )                 ! HSS brake model from LabVIEW.

            HSSBrFrac = u%ExternalHSSBrFrac

         ENDSELECT

         HSSBrFrac = MAX( MIN( HSSBrFrac, 1.0_ReKi ), 0.0_ReKi )  ! make sure we didn't get outside the acceptable range: 0 (off) <= HSSBrFrac <= 1 (full)
   
      ENDIF
   

      ! Calculate the magnitude of HSS brake torque:

      !y%HSSBrTrqC = SIGN( HSSBrFrac*p%HSSBrTqF, u%HSS_Spd )  ! Scale the full braking torque by the brake torque fraction and make sure the brake torque resists motion.
      y%HSSBrTrqC = HSSBrFrac*p%HSSBrTqF  ! Scale the full braking torque by the brake torque fraction (don't worry about the sign here).
      
   END IF
   
      ! to avoid issues with ElastoDyn extrapolating between +/- p%HSSBrTqF, we're going to make this output always positive
   y%HSSBrTrqC = ABS(y%HSSBrTrqC)
   
   RETURN
   
END SUBROUTINE Torque_CalcOutput
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine updates the other states of the torque control: GenOnLine, and Off4Good
SUBROUTINE Torque_UpdateStates( t, u, p, x, xd, z, OtherState, m, ErrStat, ErrMsg )
!..................................................................................................................................

   REAL(DbKi),                      INTENT(IN   ) :: t           !< t+dt
   TYPE(SrvD_InputType),            INTENT(IN   ) :: u           !< Inputs at t+dt
   TYPE(SrvD_ParameterType),        INTENT(IN   ) :: p           !< Parameters
   TYPE(SrvD_ContinuousStateType),  INTENT(INOUT) :: x           !< Input: Continuous states at t;
                                                                 !!   Output: Continuous states at t + dt
   TYPE(SrvD_DiscreteStateType),    INTENT(INOUT) :: xd          !< Input: Discrete states at t;
                                                                 !!   Output: Discrete states at t + dt
   TYPE(SrvD_ConstraintStateType),  INTENT(INOUT) :: z           !< Input: Constraint states at t;
                                                                 !!   Output: Constraint states at t + dt
   TYPE(SrvD_OtherStateType),       INTENT(INOUT) :: OtherState  !< Other states: Other states at t;
                                                                 !!   Output: Other states at t + dt
   TYPE(SrvD_MiscVarType),         INTENT(INOUT)  :: m           !< Misc (optimization) variables
   INTEGER(IntKi),                 INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                   INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None

      
      ! Local variables:
   REAL(ReKi)                                     :: GenTrq      !< generator torque
   REAL(ReKi)                                     :: ElecPwr     !< electrical power



      ! Initialize variables
   ErrStat = ErrID_None
   ErrMsg  = ''


      ! See if the generator is on line.
   IF ( .not. OtherState%Off4Good )  THEN
      
      ! The generator is either on-line or has never been turned online.

      IF ( OtherState%GenOnLine )  THEN   ! The generator is on-line.

         IF ( ( p%GenTiStp ) .AND. ( t > p%TimGenOf .OR. EqualRealNos(t,p%TimGenOf) ) )  THEN   ! Shut-down of generator determined by time, TimGenOf
            OtherState%Off4Good = .true.
         ENDIF

      ELSE ! The generator has never been turned online.

         IF ( p%GenTiStr )  THEN   ! Start-up of generator determined by time, TimGenOn
            IF ( t > p%TimGenOn .OR. EqualRealNos(t,p%TimGenOn) )  THEN
               OtherState%GenOnLine = .true.
            END IF
         ELSE                    ! Start-up of generator determined by HSS speed, SpdGenOn
            IF ( u%HSS_Spd > p%SpdGenOn .OR. EqualRealNos(u%HSS_Spd, p%SpdGenOn) )  THEN
               OtherState%GenOnLine = .true.
            END IF
         ENDIF

      ENDIF

   ENDIF


   IF ( OtherState%GenOnLine .and. .not. OtherState%Off4Good )  THEN    ! Generator is on line.

      ! Lets turn the generator offline for good if ( GenTiStp = .FALSE. ) .AND. ( ElecPwr <= 0.0 ):

      IF ( ( .NOT. p%GenTiStp ) ) then
         
         CALL CalculateTorque( t, u, p, m, GenTrq, ElecPwr, ErrStat, ErrMsg ) 
         if (ErrStat >= AbortErrLev) return
         
         IF ( ElecPwr <= 0.0_ReKi ) THEN   ! Shut-down of generator determined by generator power = 0
            OtherState%Off4Good = .true.
         END IF
               
      END IF

   ENDIF
   
END SUBROUTINE Torque_UpdateStates
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine calculates the drive-train torque (GenTrq, ElecPwr) assuming the generator is on.
SUBROUTINE CalculateTorque( t, u, p, m, GenTrq, ElecPwr, ErrStat, ErrMsg )
!..................................................................................................................................

   REAL(DbKi),                     INTENT(IN   )  :: t           !< Current simulation time in seconds
   TYPE(SrvD_InputType),           INTENT(IN   )  :: u           !< Inputs at t
   TYPE(SrvD_ParameterType),       INTENT(IN   )  :: p           !< Parameters
   TYPE(SrvD_MiscVarType),         INTENT(INOUT)  :: m           !< Misc (optimization) variables
   
   REAL(ReKi),                     INTENT(  OUT)  :: GenTrq      !< generator torque command
   REAL(ReKi),                     INTENT(  OUT)  :: ElecPwr     !< electrical power
   INTEGER(IntKi),                 INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                   INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None

      ! Local variables:

   COMPLEX(ReKi)                                  :: Current1    ! Current passing through the stator (amps)
   COMPLEX(ReKi)                                  :: Current2    ! Current passing through the rotor (amps)
   COMPLEX(ReKi)                                  :: Currentm    ! Magnitizing current (amps)
                                                  
   REAL(ReKi)                                     :: ComDenom    ! Common denominator of variables used in the TEC model
   REAL(ReKi)                                     :: PwrLossS    ! Power loss in the stator (watts)
   REAL(ReKi)                                     :: PwrLossR    ! Power loss in the rotor (watts)
   REAL(ReKi)                                     :: PwrMech     ! Mechanical power (watts)
   REAL(ReKi)                                     :: Slip        ! Generator slip
   REAL(ReKi)                                     :: SlipRat     ! Generator slip ratio
      
   REAL(ReKi)                                     :: S2          ! SlipRat**2
   
   character(*), parameter                        :: RoutineName = 'CalculateTorque'

      ! Initialize variables
   ErrStat = ErrID_None
   ErrMsg  = ''

   GenTrq  = 0.0_ReKi
   ElecPwr = 0.0_ReKi
   

         ! Are we doing simple variable-speed control, or using a generator model?

         SELECT CASE ( p%VSContrl )               ! Are we using variable-speed control?

            CASE ( ControlMode_NONE )                ! No variable-speed control.  Using a generator model.


               SELECT CASE ( p%GenModel )            ! Which generator model are we using?

                  CASE ( ControlMode_SIMPLE )                          ! Simple induction-generator model.


                     Slip = u%HSS_Spd - p%SIG_SySp

                     IF ( ABS( Slip ) > p%SIG_POSl  )  THEN
                        GenTrq  = SIGN( p%SIG_POTq, Slip )
                     ELSE
                        GenTrq  = Slip*p%SIG_Slop
                     ENDIF
                  
                     ElecPwr = CalculateElecPwr( GenTrq, u, p )


                  CASE ( ControlMode_ADVANCED )                          ! Thevenin-equivalent generator model.


                     SlipRat  = ( u%HSS_Spd - p%TEC_SySp )/p%TEC_SySp

                     GenTrq    = p%TEC_A0*(p%TEC_VLL**2)*SlipRat &
                                /( p%TEC_C0 + p%TEC_C1*SlipRat + p%TEC_C2*(SlipRat**2) )

                        ! trying to refactor so we don't divide by SlipRat, which may be 0
                        ! jmj tells me I need not worry about ComDenom being zero because these equations behave nicely
                     S2 = SlipRat**2
                  
                     ComDenom  = ( SlipRat*p%TEC_Re1 - p%TEC_RRes )**2 + (SlipRat*( p%TEC_Xe1 + p%TEC_RLR ))**2                  
                     Current2  = CMPLX(  p%TEC_V1a*SlipRat*( SlipRat*p%TEC_Re1 - p%TEC_RRes )/ComDenom , &
                                        -p%TEC_V1a*S2     *(         p%TEC_Xe1 + p%TEC_RLR  )/ComDenom     )                  
                     Currentm  = CMPLX( 0.0_ReKi , -p%TEC_V1a/p%TEC_MR )                  
                     Current1  = Current2 + Currentm
                  
                     PwrLossS  = 3.0*( ( ABS( Current1 ) )**2 )*p%TEC_SRes
                     PwrLossR  = 3.0*( ( ABS( Current2 ) )**2 )*p%TEC_RRes
                  
                     PwrMech   = GenTrq*u%HSS_Spd
                     ElecPwr   = PwrMech - PwrLossS - PwrLossR
                                    

                  CASE ( ControlMode_USER )                          ! User-defined generator model.


            !        CALL UserGen ( u%HSS_Spd, u%LSS_Spd, p%NumBl, t, DT, p%GenEff, DelGenTrq, DirRoot, GenTrq, ElecPwr )
                     CALL UserGen ( u%HSS_Spd, u%LSS_Spd, p%NumBl, t, p%DT, p%GenEff, 0.0_ReKi, p%RootName, GenTrq, ElecPwr )

               END SELECT


            CASE ( ControlMode_SIMPLE )              ! Simple variable-speed control.


               if ( u%HSS_Spd < 0.0_ReKi) then
                  if (.not. equalRealNos(u%HSS_Spd, 0.0_ReKi) ) then
                     call SetErrStat( ErrID_Fatal, "u%HSS_Spd is negative. Simple variable-speed control model "//&
                                      "is not valid for motoring situations.", ErrStat, ErrMsg, RoutineName)
                     return
                  end if               
               end if
            
            ! Compute the generator torque, which depends on which region we are in:

               IF ( u%HSS_Spd >= p%VS_RtGnSp )  THEN      ! We are in region 3 - torque is constant
                  GenTrq = p%VS_RtTq
               ELSEIF ( u%HSS_Spd < p%VS_TrGnSp )  THEN   ! We are in region 2 - torque is proportional to the square of the generator speed
                  GenTrq = p%VS_Rgn2K* (u%HSS_Spd**2)
               ELSE                                       ! We are in region 2 1/2 - simple induction generator transition region
                  GenTrq = p%VS_Slope*( u%HSS_Spd - p%VS_SySp )
               ENDIF


            ! It's not possible to motor using this control scheme, so the generator efficiency is always subtractive.

               ElecPwr = GenTrq*u%HSS_Spd*p%GenEff
               !y%ElecPwr = CalculateElecPwr( y%GenTrq, u, p )

            CASE ( ControlMode_USER )                              ! User-defined variable-speed control for routine UserVSCont().


               CALL UserVSCont ( u%HSS_Spd, u%LSS_Spd, p%NumBl, t, p%DT, p%GenEff, 0.0_ReKi, p%RootName, GenTrq, ElecPwr )

            CASE ( ControlMode_DLL )                                ! User-defined variable-speed control from Bladed-style DLL
            
               ! bjj: I believe this is how the old logic worked, but perhaps now we can be more clever about checking if the generator is off
            
               IF ( m%dll_data%GenState /= 0_IntKi ) THEN ! generator is on    
               
                  GenTrq = m%dll_data%GenTrq
               ElecPwr = CalculateElecPwr( GenTrq, u, p )
                        
               ELSE ! generator is off
               
                  GenTrq   = 0.0_ReKi
                  ElecPwr  = 0.0_ReKi
               
               END IF
                        
            CASE ( ControlMode_EXTERN )                             ! User-defined variable-speed control from Simulink or LabVIEW.

               GenTrq  = u%ExternalGenTrq
               ElecPwr = u%ExternalElecPwr

         END SELECT


      ! Lets turn the generator offline for good if ( GenTiStp = .FALSE. ) .AND. ( ElecPwr <= 0.0 ):

      IF ( ( .NOT. p%GenTiStp ) .AND. ( ElecPwr <= 0.0_ReKi ) ) THEN   ! Shut-down of generator determined by generator power = 0
         GenTrq   = 0.0_ReKi
         ElecPwr  = 0.0_ReKi
      ENDIF

   
END SUBROUTINE CalculateTorque
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine calculates the electrical power (ElecPwr) after the electrical generator torque (GenTrq) has been calculated.
FUNCTION CalculateElecPwr( GenTrq, u, p )
!...............................................................................................................................
REAL(ReKi),                INTENT(IN)  :: GenTrq               !< generator torque computed at t 
TYPE(SrvD_InputType),      INTENT(IN)  :: u                    !< Inputs at t
TYPE(SrvD_ParameterType),  INTENT(IN)  :: p                    !< Parameters
   
REAL(ReKi)                                :: CalculateElecPwr     !< The result of this function
   
      !! The generator efficiency is either additive for motoring,
      !!   or subtractive for generating power.

   IF ( GenTrq >= 0.0_ReKi )  THEN
      CalculateElecPwr = GenTrq * u%HSS_Spd * p%GenEff
   ELSE
      CalculateElecPwr = GenTrq * u%HSS_Spd / p%GenEff
   ENDIF   
   
END FUNCTION CalculateElecPwr
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine calculates the partials with respect to inputs of the drive-train torque outputs: GenTrq and ElecPwr
SUBROUTINE Torque_JacobianPInput( t, u, p, x, xd, z, OtherState, m, GenTrq_du, ElecPwr_du, ErrStat, ErrMsg )
!..................................................................................................................................

   REAL(DbKi),                     INTENT(IN   )  :: t           !< Current simulation time in seconds
   TYPE(SrvD_InputType),           INTENT(IN   )  :: u           !< Inputs at t
   TYPE(SrvD_ParameterType),       INTENT(IN   )  :: p           !< Parameters
   TYPE(SrvD_ContinuousStateType), INTENT(IN   )  :: x           !< Continuous states at t
   TYPE(SrvD_DiscreteStateType),   INTENT(IN   )  :: xd          !< Discrete states at t
   TYPE(SrvD_ConstraintStateType), INTENT(IN   )  :: z           !< Constraint states at t
   TYPE(SrvD_OtherStateType),      INTENT(IN   )  :: OtherState  !< Other states at t
   TYPE(SrvD_MiscVarType),         INTENT(INOUT)  :: m           !< Misc (optimization) variables
   REAL(R8Ki),                     INTENT(  OUT)  :: GenTrq_du   !< partial derivative of generator torque output with respect to HSS_Spd input
   REAL(R8Ki),                     INTENT(  OUT)  :: ElecPwr_du  !< partial derivative of electrical power output with respect to HSS_Spd input
   INTEGER(IntKi),                 INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                   INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None

 

      ! Initialize variables
   ErrStat = ErrID_None
   ErrMsg  = ''
   
   !.................................................................................
   ! Calculate generator torque (y%GenTrq) and electrical power (y%ElecPwr):
   !.................................................................................
   
   IF ( OtherState%GenOnLine .and. .not. OtherState%Off4Good )  THEN    ! Generator is on line.
      CALL CalculateTorqueJacobian( t, u, p, m, GenTrq_du, ElecPwr_du, ErrStat, ErrMsg )
      if (ErrStat >= AbortErrLev) return
   ELSE                                                                 ! Generator is off line.
      GenTrq_du  = 0.0_R8Ki
      ElecPwr_du = 0.0_R8Ki
   ENDIF

   
   !.................................................................................
   ! Calculate the fraction of applied HSS-brake torque, HSSBrFrac:
   !.................................................................................
   ! we're ignorming HSSBrFrac in linearization
   
   RETURN
   
END SUBROUTINE Torque_JacobianPInput
!----------------------------------------------------------------------------------------------------------------------------------
!> This routine calculates jacobians (with respect to u%HSS_Spd) of the drive-train torque (GenTrq, ElecPwr) assuming the generator is on.
SUBROUTINE CalculateTorqueJacobian( t, u, p, m, GenTrq_du, ElecPwr_du, ErrStat, ErrMsg )
!..................................................................................................................................

   REAL(DbKi),                     INTENT(IN   )  :: t           !< Current simulation time in seconds
   TYPE(SrvD_InputType),           INTENT(IN   )  :: u           !< Inputs at t
   TYPE(SrvD_ParameterType),       INTENT(IN   )  :: p           !< Parameters
   TYPE(SrvD_MiscVarType),         INTENT(INOUT)  :: m           !< Misc (optimization) variables
   
   REAL(R8Ki),                     INTENT(  OUT)  :: GenTrq_du   !< partial generator torque / partial u%HSS_Spd
   REAL(R8Ki),                     INTENT(  OUT)  :: ElecPwr_du  !< partialelectrical power / partial u%HSS_Spd
   INTEGER(IntKi),                 INTENT(  OUT)  :: ErrStat     !< Error status of the operation
   CHARACTER(*),                   INTENT(  OUT)  :: ErrMsg      !< Error message if ErrStat /= ErrID_None

      ! Local variables:

   REAL(R8Ki)                                     :: Current1_r, Current1_r_du  ! Current passing through the stator (amps) and its derivative w.r.t. u%HSS_Spd
   REAL(R8Ki)                                     :: Current1_i, Current1_i_du  ! Current passing through the stator (amps) and its derivative w.r.t. u%HSS_Spd
   REAL(R8Ki)                                     :: Current2_r, Current2_r_du  ! Current passing through the rotor (amps) and its derivative w.r.t. u%HSS_Spd
   REAL(R8Ki)                                     :: Current2_i, Current2_i_du  ! Current passing through the rotor (amps) and its derivative w.r.t. u%HSS_Spd
                                                  
   REAL(R8Ki)                                     :: GenTrq      ! generator torque
   
   REAL(R8Ki)                                     :: ComDenom, ComDenom_du  ! temporary variable (common denominator)
   REAL(R8Ki)                                     :: PwrLossS_du ! Power loss in the stator (watts) and its derivative w.r.t. u%HSS_Spd 
   REAL(R8Ki)                                     :: PwrLossR_du ! Power loss in the rotor (watts) and its derivative w.r.t. u%HSS_Spd 
   REAL(R8Ki)                                     :: PwrMech_du  ! partial derivative of Mechanical power (watts) w.r.t. u%HSS_Spd
   REAL(R8Ki)                                     :: Slip        ! Generator slip
   REAL(R8Ki)                                     :: SlipRat     ! Generator slip ratio
   
   REAL(R8Ki)                                     :: A, B, dAdu, dBdu
   REAL(R8Ki)                                     :: SlipRat_du ! temporary variables for computing derivatives
      
   !REAL(ReKi)                                     :: S2          ! SlipRat**2
   
   character(*), parameter                        :: RoutineName = 'CalculateTorqueJacobian'

      ! Initialize variables
   ErrStat = ErrID_None
   ErrMsg  = ''

   GenTrq_du  = 0.0_R8Ki
   ElecPwr_du = 0.0_R8Ki
   

      ! Are we doing simple variable-speed control, or using a generator model?

      SELECT CASE ( p%VSContrl )               ! Are we using variable-speed control?

         CASE ( ControlMode_NONE )                ! No variable-speed control.  Using a generator model.


            SELECT CASE ( p%GenModel )            ! Which generator model are we using?

               CASE ( ControlMode_SIMPLE )                          ! Simple induction-generator model.

                  Slip = u%HSS_Spd - p%SIG_SySp

                  IF ( ABS( Slip ) > p%SIG_POSl  )  THEN
                     GenTrq    = SIGN( real(p%SIG_POTq,R8Ki), Slip )
                     GenTrq_du = 0.0_R8Ki
                  ELSE
                     GenTrq    = Slip*p%SIG_Slop
                     GenTrq_du = p%SIG_Slop
                  ENDIF

                     ! Calculate the electrical powerF
                     !     As generator:  ElecPwr = GenTrq * u%HSS_Spd * m%GenEff 
                     !     As motor:      ElecPwr = GenTrq * u%HSS_Spd / m%GenEff 
                  IF ( GenTrq >= 0.0_R8Ki )  THEN
                     !ElecPwr = GenTrq * u%HSS_Spd * p%GenEff 
                     ElecPwr_du = (GenTrq_du * u%HSS_Spd + GenTrq) * p%GenEff
                  ELSE
                     !ElecPwr = GenTrq * u%HSS_Spd / p%GenEff 
                     ElecPwr_du = (GenTrq_du * u%HSS_Spd + GenTrq) / p%GenEff 
                  ENDIF
                                    
               CASE ( ControlMode_ADVANCED )                          ! Thevenin-equivalent generator model.
                 
                  SlipRat  = ( u%HSS_Spd - p%TEC_SySp )/p%TEC_SySp
                  SlipRat_du = 1.0_R8Ki / p%TEC_SySp
                  
                  A = p%TEC_A0*(p%TEC_VLL**2)*SlipRat
                  B = p%TEC_C0 + p%TEC_C1*SlipRat + p%TEC_C2*(SlipRat**2)

                  dAdu = p%TEC_A0*(p%TEC_VLL**2)*SlipRat_du
                  dBdu = p%TEC_C1*SlipRat_du + 2.0_R8Ki*p%TEC_C2*SlipRat*SlipRat_du
                  
                  GenTrq    =  A / B
                  GenTrq_du = dAdu / B - A/B**2 * dBdu

                  
                  A = SlipRat*p%TEC_Re1 - p%TEC_RRes
                  B = SlipRat*( p%TEC_Xe1 + p%TEC_RLR )
                  dAdu = SlipRat_du * p%TEC_Re1
                  dBdu = SlipRat_du * (p%TEC_Xe1 + p%TEC_RLR)
                  
                  ComDenom  = A**2 + B**2                  
                  ComDenom_du = 2.0_R8Ki * A * dAdu +  2.0_R8Ki * B * dBdu
                  
                                    
                  A = SlipRat**2*p%TEC_Re1 - SlipRat*p%TEC_RRes
                  dAdu = 2.0_R8Ki * SlipRat * SlipRat_du * p%TEC_Re1 - SlipRat_du * p%TEC_RRes
                  Current2_r = p%TEC_V1a*A/ComDenom
                  Current2_r_du = p%TEC_V1a*(dAdu/ComDenom - A/ComDenom**2 * ComDenom_du)
                  
                  Current2_i = -p%TEC_V1a*( p%TEC_Xe1 + p%TEC_RLR  )*SlipRat**2/ComDenom
                  Current2_i_du = -p%TEC_V1a*( p%TEC_Xe1 + p%TEC_RLR ) * ( 2.0_R8Ki*SlipRat*SlipRat_du / ComDenom - SlipRat**2/(ComDenom**2) * ComDenom_du)
                                    
                  Current1_r  = Current2_r
                  Current1_i  = Current2_i - p%TEC_V1a/p%TEC_MR 
                  Current1_r_du = Current2_r_du
                  Current1_i_du = Current2_i_du

                                    
                  !PwrLossS  = 3.0*( Current1_r**2 + Current1_i**2 )*p%TEC_SRes
                  PwrLossS_du = 3.0_R8Ki*p%TEC_SRes*( 2.0_R8Ki*Current1_r*Current1_r_du + 2.0_R8Ki*Current1_i*Current1_i_du )
                  
                  !PwrLossR  = 3.0*( Current2_r**2 + Current2_i**2  )*p%TEC_RRes
                  PwrLossR_du = 3.0_R8Ki*p%TEC_RRes*( 2.0_R8Ki*Current2_r*Current2_r_du + 2.0_R8Ki*Current2_i*Current2_i_du )
                  
                  !PwrMech   = GenTrq*u%HSS_Spd
                  PwrMech_du = GenTrq_du * u%HSS_Spd + GenTrq
                  
                  !ElecPwr   = PwrMech - PwrLossS - PwrLossR
                  ElecPwr_du = PwrMech_du - PwrLossS_du - PwrLossR_du                  
                  
               CASE ( ControlMode_USER )                          ! User-defined generator model.

                     ! we should not get here (initialization should have caught this issue)
                
                  GenTrq_du   = 0.0_R8Ki
                  ElecPwr_du  = 0.0_R8Ki

            END SELECT


         CASE ( ControlMode_SIMPLE )              ! Simple variable-speed control.


            if ( u%HSS_Spd < 0.0_ReKi) then
               if (.not. equalRealNos(u%HSS_Spd, 0.0_ReKi) ) then
                  call SetErrStat( ErrID_Fatal, "u%HSS_Spd is negative. Simple variable-speed control model "//&
                                   "is not valid for motoring situations.", ErrStat, ErrMsg, RoutineName)
                  return
               end if               
            end if
            
         ! Compute the generator torque, which depends on which region we are in:

            IF ( u%HSS_Spd >= p%VS_RtGnSp )  THEN      ! We are in region 3 - torque is constant
               GenTrq    = p%VS_RtTq
               GenTrq_du = 0.0_R8Ki
            ELSEIF ( u%HSS_Spd < p%VS_TrGnSp )  THEN   ! We are in region 2 - torque is proportional to the square of the generator speed
               GenTrq    = p%VS_Rgn2K* (u%HSS_Spd**2)
               GenTrq_du = 2.0_R8Ki * p%VS_Rgn2K * u%HSS_Spd
            ELSE                                       ! We are in region 2 1/2 - simple induction generator transition region
               GenTrq    = p%VS_Slope*( u%HSS_Spd - p%VS_SySp )
               GenTrq_du = p%VS_Slope
            ENDIF            
            
         ! It's not possible to motor using this control scheme, so the generator efficiency is always subtractive.

            ElecPwr_du = (GenTrq_du * u%HSS_Spd + GenTrq) * p%GenEff

            
         CASE ( ControlMode_USER , &                             ! User-defined variable-speed control for routine UserVSCont().
                ControlMode_DLL  , &                             ! User-defined variable-speed control from Bladed-style DLL                                    
                ControlMode_EXTERN )                             ! User-defined variable-speed control from Simulink or LabVIEW.
                
               ! we should not get here (initialization should have caught this issue)
                
            GenTrq_du   = 0.0_R8Ki
            ElecPwr_du  = 0.0_R8Ki

      END SELECT
   
END SUBROUTINE CalculateTorqueJacobian
!----------------------------------------------------------------------------------------------------------------------------------



END MODULE ServoDyn
!**********************************************************************************************************************************
