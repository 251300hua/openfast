!STARTOFREGISTRYGENERATEDFILE 'MoorDyn_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! MoorDyn_Types
!.................................................................................................................................
! This file is part of MoorDyn.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in MoorDyn. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE MoorDyn_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE NWTC_Library
IMPLICIT NONE
! =========  MD_InitInputType  =======
  TYPE, PUBLIC :: MD_InitInputType
    REAL(ReKi)  :: g = -999.9      !< gravity constant [[m/s^2]]
    REAL(ReKi)  :: rhoW = -999.9      !< sea density [[kg/m^3]]
    REAL(ReKi)  :: WtrDepth = -999.9      !< depth of water [[m]]
    REAL(ReKi) , DIMENSION(1:6)  :: PtfmInit      !< initial position of platform [-]
    CHARACTER(1024)  :: FileName      !< MoorDyn input file [-]
    CHARACTER(1024)  :: RootName      !< RootName for writing output files [-]
    LOGICAL  :: Echo      !< echo parameter - do we want to echo the header line describing the input file? [-]
    REAL(DbKi)  :: DTIC      !< convergence check time step for IC generation [[s]]
    REAL(DbKi)  :: TMaxIC = 120      !< maximum time to allow for getting converged ICs [[s]]
    REAL(ReKi)  :: CdScaleIC = 1      !< factor to scale drag coefficients by during dynamic relaxation [[]]
    REAL(ReKi)  :: threshIC = 0.01      !< convergence tolerance for ICs  (0.01 means 1%) [[]]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: WaveVel      !<  [-]
    REAL(ReKi) , DIMENSION(:,:,:), ALLOCATABLE  :: WaveAcc      !<  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: WavePDyn      !<  [-]
    REAL(ReKi) , DIMENSION(:,:), ALLOCATABLE  :: WaveElev      !<  [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: WaveTime      !< Should this be double precision? [-]
  END TYPE MD_InitInputType
! =======================
! =========  MD_LineProp  =======
  TYPE, PUBLIC :: MD_LineProp
    INTEGER(IntKi)  :: IdNum      !< integer identifier of this set of line properties [-]
    CHARACTER(10)  :: name      !< name/identifier of this set of line properties [-]
    REAL(DbKi)  :: d      !< volume-equivalent diameter [[m]]
    REAL(DbKi)  :: w      !< per-length weight in air [[kg/m]]
    REAL(DbKi)  :: EA      !< axial stiffness [[N]]
    REAL(DbKi)  :: BA      !< internal damping coefficient times area [[N-s]]
    REAL(DbKi)  :: EI      !< bending stiffness [[N-m]]
    REAL(DbKi)  :: Can      !< transverse added mass coefficient [-]
    REAL(DbKi)  :: Cat      !< tangential added mass coefficient [-]
    REAL(DbKi)  :: Cdn      !< transverse drag coefficient [-]
    REAL(DbKi)  :: Cdt      !< tangential drag coefficient [-]
    INTEGER(IntKi)  :: nEApoints = 0      !< number of values in stress-strain lookup table (0 means using constant E) [-]
    REAL(DbKi) , DIMENSION(1:30)  :: stiffXs      !< x array for stress-strain lookup table (up to nCoef) [-]
    REAL(DbKi) , DIMENSION(1:30)  :: stiffYs      !< y array for stress-strain lookup table [-]
    INTEGER(IntKi)  :: nBpoints = 0      !< number of values in stress-strainrate lookup table (0 means using constant c) [-]
    REAL(DbKi) , DIMENSION(1:30)  :: dampXs      !< x array for stress-strainrate lookup table (up to nCoef) [-]
    REAL(DbKi) , DIMENSION(1:30)  :: dampYs      !< y array for stress-strainrate lookup table	 [-]
    INTEGER(IntKi)  :: nEIpoints = 0      !< number of values in bending stress-strain lookup table (0 means using constant E) [-]
    REAL(DbKi) , DIMENSION(1:30)  :: bstiffXs      !< x array for stress-strain lookup table (up to nCoef) [-]
    REAL(DbKi) , DIMENSION(1:30)  :: bstiffYs      !< y array for stress-strain lookup table [-]
  END TYPE MD_LineProp
! =======================
! =========  MD_RodProp  =======
  TYPE, PUBLIC :: MD_RodProp
    INTEGER(IntKi)  :: IdNum      !< integer identifier of this set of rod properties [-]
    CHARACTER(10)  :: name      !< name/identifier of this set of rod properties [-]
    REAL(DbKi)  :: d      !< volume-equivalent diameter [[m]]
    REAL(DbKi)  :: w      !< per-length weight in air [[kg/m]]
    REAL(DbKi)  :: Can      !< transverse added mass coefficient [-]
    REAL(DbKi)  :: Cat      !< tangential added mass coefficient [-]
    REAL(DbKi)  :: Cdn      !< transverse drag coefficient [-]
    REAL(DbKi)  :: Cdt      !< tangential drag coefficient [-]
    REAL(DbKi)  :: CdEnd      !< drag coefficient for rod end [[-]]
    REAL(DbKi)  :: CaEnd      !< added mass coefficient for rod end [[-]]
  END TYPE MD_RodProp
! =======================
! =========  MD_Body  =======
  TYPE, PUBLIC :: MD_Body
    INTEGER(IntKi)  :: IdNum      !< integer identifier of this Connection [-]
    INTEGER(IntKi)  :: typeNum      !< integer identifying the type.  0=fixed, 1=vessel, 2=connect [-]
    INTEGER(IntKi) , DIMENSION(1:30)  :: AttachedC      !< list of IdNums of connections attached to this body [-]
    INTEGER(IntKi) , DIMENSION(1:30)  :: AttachedR      !< list of IdNums of rods attached to this body [-]
    INTEGER(IntKi)  :: nAttachedC = 0      !< number of attached connections [-]
    INTEGER(IntKi)  :: nAttachedR = 0      !< number of attached rods [-]
    REAL(DbKi) , DIMENSION(1:3,1:30)  :: rConnectRel      !< relative position of connection on body [-]
    REAL(DbKi) , DIMENSION(1:6,1:30)  :: r6RodRel      !< relative position and orientation of rod on body [-]
    REAL(DbKi)  :: bodyM      !<  [-]
    REAL(DbKi)  :: bodyV      !<  [-]
    REAL(DbKi) , DIMENSION(1:3)  :: bodyI      !<  [-]
    REAL(DbKi) , DIMENSION(1:6)  :: bodyCdA      !< product of drag force and frontal area of connection point [[m^2]]
    REAL(DbKi) , DIMENSION(1:6)  :: bodyCa      !< added mass coefficient of connection point [-]
    REAL(DbKi)  :: time      !< current time [[s]]
    REAL(DbKi) , DIMENSION(1:6)  :: r6      !< position [-]
    REAL(DbKi) , DIMENSION(1:6)  :: v6      !< velocity [-]
    REAL(DbKi) , DIMENSION(1:6)  :: a6      !< acceleration (only used for coupled bodies) [-]
    REAL(DbKi) , DIMENSION(1:3)  :: U      !< water velocity at ref point [[m/s]]
    REAL(DbKi) , DIMENSION(1:3)  :: Ud      !< water acceleration at ref point [[m/s^2]]
    REAL(DbKi)  :: zeta      !< water surface elevation above ref point [[m]]
    REAL(DbKi) , DIMENSION(1:6)  :: F6net      !< total force and moment on body (excluding inertial loads) [-]
    REAL(DbKi) , DIMENSION(1:6,1:6)  :: M6net      !< total mass matrix of Body and any attached objects [-]
    REAL(DbKi) , DIMENSION(1:6,1:6)  :: M      !< rotated body 6-dof mass and inertia matrix in global orientation [-]
    REAL(DbKi) , DIMENSION(1:6,1:6)  :: M0      !< body 6-dof mass and inertia matrix in its own frame [-]
    REAL(DbKi) , DIMENSION(1:3,1:3)  :: OrMat      !< DCM for body orientation [-]
    REAL(DbKi) , DIMENSION(1:3)  :: rCG      !< vector in body frame from ref point to CG (before rods etc..) [-]
  END TYPE MD_Body
! =======================
! =========  MD_Connect  =======
  TYPE, PUBLIC :: MD_Connect
    INTEGER(IntKi)  :: IdNum      !< integer identifier of this Connection [-]
    CHARACTER(10)  :: type      !< type of Connect: fix, vessel, connect [-]
    INTEGER(IntKi)  :: typeNum      !< integer identifying the type.  0=fixed, 1=vessel, 2=connect [-]
    INTEGER(IntKi) , DIMENSION(1:10)  :: Attached      !< list of IdNums of lines attached to this connection node [-]
    INTEGER(IntKi) , DIMENSION(1:10)  :: Top      !< list of ints specifying whether each line is attached at 1 = top/fairlead(end B), 0 = bottom/anchor(end A) [-]
    INTEGER(IntKi)  :: nAttached = 0      !< number of attached lines [-]
    REAL(DbKi)  :: conX      !<  [-]
    REAL(DbKi)  :: conY      !<  [-]
    REAL(DbKi)  :: conZ      !<  [-]
    REAL(DbKi)  :: conM      !<  [-]
    REAL(DbKi)  :: conV      !<  [-]
    REAL(DbKi)  :: conFX      !<  [-]
    REAL(DbKi)  :: conFY      !<  [-]
    REAL(DbKi)  :: conFZ      !<  [-]
    REAL(DbKi)  :: conCa      !< added mass coefficient of connection point [-]
    REAL(DbKi)  :: conCdA      !< product of drag force and frontal area of connection point [[m^2]]
    REAL(DbKi)  :: time      !< current time [[s]]
    REAL(DbKi) , DIMENSION(1:3)  :: r      !< position [-]
    REAL(DbKi) , DIMENSION(1:3)  :: rd      !< velocity [-]
    REAL(DbKi) , DIMENSION(1:3)  :: a      !< acceleration (only used for coupled points) [-]
    REAL(DbKi) , DIMENSION(1:3)  :: U      !< water velocity at node [[m/s]]
    REAL(DbKi) , DIMENSION(1:3)  :: Ud      !< water acceleration at node [[m/s^2]]
    REAL(DbKi)  :: zeta      !< water surface elevation above node [[m]]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: PDyn      !< water dynamic pressure at node [[Pa]]
    REAL(DbKi) , DIMENSION(1:3)  :: Fnet      !< total force on node (excluding inertial loads) [-]
    REAL(DbKi) , DIMENSION(1:3,1:3)  :: M      !< node mass matrix, from attached lines [-]
  END TYPE MD_Connect
! =======================
! =========  MD_Rod  =======
  TYPE, PUBLIC :: MD_Rod
    INTEGER(IntKi)  :: IdNum      !< integer identifier of this Line [-]
    CHARACTER(10)  :: type      !< type of Rod.  should match one of RodProp names [-]
    INTEGER(IntKi)  :: PropsIdNum      !< the IdNum of the associated rod properties [-]
    INTEGER(IntKi)  :: typeNum      !< integer identifying the type.  0=fixed, 1=vessel, 2=connect [-]
    INTEGER(IntKi) , DIMENSION(1:10)  :: AttachedA      !< list of IdNums of lines attached to end A [-]
    INTEGER(IntKi) , DIMENSION(1:10)  :: AttachedB      !< list of IdNums of lines attached to end B [-]
    INTEGER(IntKi) , DIMENSION(1:10)  :: TopA      !< list of ints specifying whether each line is attached at 1 = top/fairlead(end B), 0 = bottom/anchor(end A) [-]
    INTEGER(IntKi) , DIMENSION(1:10)  :: TopB      !< list of ints specifying whether each line is attached at 1 = top/fairlead(end B), 0 = bottom/anchor(end A) [-]
    INTEGER(IntKi)  :: nAttachedA = 0      !< number of attached lines to Rod end A [-]
    INTEGER(IntKi)  :: nAttachedB = 0      !< number of attached lines to Rod end B [-]
    INTEGER(IntKi) , DIMENSION(1:20)  :: OutFlagList      !< array specifying what line quantities should be output (1 vs 0) [-]
    INTEGER(IntKi)  :: N      !< The number of elements in the line [-]
    INTEGER(IntKi)  :: endTypeA      !< type of connection at end A: 0=pinned to Connection, 1=cantilevered to Rod. [-]
    INTEGER(IntKi)  :: endTypeB      !< type of connection at end B: 0=pinned to Connection, 1=cantilevered to Rod. [-]
    REAL(DbKi)  :: UnstrLen      !< length of the rod [[m]]
    REAL(DbKi)  :: mass      !< mass of the rod [[kg]]
    REAL(DbKi)  :: rho      !< density [[kg/m3]]
    REAL(DbKi)  :: d      !< volume-equivalent diameter [[m]]
    REAL(DbKi)  :: Can      !<  [[-]]
    REAL(DbKi)  :: Cat      !<  [[-]]
    REAL(DbKi)  :: Cdn      !<  [[-]]
    REAL(DbKi)  :: Cdt      !<  [[-]]
    REAL(DbKi)  :: CdEnd      !< drag coefficient for rod end [[-]]
    REAL(DbKi)  :: CaEnd      !< added mass coefficient for rod end [[-]]
    REAL(DbKi)  :: time      !< current time [[s]]
    REAL(DbKi)  :: roll      !< roll relative to vertical [deg]
    REAL(DbKi)  :: pitch      !< pitch relative to vertical [deg]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: r      !< node positions [-]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: rd      !< node velocities [-]
    REAL(DbKi) , DIMENSION(1:3)  :: q      !< tangent vector for rod as a whole [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: l      !< segment unstretched length [[m]]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: V      !< segment volume [[m^3]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: U      !< water velocity at node [[m/s]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Ud      !< water acceleration at node [[m/s^2]]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: zeta      !< water surface elevation above node [[m]]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: PDyn      !< water dynamic pressure at node [[Pa]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: W      !< weight vectors [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Bo      !< buoyancy force vectors [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Pd      !< dynamic pressure force vectors [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Dp      !< node drag (transverse) [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Dq      !< node drag (axial) [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Ap      !< node added mass forcing (transverse) [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Aq      !< node added mass forcing (axial) [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: B      !< node bottom contact force [[N]]
    REAL(DbKi) , DIMENSION(:,:), ALLOCATABLE  :: Fnet      !< total force on node [[N]]
    REAL(DbKi) , DIMENSION(:,:,:), ALLOCATABLE  :: M      !< node mass matrix [[kg]]
    REAL(DbKi) , DIMENSION(1:3)  :: Mext      !< external moment vector holding sum of any externally applied moments i.e. bending lines [-]
    REAL(DbKi) , DIMENSION(1:6)  :: r6      !< 6 DOF position vector [-]
    REAL(DbKi) , DIMENSION(1:6)  :: v6      !< 6 DOF velocity vector [-]
    REAL(DbKi) , DIMENSION(1:6)  :: a6      !< 6 DOF acceleration vector (only used for coupled Rods) [-]
    REAL(DbKi) , DIMENSION(1:6)  :: F6net      !< total force and moment about end A (excluding inertial loads) that Rod may exert on whatever it's attached to [-]
    REAL(DbKi) , DIMENSION(1:6,1:6)  :: M6net      !< total mass matrix about end A of Rod and any attached Points [-]
    REAL(DbKi) , DIMENSION(1:3,1:3)  :: OrMat      !< DCM for body orientation [-]
    INTEGER(IntKi)  :: RodUnOut      !< unit number of rod output file [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: RodWrOutput      !< one row of output data for this rod [-]
  END TYPE MD_Rod
! =======================
! =========  MD_Line  =======
  TYPE, PUBLIC :: MD_Line
    INTEGER(IntKi)  :: IdNum      !< integer identifier of this Line [-]
    INTEGER(IntKi)  :: PropsIdNum      !< the IdNum of the associated line properties [-]
    INTEGER(IntKi) , DIMENSION(1:20)  :: OutFlagList      !< array specifying what line quantities should be output (1 vs 0) [-]
    INTEGER(IntKi)  :: CtrlChan      !< index of control channel that will drive line active tensioning (0 for none) [-]
    INTEGER(IntKi)  :: FairConnect      !< IdNum of Connection at fairlead [-]
    INTEGER(IntKi)  :: AnchConnect      !< IdNum of Connection at anchor [-]
    INTEGER(IntKi)  :: N      !< The number of elements in the line [-]
  END TYPE MD_Line
! =======================
CONTAINS
 SUBROUTINE MD_CopyInitInput( SrcInitInputData, DstInitInputData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_InitInputType), INTENT(IN) :: SrcInitInputData
   TYPE(MD_InitInputType), INTENT(INOUT) :: DstInitInputData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'MD_CopyInitInput'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstInitInputData%g = SrcInitInputData%g
    DstInitInputData%rhoW = SrcInitInputData%rhoW
    DstInitInputData%WtrDepth = SrcInitInputData%WtrDepth
    DstInitInputData%PtfmInit = SrcInitInputData%PtfmInit
    DstInitInputData%FileName = SrcInitInputData%FileName
    DstInitInputData%RootName = SrcInitInputData%RootName
    DstInitInputData%Echo = SrcInitInputData%Echo
    DstInitInputData%DTIC = SrcInitInputData%DTIC
    DstInitInputData%TMaxIC = SrcInitInputData%TMaxIC
    DstInitInputData%CdScaleIC = SrcInitInputData%CdScaleIC
    DstInitInputData%threshIC = SrcInitInputData%threshIC
IF (ALLOCATED(SrcInitInputData%WaveVel)) THEN
  i1_l = LBOUND(SrcInitInputData%WaveVel,1)
  i1_u = UBOUND(SrcInitInputData%WaveVel,1)
  i2_l = LBOUND(SrcInitInputData%WaveVel,2)
  i2_u = UBOUND(SrcInitInputData%WaveVel,2)
  i3_l = LBOUND(SrcInitInputData%WaveVel,3)
  i3_u = UBOUND(SrcInitInputData%WaveVel,3)
  IF (.NOT. ALLOCATED(DstInitInputData%WaveVel)) THEN 
    ALLOCATE(DstInitInputData%WaveVel(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WaveVel.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%WaveVel = SrcInitInputData%WaveVel
ENDIF
IF (ALLOCATED(SrcInitInputData%WaveAcc)) THEN
  i1_l = LBOUND(SrcInitInputData%WaveAcc,1)
  i1_u = UBOUND(SrcInitInputData%WaveAcc,1)
  i2_l = LBOUND(SrcInitInputData%WaveAcc,2)
  i2_u = UBOUND(SrcInitInputData%WaveAcc,2)
  i3_l = LBOUND(SrcInitInputData%WaveAcc,3)
  i3_u = UBOUND(SrcInitInputData%WaveAcc,3)
  IF (.NOT. ALLOCATED(DstInitInputData%WaveAcc)) THEN 
    ALLOCATE(DstInitInputData%WaveAcc(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WaveAcc.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%WaveAcc = SrcInitInputData%WaveAcc
ENDIF
IF (ALLOCATED(SrcInitInputData%WavePDyn)) THEN
  i1_l = LBOUND(SrcInitInputData%WavePDyn,1)
  i1_u = UBOUND(SrcInitInputData%WavePDyn,1)
  i2_l = LBOUND(SrcInitInputData%WavePDyn,2)
  i2_u = UBOUND(SrcInitInputData%WavePDyn,2)
  IF (.NOT. ALLOCATED(DstInitInputData%WavePDyn)) THEN 
    ALLOCATE(DstInitInputData%WavePDyn(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WavePDyn.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%WavePDyn = SrcInitInputData%WavePDyn
ENDIF
IF (ALLOCATED(SrcInitInputData%WaveElev)) THEN
  i1_l = LBOUND(SrcInitInputData%WaveElev,1)
  i1_u = UBOUND(SrcInitInputData%WaveElev,1)
  i2_l = LBOUND(SrcInitInputData%WaveElev,2)
  i2_u = UBOUND(SrcInitInputData%WaveElev,2)
  IF (.NOT. ALLOCATED(DstInitInputData%WaveElev)) THEN 
    ALLOCATE(DstInitInputData%WaveElev(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WaveElev.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%WaveElev = SrcInitInputData%WaveElev
ENDIF
IF (ALLOCATED(SrcInitInputData%WaveTime)) THEN
  i1_l = LBOUND(SrcInitInputData%WaveTime,1)
  i1_u = UBOUND(SrcInitInputData%WaveTime,1)
  IF (.NOT. ALLOCATED(DstInitInputData%WaveTime)) THEN 
    ALLOCATE(DstInitInputData%WaveTime(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstInitInputData%WaveTime.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstInitInputData%WaveTime = SrcInitInputData%WaveTime
ENDIF
 END SUBROUTINE MD_CopyInitInput

 SUBROUTINE MD_DestroyInitInput( InitInputData, ErrStat, ErrMsg )
  TYPE(MD_InitInputType), INTENT(INOUT) :: InitInputData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'MD_DestroyInitInput'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(InitInputData%WaveVel)) THEN
  DEALLOCATE(InitInputData%WaveVel)
ENDIF
IF (ALLOCATED(InitInputData%WaveAcc)) THEN
  DEALLOCATE(InitInputData%WaveAcc)
ENDIF
IF (ALLOCATED(InitInputData%WavePDyn)) THEN
  DEALLOCATE(InitInputData%WavePDyn)
ENDIF
IF (ALLOCATED(InitInputData%WaveElev)) THEN
  DEALLOCATE(InitInputData%WaveElev)
ENDIF
IF (ALLOCATED(InitInputData%WaveTime)) THEN
  DEALLOCATE(InitInputData%WaveTime)
ENDIF
 END SUBROUTINE MD_DestroyInitInput

 SUBROUTINE MD_PackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_InitInputType),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'MD_PackInitInput'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Re_BufSz   = Re_BufSz   + 1  ! g
      Re_BufSz   = Re_BufSz   + 1  ! rhoW
      Re_BufSz   = Re_BufSz   + 1  ! WtrDepth
      Re_BufSz   = Re_BufSz   + SIZE(InData%PtfmInit)  ! PtfmInit
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%FileName)  ! FileName
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%RootName)  ! RootName
      Int_BufSz  = Int_BufSz  + 1  ! Echo
      Db_BufSz   = Db_BufSz   + 1  ! DTIC
      Db_BufSz   = Db_BufSz   + 1  ! TMaxIC
      Re_BufSz   = Re_BufSz   + 1  ! CdScaleIC
      Re_BufSz   = Re_BufSz   + 1  ! threshIC
  Int_BufSz   = Int_BufSz   + 1     ! WaveVel allocated yes/no
  IF ( ALLOCATED(InData%WaveVel) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! WaveVel upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%WaveVel)  ! WaveVel
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! WaveAcc allocated yes/no
  IF ( ALLOCATED(InData%WaveAcc) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! WaveAcc upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%WaveAcc)  ! WaveAcc
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! WavePDyn allocated yes/no
  IF ( ALLOCATED(InData%WavePDyn) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! WavePDyn upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%WavePDyn)  ! WavePDyn
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! WaveElev allocated yes/no
  IF ( ALLOCATED(InData%WaveElev) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! WaveElev upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%WaveElev)  ! WaveElev
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! WaveTime allocated yes/no
  IF ( ALLOCATED(InData%WaveTime) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! WaveTime upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%WaveTime)  ! WaveTime
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    ReKiBuf(Re_Xferred) = InData%g
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%rhoW
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%WtrDepth
    Re_Xferred = Re_Xferred + 1
    DO i1 = LBOUND(InData%PtfmInit,1), UBOUND(InData%PtfmInit,1)
      ReKiBuf(Re_Xferred) = InData%PtfmInit(i1)
      Re_Xferred = Re_Xferred + 1
    END DO
    DO I = 1, LEN(InData%FileName)
      IntKiBuf(Int_Xferred) = ICHAR(InData%FileName(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    DO I = 1, LEN(InData%RootName)
      IntKiBuf(Int_Xferred) = ICHAR(InData%RootName(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    IntKiBuf(Int_Xferred) = TRANSFER(InData%Echo, IntKiBuf(1))
    Int_Xferred = Int_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%DTIC
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%TMaxIC
    Db_Xferred = Db_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%CdScaleIC
    Re_Xferred = Re_Xferred + 1
    ReKiBuf(Re_Xferred) = InData%threshIC
    Re_Xferred = Re_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%WaveVel) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveVel,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveVel,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveVel,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveVel,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveVel,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveVel,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%WaveVel,3), UBOUND(InData%WaveVel,3)
        DO i2 = LBOUND(InData%WaveVel,2), UBOUND(InData%WaveVel,2)
          DO i1 = LBOUND(InData%WaveVel,1), UBOUND(InData%WaveVel,1)
            ReKiBuf(Re_Xferred) = InData%WaveVel(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%WaveAcc) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveAcc,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveAcc,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveAcc,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveAcc,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveAcc,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveAcc,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%WaveAcc,3), UBOUND(InData%WaveAcc,3)
        DO i2 = LBOUND(InData%WaveAcc,2), UBOUND(InData%WaveAcc,2)
          DO i1 = LBOUND(InData%WaveAcc,1), UBOUND(InData%WaveAcc,1)
            ReKiBuf(Re_Xferred) = InData%WaveAcc(i1,i2,i3)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%WavePDyn) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WavePDyn,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WavePDyn,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WavePDyn,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WavePDyn,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%WavePDyn,2), UBOUND(InData%WavePDyn,2)
        DO i1 = LBOUND(InData%WavePDyn,1), UBOUND(InData%WavePDyn,1)
          ReKiBuf(Re_Xferred) = InData%WavePDyn(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%WaveElev) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveElev,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveElev,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveElev,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveElev,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%WaveElev,2), UBOUND(InData%WaveElev,2)
        DO i1 = LBOUND(InData%WaveElev,1), UBOUND(InData%WaveElev,1)
          ReKiBuf(Re_Xferred) = InData%WaveElev(i1,i2)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%WaveTime) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WaveTime,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WaveTime,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%WaveTime,1), UBOUND(InData%WaveTime,1)
        DbKiBuf(Db_Xferred) = InData%WaveTime(i1)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
 END SUBROUTINE MD_PackInitInput

 SUBROUTINE MD_UnPackInitInput( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_InitInputType), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'MD_UnPackInitInput'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%g = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%rhoW = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%WtrDepth = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    i1_l = LBOUND(OutData%PtfmInit,1)
    i1_u = UBOUND(OutData%PtfmInit,1)
    DO i1 = LBOUND(OutData%PtfmInit,1), UBOUND(OutData%PtfmInit,1)
      OutData%PtfmInit(i1) = ReKiBuf(Re_Xferred)
      Re_Xferred = Re_Xferred + 1
    END DO
    DO I = 1, LEN(OutData%FileName)
      OutData%FileName(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    DO I = 1, LEN(OutData%RootName)
      OutData%RootName(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    OutData%Echo = TRANSFER(IntKiBuf(Int_Xferred), OutData%Echo)
    Int_Xferred = Int_Xferred + 1
    OutData%DTIC = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%TMaxIC = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%CdScaleIC = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
    OutData%threshIC = ReKiBuf(Re_Xferred)
    Re_Xferred = Re_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WaveVel not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WaveVel)) DEALLOCATE(OutData%WaveVel)
    ALLOCATE(OutData%WaveVel(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveVel.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%WaveVel,3), UBOUND(OutData%WaveVel,3)
        DO i2 = LBOUND(OutData%WaveVel,2), UBOUND(OutData%WaveVel,2)
          DO i1 = LBOUND(OutData%WaveVel,1), UBOUND(OutData%WaveVel,1)
            OutData%WaveVel(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WaveAcc not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WaveAcc)) DEALLOCATE(OutData%WaveAcc)
    ALLOCATE(OutData%WaveAcc(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveAcc.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%WaveAcc,3), UBOUND(OutData%WaveAcc,3)
        DO i2 = LBOUND(OutData%WaveAcc,2), UBOUND(OutData%WaveAcc,2)
          DO i1 = LBOUND(OutData%WaveAcc,1), UBOUND(OutData%WaveAcc,1)
            OutData%WaveAcc(i1,i2,i3) = ReKiBuf(Re_Xferred)
            Re_Xferred = Re_Xferred + 1
          END DO
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WavePDyn not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WavePDyn)) DEALLOCATE(OutData%WavePDyn)
    ALLOCATE(OutData%WavePDyn(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WavePDyn.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%WavePDyn,2), UBOUND(OutData%WavePDyn,2)
        DO i1 = LBOUND(OutData%WavePDyn,1), UBOUND(OutData%WavePDyn,1)
          OutData%WavePDyn(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WaveElev not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WaveElev)) DEALLOCATE(OutData%WaveElev)
    ALLOCATE(OutData%WaveElev(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveElev.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%WaveElev,2), UBOUND(OutData%WaveElev,2)
        DO i1 = LBOUND(OutData%WaveElev,1), UBOUND(OutData%WaveElev,1)
          OutData%WaveElev(i1,i2) = ReKiBuf(Re_Xferred)
          Re_Xferred = Re_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WaveTime not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WaveTime)) DEALLOCATE(OutData%WaveTime)
    ALLOCATE(OutData%WaveTime(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WaveTime.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%WaveTime,1), UBOUND(OutData%WaveTime,1)
        OutData%WaveTime(i1) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
 END SUBROUTINE MD_UnPackInitInput

 SUBROUTINE MD_CopyLineProp( SrcLinePropData, DstLinePropData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_LineProp), INTENT(IN) :: SrcLinePropData
   TYPE(MD_LineProp), INTENT(INOUT) :: DstLinePropData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'MD_CopyLineProp'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstLinePropData%IdNum = SrcLinePropData%IdNum
    DstLinePropData%name = SrcLinePropData%name
    DstLinePropData%d = SrcLinePropData%d
    DstLinePropData%w = SrcLinePropData%w
    DstLinePropData%EA = SrcLinePropData%EA
    DstLinePropData%BA = SrcLinePropData%BA
    DstLinePropData%EI = SrcLinePropData%EI
    DstLinePropData%Can = SrcLinePropData%Can
    DstLinePropData%Cat = SrcLinePropData%Cat
    DstLinePropData%Cdn = SrcLinePropData%Cdn
    DstLinePropData%Cdt = SrcLinePropData%Cdt
    DstLinePropData%nEApoints = SrcLinePropData%nEApoints
    DstLinePropData%stiffXs = SrcLinePropData%stiffXs
    DstLinePropData%stiffYs = SrcLinePropData%stiffYs
    DstLinePropData%nBpoints = SrcLinePropData%nBpoints
    DstLinePropData%dampXs = SrcLinePropData%dampXs
    DstLinePropData%dampYs = SrcLinePropData%dampYs
    DstLinePropData%nEIpoints = SrcLinePropData%nEIpoints
    DstLinePropData%bstiffXs = SrcLinePropData%bstiffXs
    DstLinePropData%bstiffYs = SrcLinePropData%bstiffYs
 END SUBROUTINE MD_CopyLineProp

 SUBROUTINE MD_DestroyLineProp( LinePropData, ErrStat, ErrMsg )
  TYPE(MD_LineProp), INTENT(INOUT) :: LinePropData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'MD_DestroyLineProp'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE MD_DestroyLineProp

 SUBROUTINE MD_PackLineProp( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_LineProp),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'MD_PackLineProp'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! IdNum
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%name)  ! name
      Db_BufSz   = Db_BufSz   + 1  ! d
      Db_BufSz   = Db_BufSz   + 1  ! w
      Db_BufSz   = Db_BufSz   + 1  ! EA
      Db_BufSz   = Db_BufSz   + 1  ! BA
      Db_BufSz   = Db_BufSz   + 1  ! EI
      Db_BufSz   = Db_BufSz   + 1  ! Can
      Db_BufSz   = Db_BufSz   + 1  ! Cat
      Db_BufSz   = Db_BufSz   + 1  ! Cdn
      Db_BufSz   = Db_BufSz   + 1  ! Cdt
      Int_BufSz  = Int_BufSz  + 1  ! nEApoints
      Db_BufSz   = Db_BufSz   + SIZE(InData%stiffXs)  ! stiffXs
      Db_BufSz   = Db_BufSz   + SIZE(InData%stiffYs)  ! stiffYs
      Int_BufSz  = Int_BufSz  + 1  ! nBpoints
      Db_BufSz   = Db_BufSz   + SIZE(InData%dampXs)  ! dampXs
      Db_BufSz   = Db_BufSz   + SIZE(InData%dampYs)  ! dampYs
      Int_BufSz  = Int_BufSz  + 1  ! nEIpoints
      Db_BufSz   = Db_BufSz   + SIZE(InData%bstiffXs)  ! bstiffXs
      Db_BufSz   = Db_BufSz   + SIZE(InData%bstiffYs)  ! bstiffYs
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%IdNum
    Int_Xferred = Int_Xferred + 1
    DO I = 1, LEN(InData%name)
      IntKiBuf(Int_Xferred) = ICHAR(InData%name(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    DbKiBuf(Db_Xferred) = InData%d
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%w
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%EA
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%BA
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%EI
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%Can
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%Cat
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%Cdn
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%Cdt
    Db_Xferred = Db_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%nEApoints
    Int_Xferred = Int_Xferred + 1
    DO i1 = LBOUND(InData%stiffXs,1), UBOUND(InData%stiffXs,1)
      DbKiBuf(Db_Xferred) = InData%stiffXs(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%stiffYs,1), UBOUND(InData%stiffYs,1)
      DbKiBuf(Db_Xferred) = InData%stiffYs(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    IntKiBuf(Int_Xferred) = InData%nBpoints
    Int_Xferred = Int_Xferred + 1
    DO i1 = LBOUND(InData%dampXs,1), UBOUND(InData%dampXs,1)
      DbKiBuf(Db_Xferred) = InData%dampXs(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%dampYs,1), UBOUND(InData%dampYs,1)
      DbKiBuf(Db_Xferred) = InData%dampYs(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    IntKiBuf(Int_Xferred) = InData%nEIpoints
    Int_Xferred = Int_Xferred + 1
    DO i1 = LBOUND(InData%bstiffXs,1), UBOUND(InData%bstiffXs,1)
      DbKiBuf(Db_Xferred) = InData%bstiffXs(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%bstiffYs,1), UBOUND(InData%bstiffYs,1)
      DbKiBuf(Db_Xferred) = InData%bstiffYs(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
 END SUBROUTINE MD_PackLineProp

 SUBROUTINE MD_UnPackLineProp( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_LineProp), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'MD_UnPackLineProp'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%IdNum = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    DO I = 1, LEN(OutData%name)
      OutData%name(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    OutData%d = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%w = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%EA = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%BA = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%EI = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%Can = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%Cat = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%Cdn = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%Cdt = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%nEApoints = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    i1_l = LBOUND(OutData%stiffXs,1)
    i1_u = UBOUND(OutData%stiffXs,1)
    DO i1 = LBOUND(OutData%stiffXs,1), UBOUND(OutData%stiffXs,1)
      OutData%stiffXs(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%stiffYs,1)
    i1_u = UBOUND(OutData%stiffYs,1)
    DO i1 = LBOUND(OutData%stiffYs,1), UBOUND(OutData%stiffYs,1)
      OutData%stiffYs(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    OutData%nBpoints = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    i1_l = LBOUND(OutData%dampXs,1)
    i1_u = UBOUND(OutData%dampXs,1)
    DO i1 = LBOUND(OutData%dampXs,1), UBOUND(OutData%dampXs,1)
      OutData%dampXs(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%dampYs,1)
    i1_u = UBOUND(OutData%dampYs,1)
    DO i1 = LBOUND(OutData%dampYs,1), UBOUND(OutData%dampYs,1)
      OutData%dampYs(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    OutData%nEIpoints = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    i1_l = LBOUND(OutData%bstiffXs,1)
    i1_u = UBOUND(OutData%bstiffXs,1)
    DO i1 = LBOUND(OutData%bstiffXs,1), UBOUND(OutData%bstiffXs,1)
      OutData%bstiffXs(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%bstiffYs,1)
    i1_u = UBOUND(OutData%bstiffYs,1)
    DO i1 = LBOUND(OutData%bstiffYs,1), UBOUND(OutData%bstiffYs,1)
      OutData%bstiffYs(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
 END SUBROUTINE MD_UnPackLineProp

 SUBROUTINE MD_CopyRodProp( SrcRodPropData, DstRodPropData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_RodProp), INTENT(IN) :: SrcRodPropData
   TYPE(MD_RodProp), INTENT(INOUT) :: DstRodPropData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'MD_CopyRodProp'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstRodPropData%IdNum = SrcRodPropData%IdNum
    DstRodPropData%name = SrcRodPropData%name
    DstRodPropData%d = SrcRodPropData%d
    DstRodPropData%w = SrcRodPropData%w
    DstRodPropData%Can = SrcRodPropData%Can
    DstRodPropData%Cat = SrcRodPropData%Cat
    DstRodPropData%Cdn = SrcRodPropData%Cdn
    DstRodPropData%Cdt = SrcRodPropData%Cdt
    DstRodPropData%CdEnd = SrcRodPropData%CdEnd
    DstRodPropData%CaEnd = SrcRodPropData%CaEnd
 END SUBROUTINE MD_CopyRodProp

 SUBROUTINE MD_DestroyRodProp( RodPropData, ErrStat, ErrMsg )
  TYPE(MD_RodProp), INTENT(INOUT) :: RodPropData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'MD_DestroyRodProp'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE MD_DestroyRodProp

 SUBROUTINE MD_PackRodProp( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_RodProp),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'MD_PackRodProp'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! IdNum
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%name)  ! name
      Db_BufSz   = Db_BufSz   + 1  ! d
      Db_BufSz   = Db_BufSz   + 1  ! w
      Db_BufSz   = Db_BufSz   + 1  ! Can
      Db_BufSz   = Db_BufSz   + 1  ! Cat
      Db_BufSz   = Db_BufSz   + 1  ! Cdn
      Db_BufSz   = Db_BufSz   + 1  ! Cdt
      Db_BufSz   = Db_BufSz   + 1  ! CdEnd
      Db_BufSz   = Db_BufSz   + 1  ! CaEnd
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%IdNum
    Int_Xferred = Int_Xferred + 1
    DO I = 1, LEN(InData%name)
      IntKiBuf(Int_Xferred) = ICHAR(InData%name(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    DbKiBuf(Db_Xferred) = InData%d
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%w
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%Can
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%Cat
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%Cdn
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%Cdt
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%CdEnd
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%CaEnd
    Db_Xferred = Db_Xferred + 1
 END SUBROUTINE MD_PackRodProp

 SUBROUTINE MD_UnPackRodProp( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_RodProp), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'MD_UnPackRodProp'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%IdNum = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    DO I = 1, LEN(OutData%name)
      OutData%name(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    OutData%d = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%w = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%Can = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%Cat = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%Cdn = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%Cdt = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%CdEnd = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%CaEnd = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
 END SUBROUTINE MD_UnPackRodProp

 SUBROUTINE MD_CopyBody( SrcBodyData, DstBodyData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_Body), INTENT(IN) :: SrcBodyData
   TYPE(MD_Body), INTENT(INOUT) :: DstBodyData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'MD_CopyBody'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstBodyData%IdNum = SrcBodyData%IdNum
    DstBodyData%typeNum = SrcBodyData%typeNum
    DstBodyData%AttachedC = SrcBodyData%AttachedC
    DstBodyData%AttachedR = SrcBodyData%AttachedR
    DstBodyData%nAttachedC = SrcBodyData%nAttachedC
    DstBodyData%nAttachedR = SrcBodyData%nAttachedR
    DstBodyData%rConnectRel = SrcBodyData%rConnectRel
    DstBodyData%r6RodRel = SrcBodyData%r6RodRel
    DstBodyData%bodyM = SrcBodyData%bodyM
    DstBodyData%bodyV = SrcBodyData%bodyV
    DstBodyData%bodyI = SrcBodyData%bodyI
    DstBodyData%bodyCdA = SrcBodyData%bodyCdA
    DstBodyData%bodyCa = SrcBodyData%bodyCa
    DstBodyData%time = SrcBodyData%time
    DstBodyData%r6 = SrcBodyData%r6
    DstBodyData%v6 = SrcBodyData%v6
    DstBodyData%a6 = SrcBodyData%a6
    DstBodyData%U = SrcBodyData%U
    DstBodyData%Ud = SrcBodyData%Ud
    DstBodyData%zeta = SrcBodyData%zeta
    DstBodyData%F6net = SrcBodyData%F6net
    DstBodyData%M6net = SrcBodyData%M6net
    DstBodyData%M = SrcBodyData%M
    DstBodyData%M0 = SrcBodyData%M0
    DstBodyData%OrMat = SrcBodyData%OrMat
    DstBodyData%rCG = SrcBodyData%rCG
 END SUBROUTINE MD_CopyBody

 SUBROUTINE MD_DestroyBody( BodyData, ErrStat, ErrMsg )
  TYPE(MD_Body), INTENT(INOUT) :: BodyData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'MD_DestroyBody'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE MD_DestroyBody

 SUBROUTINE MD_PackBody( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_Body),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'MD_PackBody'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! IdNum
      Int_BufSz  = Int_BufSz  + 1  ! typeNum
      Int_BufSz  = Int_BufSz  + SIZE(InData%AttachedC)  ! AttachedC
      Int_BufSz  = Int_BufSz  + SIZE(InData%AttachedR)  ! AttachedR
      Int_BufSz  = Int_BufSz  + 1  ! nAttachedC
      Int_BufSz  = Int_BufSz  + 1  ! nAttachedR
      Db_BufSz   = Db_BufSz   + SIZE(InData%rConnectRel)  ! rConnectRel
      Db_BufSz   = Db_BufSz   + SIZE(InData%r6RodRel)  ! r6RodRel
      Db_BufSz   = Db_BufSz   + 1  ! bodyM
      Db_BufSz   = Db_BufSz   + 1  ! bodyV
      Db_BufSz   = Db_BufSz   + SIZE(InData%bodyI)  ! bodyI
      Db_BufSz   = Db_BufSz   + SIZE(InData%bodyCdA)  ! bodyCdA
      Db_BufSz   = Db_BufSz   + SIZE(InData%bodyCa)  ! bodyCa
      Db_BufSz   = Db_BufSz   + 1  ! time
      Db_BufSz   = Db_BufSz   + SIZE(InData%r6)  ! r6
      Db_BufSz   = Db_BufSz   + SIZE(InData%v6)  ! v6
      Db_BufSz   = Db_BufSz   + SIZE(InData%a6)  ! a6
      Db_BufSz   = Db_BufSz   + SIZE(InData%U)  ! U
      Db_BufSz   = Db_BufSz   + SIZE(InData%Ud)  ! Ud
      Db_BufSz   = Db_BufSz   + 1  ! zeta
      Db_BufSz   = Db_BufSz   + SIZE(InData%F6net)  ! F6net
      Db_BufSz   = Db_BufSz   + SIZE(InData%M6net)  ! M6net
      Db_BufSz   = Db_BufSz   + SIZE(InData%M)  ! M
      Db_BufSz   = Db_BufSz   + SIZE(InData%M0)  ! M0
      Db_BufSz   = Db_BufSz   + SIZE(InData%OrMat)  ! OrMat
      Db_BufSz   = Db_BufSz   + SIZE(InData%rCG)  ! rCG
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%IdNum
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%typeNum
    Int_Xferred = Int_Xferred + 1
    DO i1 = LBOUND(InData%AttachedC,1), UBOUND(InData%AttachedC,1)
      IntKiBuf(Int_Xferred) = InData%AttachedC(i1)
      Int_Xferred = Int_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%AttachedR,1), UBOUND(InData%AttachedR,1)
      IntKiBuf(Int_Xferred) = InData%AttachedR(i1)
      Int_Xferred = Int_Xferred + 1
    END DO
    IntKiBuf(Int_Xferred) = InData%nAttachedC
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%nAttachedR
    Int_Xferred = Int_Xferred + 1
    DO i2 = LBOUND(InData%rConnectRel,2), UBOUND(InData%rConnectRel,2)
      DO i1 = LBOUND(InData%rConnectRel,1), UBOUND(InData%rConnectRel,1)
        DbKiBuf(Db_Xferred) = InData%rConnectRel(i1,i2)
        Db_Xferred = Db_Xferred + 1
      END DO
    END DO
    DO i2 = LBOUND(InData%r6RodRel,2), UBOUND(InData%r6RodRel,2)
      DO i1 = LBOUND(InData%r6RodRel,1), UBOUND(InData%r6RodRel,1)
        DbKiBuf(Db_Xferred) = InData%r6RodRel(i1,i2)
        Db_Xferred = Db_Xferred + 1
      END DO
    END DO
    DbKiBuf(Db_Xferred) = InData%bodyM
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%bodyV
    Db_Xferred = Db_Xferred + 1
    DO i1 = LBOUND(InData%bodyI,1), UBOUND(InData%bodyI,1)
      DbKiBuf(Db_Xferred) = InData%bodyI(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%bodyCdA,1), UBOUND(InData%bodyCdA,1)
      DbKiBuf(Db_Xferred) = InData%bodyCdA(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%bodyCa,1), UBOUND(InData%bodyCa,1)
      DbKiBuf(Db_Xferred) = InData%bodyCa(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    DbKiBuf(Db_Xferred) = InData%time
    Db_Xferred = Db_Xferred + 1
    DO i1 = LBOUND(InData%r6,1), UBOUND(InData%r6,1)
      DbKiBuf(Db_Xferred) = InData%r6(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%v6,1), UBOUND(InData%v6,1)
      DbKiBuf(Db_Xferred) = InData%v6(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%a6,1), UBOUND(InData%a6,1)
      DbKiBuf(Db_Xferred) = InData%a6(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%U,1), UBOUND(InData%U,1)
      DbKiBuf(Db_Xferred) = InData%U(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%Ud,1), UBOUND(InData%Ud,1)
      DbKiBuf(Db_Xferred) = InData%Ud(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    DbKiBuf(Db_Xferred) = InData%zeta
    Db_Xferred = Db_Xferred + 1
    DO i1 = LBOUND(InData%F6net,1), UBOUND(InData%F6net,1)
      DbKiBuf(Db_Xferred) = InData%F6net(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    DO i2 = LBOUND(InData%M6net,2), UBOUND(InData%M6net,2)
      DO i1 = LBOUND(InData%M6net,1), UBOUND(InData%M6net,1)
        DbKiBuf(Db_Xferred) = InData%M6net(i1,i2)
        Db_Xferred = Db_Xferred + 1
      END DO
    END DO
    DO i2 = LBOUND(InData%M,2), UBOUND(InData%M,2)
      DO i1 = LBOUND(InData%M,1), UBOUND(InData%M,1)
        DbKiBuf(Db_Xferred) = InData%M(i1,i2)
        Db_Xferred = Db_Xferred + 1
      END DO
    END DO
    DO i2 = LBOUND(InData%M0,2), UBOUND(InData%M0,2)
      DO i1 = LBOUND(InData%M0,1), UBOUND(InData%M0,1)
        DbKiBuf(Db_Xferred) = InData%M0(i1,i2)
        Db_Xferred = Db_Xferred + 1
      END DO
    END DO
    DO i2 = LBOUND(InData%OrMat,2), UBOUND(InData%OrMat,2)
      DO i1 = LBOUND(InData%OrMat,1), UBOUND(InData%OrMat,1)
        DbKiBuf(Db_Xferred) = InData%OrMat(i1,i2)
        Db_Xferred = Db_Xferred + 1
      END DO
    END DO
    DO i1 = LBOUND(InData%rCG,1), UBOUND(InData%rCG,1)
      DbKiBuf(Db_Xferred) = InData%rCG(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
 END SUBROUTINE MD_PackBody

 SUBROUTINE MD_UnPackBody( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_Body), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'MD_UnPackBody'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%IdNum = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%typeNum = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    i1_l = LBOUND(OutData%AttachedC,1)
    i1_u = UBOUND(OutData%AttachedC,1)
    DO i1 = LBOUND(OutData%AttachedC,1), UBOUND(OutData%AttachedC,1)
      OutData%AttachedC(i1) = IntKiBuf(Int_Xferred)
      Int_Xferred = Int_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%AttachedR,1)
    i1_u = UBOUND(OutData%AttachedR,1)
    DO i1 = LBOUND(OutData%AttachedR,1), UBOUND(OutData%AttachedR,1)
      OutData%AttachedR(i1) = IntKiBuf(Int_Xferred)
      Int_Xferred = Int_Xferred + 1
    END DO
    OutData%nAttachedC = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%nAttachedR = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    i1_l = LBOUND(OutData%rConnectRel,1)
    i1_u = UBOUND(OutData%rConnectRel,1)
    i2_l = LBOUND(OutData%rConnectRel,2)
    i2_u = UBOUND(OutData%rConnectRel,2)
    DO i2 = LBOUND(OutData%rConnectRel,2), UBOUND(OutData%rConnectRel,2)
      DO i1 = LBOUND(OutData%rConnectRel,1), UBOUND(OutData%rConnectRel,1)
        OutData%rConnectRel(i1,i2) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
    END DO
    i1_l = LBOUND(OutData%r6RodRel,1)
    i1_u = UBOUND(OutData%r6RodRel,1)
    i2_l = LBOUND(OutData%r6RodRel,2)
    i2_u = UBOUND(OutData%r6RodRel,2)
    DO i2 = LBOUND(OutData%r6RodRel,2), UBOUND(OutData%r6RodRel,2)
      DO i1 = LBOUND(OutData%r6RodRel,1), UBOUND(OutData%r6RodRel,1)
        OutData%r6RodRel(i1,i2) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
    END DO
    OutData%bodyM = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%bodyV = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    i1_l = LBOUND(OutData%bodyI,1)
    i1_u = UBOUND(OutData%bodyI,1)
    DO i1 = LBOUND(OutData%bodyI,1), UBOUND(OutData%bodyI,1)
      OutData%bodyI(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%bodyCdA,1)
    i1_u = UBOUND(OutData%bodyCdA,1)
    DO i1 = LBOUND(OutData%bodyCdA,1), UBOUND(OutData%bodyCdA,1)
      OutData%bodyCdA(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%bodyCa,1)
    i1_u = UBOUND(OutData%bodyCa,1)
    DO i1 = LBOUND(OutData%bodyCa,1), UBOUND(OutData%bodyCa,1)
      OutData%bodyCa(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    OutData%time = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    i1_l = LBOUND(OutData%r6,1)
    i1_u = UBOUND(OutData%r6,1)
    DO i1 = LBOUND(OutData%r6,1), UBOUND(OutData%r6,1)
      OutData%r6(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%v6,1)
    i1_u = UBOUND(OutData%v6,1)
    DO i1 = LBOUND(OutData%v6,1), UBOUND(OutData%v6,1)
      OutData%v6(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%a6,1)
    i1_u = UBOUND(OutData%a6,1)
    DO i1 = LBOUND(OutData%a6,1), UBOUND(OutData%a6,1)
      OutData%a6(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%U,1)
    i1_u = UBOUND(OutData%U,1)
    DO i1 = LBOUND(OutData%U,1), UBOUND(OutData%U,1)
      OutData%U(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%Ud,1)
    i1_u = UBOUND(OutData%Ud,1)
    DO i1 = LBOUND(OutData%Ud,1), UBOUND(OutData%Ud,1)
      OutData%Ud(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    OutData%zeta = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    i1_l = LBOUND(OutData%F6net,1)
    i1_u = UBOUND(OutData%F6net,1)
    DO i1 = LBOUND(OutData%F6net,1), UBOUND(OutData%F6net,1)
      OutData%F6net(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%M6net,1)
    i1_u = UBOUND(OutData%M6net,1)
    i2_l = LBOUND(OutData%M6net,2)
    i2_u = UBOUND(OutData%M6net,2)
    DO i2 = LBOUND(OutData%M6net,2), UBOUND(OutData%M6net,2)
      DO i1 = LBOUND(OutData%M6net,1), UBOUND(OutData%M6net,1)
        OutData%M6net(i1,i2) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
    END DO
    i1_l = LBOUND(OutData%M,1)
    i1_u = UBOUND(OutData%M,1)
    i2_l = LBOUND(OutData%M,2)
    i2_u = UBOUND(OutData%M,2)
    DO i2 = LBOUND(OutData%M,2), UBOUND(OutData%M,2)
      DO i1 = LBOUND(OutData%M,1), UBOUND(OutData%M,1)
        OutData%M(i1,i2) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
    END DO
    i1_l = LBOUND(OutData%M0,1)
    i1_u = UBOUND(OutData%M0,1)
    i2_l = LBOUND(OutData%M0,2)
    i2_u = UBOUND(OutData%M0,2)
    DO i2 = LBOUND(OutData%M0,2), UBOUND(OutData%M0,2)
      DO i1 = LBOUND(OutData%M0,1), UBOUND(OutData%M0,1)
        OutData%M0(i1,i2) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
    END DO
    i1_l = LBOUND(OutData%OrMat,1)
    i1_u = UBOUND(OutData%OrMat,1)
    i2_l = LBOUND(OutData%OrMat,2)
    i2_u = UBOUND(OutData%OrMat,2)
    DO i2 = LBOUND(OutData%OrMat,2), UBOUND(OutData%OrMat,2)
      DO i1 = LBOUND(OutData%OrMat,1), UBOUND(OutData%OrMat,1)
        OutData%OrMat(i1,i2) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
    END DO
    i1_l = LBOUND(OutData%rCG,1)
    i1_u = UBOUND(OutData%rCG,1)
    DO i1 = LBOUND(OutData%rCG,1), UBOUND(OutData%rCG,1)
      OutData%rCG(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
 END SUBROUTINE MD_UnPackBody

 SUBROUTINE MD_CopyConnect( SrcConnectData, DstConnectData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_Connect), INTENT(IN) :: SrcConnectData
   TYPE(MD_Connect), INTENT(INOUT) :: DstConnectData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'MD_CopyConnect'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstConnectData%IdNum = SrcConnectData%IdNum
    DstConnectData%type = SrcConnectData%type
    DstConnectData%typeNum = SrcConnectData%typeNum
    DstConnectData%Attached = SrcConnectData%Attached
    DstConnectData%Top = SrcConnectData%Top
    DstConnectData%nAttached = SrcConnectData%nAttached
    DstConnectData%conX = SrcConnectData%conX
    DstConnectData%conY = SrcConnectData%conY
    DstConnectData%conZ = SrcConnectData%conZ
    DstConnectData%conM = SrcConnectData%conM
    DstConnectData%conV = SrcConnectData%conV
    DstConnectData%conFX = SrcConnectData%conFX
    DstConnectData%conFY = SrcConnectData%conFY
    DstConnectData%conFZ = SrcConnectData%conFZ
    DstConnectData%conCa = SrcConnectData%conCa
    DstConnectData%conCdA = SrcConnectData%conCdA
    DstConnectData%time = SrcConnectData%time
    DstConnectData%r = SrcConnectData%r
    DstConnectData%rd = SrcConnectData%rd
    DstConnectData%a = SrcConnectData%a
    DstConnectData%U = SrcConnectData%U
    DstConnectData%Ud = SrcConnectData%Ud
    DstConnectData%zeta = SrcConnectData%zeta
IF (ALLOCATED(SrcConnectData%PDyn)) THEN
  i1_l = LBOUND(SrcConnectData%PDyn,1)
  i1_u = UBOUND(SrcConnectData%PDyn,1)
  IF (.NOT. ALLOCATED(DstConnectData%PDyn)) THEN 
    ALLOCATE(DstConnectData%PDyn(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstConnectData%PDyn.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstConnectData%PDyn = SrcConnectData%PDyn
ENDIF
    DstConnectData%Fnet = SrcConnectData%Fnet
    DstConnectData%M = SrcConnectData%M
 END SUBROUTINE MD_CopyConnect

 SUBROUTINE MD_DestroyConnect( ConnectData, ErrStat, ErrMsg )
  TYPE(MD_Connect), INTENT(INOUT) :: ConnectData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'MD_DestroyConnect'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(ConnectData%PDyn)) THEN
  DEALLOCATE(ConnectData%PDyn)
ENDIF
 END SUBROUTINE MD_DestroyConnect

 SUBROUTINE MD_PackConnect( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_Connect),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'MD_PackConnect'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! IdNum
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%type)  ! type
      Int_BufSz  = Int_BufSz  + 1  ! typeNum
      Int_BufSz  = Int_BufSz  + SIZE(InData%Attached)  ! Attached
      Int_BufSz  = Int_BufSz  + SIZE(InData%Top)  ! Top
      Int_BufSz  = Int_BufSz  + 1  ! nAttached
      Db_BufSz   = Db_BufSz   + 1  ! conX
      Db_BufSz   = Db_BufSz   + 1  ! conY
      Db_BufSz   = Db_BufSz   + 1  ! conZ
      Db_BufSz   = Db_BufSz   + 1  ! conM
      Db_BufSz   = Db_BufSz   + 1  ! conV
      Db_BufSz   = Db_BufSz   + 1  ! conFX
      Db_BufSz   = Db_BufSz   + 1  ! conFY
      Db_BufSz   = Db_BufSz   + 1  ! conFZ
      Db_BufSz   = Db_BufSz   + 1  ! conCa
      Db_BufSz   = Db_BufSz   + 1  ! conCdA
      Db_BufSz   = Db_BufSz   + 1  ! time
      Db_BufSz   = Db_BufSz   + SIZE(InData%r)  ! r
      Db_BufSz   = Db_BufSz   + SIZE(InData%rd)  ! rd
      Db_BufSz   = Db_BufSz   + SIZE(InData%a)  ! a
      Db_BufSz   = Db_BufSz   + SIZE(InData%U)  ! U
      Db_BufSz   = Db_BufSz   + SIZE(InData%Ud)  ! Ud
      Db_BufSz   = Db_BufSz   + 1  ! zeta
  Int_BufSz   = Int_BufSz   + 1     ! PDyn allocated yes/no
  IF ( ALLOCATED(InData%PDyn) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! PDyn upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%PDyn)  ! PDyn
  END IF
      Db_BufSz   = Db_BufSz   + SIZE(InData%Fnet)  ! Fnet
      Db_BufSz   = Db_BufSz   + SIZE(InData%M)  ! M
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%IdNum
    Int_Xferred = Int_Xferred + 1
    DO I = 1, LEN(InData%type)
      IntKiBuf(Int_Xferred) = ICHAR(InData%type(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    IntKiBuf(Int_Xferred) = InData%typeNum
    Int_Xferred = Int_Xferred + 1
    DO i1 = LBOUND(InData%Attached,1), UBOUND(InData%Attached,1)
      IntKiBuf(Int_Xferred) = InData%Attached(i1)
      Int_Xferred = Int_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%Top,1), UBOUND(InData%Top,1)
      IntKiBuf(Int_Xferred) = InData%Top(i1)
      Int_Xferred = Int_Xferred + 1
    END DO
    IntKiBuf(Int_Xferred) = InData%nAttached
    Int_Xferred = Int_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%conX
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%conY
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%conZ
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%conM
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%conV
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%conFX
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%conFY
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%conFZ
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%conCa
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%conCdA
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%time
    Db_Xferred = Db_Xferred + 1
    DO i1 = LBOUND(InData%r,1), UBOUND(InData%r,1)
      DbKiBuf(Db_Xferred) = InData%r(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%rd,1), UBOUND(InData%rd,1)
      DbKiBuf(Db_Xferred) = InData%rd(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%a,1), UBOUND(InData%a,1)
      DbKiBuf(Db_Xferred) = InData%a(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%U,1), UBOUND(InData%U,1)
      DbKiBuf(Db_Xferred) = InData%U(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%Ud,1), UBOUND(InData%Ud,1)
      DbKiBuf(Db_Xferred) = InData%Ud(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    DbKiBuf(Db_Xferred) = InData%zeta
    Db_Xferred = Db_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%PDyn) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%PDyn,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%PDyn,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%PDyn,1), UBOUND(InData%PDyn,1)
        DbKiBuf(Db_Xferred) = InData%PDyn(i1)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
    DO i1 = LBOUND(InData%Fnet,1), UBOUND(InData%Fnet,1)
      DbKiBuf(Db_Xferred) = InData%Fnet(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    DO i2 = LBOUND(InData%M,2), UBOUND(InData%M,2)
      DO i1 = LBOUND(InData%M,1), UBOUND(InData%M,1)
        DbKiBuf(Db_Xferred) = InData%M(i1,i2)
        Db_Xferred = Db_Xferred + 1
      END DO
    END DO
 END SUBROUTINE MD_PackConnect

 SUBROUTINE MD_UnPackConnect( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_Connect), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'MD_UnPackConnect'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%IdNum = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    DO I = 1, LEN(OutData%type)
      OutData%type(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    OutData%typeNum = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    i1_l = LBOUND(OutData%Attached,1)
    i1_u = UBOUND(OutData%Attached,1)
    DO i1 = LBOUND(OutData%Attached,1), UBOUND(OutData%Attached,1)
      OutData%Attached(i1) = IntKiBuf(Int_Xferred)
      Int_Xferred = Int_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%Top,1)
    i1_u = UBOUND(OutData%Top,1)
    DO i1 = LBOUND(OutData%Top,1), UBOUND(OutData%Top,1)
      OutData%Top(i1) = IntKiBuf(Int_Xferred)
      Int_Xferred = Int_Xferred + 1
    END DO
    OutData%nAttached = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%conX = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%conY = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%conZ = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%conM = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%conV = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%conFX = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%conFY = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%conFZ = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%conCa = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%conCdA = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%time = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    i1_l = LBOUND(OutData%r,1)
    i1_u = UBOUND(OutData%r,1)
    DO i1 = LBOUND(OutData%r,1), UBOUND(OutData%r,1)
      OutData%r(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%rd,1)
    i1_u = UBOUND(OutData%rd,1)
    DO i1 = LBOUND(OutData%rd,1), UBOUND(OutData%rd,1)
      OutData%rd(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%a,1)
    i1_u = UBOUND(OutData%a,1)
    DO i1 = LBOUND(OutData%a,1), UBOUND(OutData%a,1)
      OutData%a(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%U,1)
    i1_u = UBOUND(OutData%U,1)
    DO i1 = LBOUND(OutData%U,1), UBOUND(OutData%U,1)
      OutData%U(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%Ud,1)
    i1_u = UBOUND(OutData%Ud,1)
    DO i1 = LBOUND(OutData%Ud,1), UBOUND(OutData%Ud,1)
      OutData%Ud(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    OutData%zeta = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! PDyn not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%PDyn)) DEALLOCATE(OutData%PDyn)
    ALLOCATE(OutData%PDyn(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%PDyn.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%PDyn,1), UBOUND(OutData%PDyn,1)
        OutData%PDyn(i1) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
    i1_l = LBOUND(OutData%Fnet,1)
    i1_u = UBOUND(OutData%Fnet,1)
    DO i1 = LBOUND(OutData%Fnet,1), UBOUND(OutData%Fnet,1)
      OutData%Fnet(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%M,1)
    i1_u = UBOUND(OutData%M,1)
    i2_l = LBOUND(OutData%M,2)
    i2_u = UBOUND(OutData%M,2)
    DO i2 = LBOUND(OutData%M,2), UBOUND(OutData%M,2)
      DO i1 = LBOUND(OutData%M,1), UBOUND(OutData%M,1)
        OutData%M(i1,i2) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
    END DO
 END SUBROUTINE MD_UnPackConnect

 SUBROUTINE MD_CopyRod( SrcRodData, DstRodData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_Rod), INTENT(IN) :: SrcRodData
   TYPE(MD_Rod), INTENT(INOUT) :: DstRodData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
   INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'MD_CopyRod'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstRodData%IdNum = SrcRodData%IdNum
    DstRodData%type = SrcRodData%type
    DstRodData%PropsIdNum = SrcRodData%PropsIdNum
    DstRodData%typeNum = SrcRodData%typeNum
    DstRodData%AttachedA = SrcRodData%AttachedA
    DstRodData%AttachedB = SrcRodData%AttachedB
    DstRodData%TopA = SrcRodData%TopA
    DstRodData%TopB = SrcRodData%TopB
    DstRodData%nAttachedA = SrcRodData%nAttachedA
    DstRodData%nAttachedB = SrcRodData%nAttachedB
    DstRodData%OutFlagList = SrcRodData%OutFlagList
    DstRodData%N = SrcRodData%N
    DstRodData%endTypeA = SrcRodData%endTypeA
    DstRodData%endTypeB = SrcRodData%endTypeB
    DstRodData%UnstrLen = SrcRodData%UnstrLen
    DstRodData%mass = SrcRodData%mass
    DstRodData%rho = SrcRodData%rho
    DstRodData%d = SrcRodData%d
    DstRodData%Can = SrcRodData%Can
    DstRodData%Cat = SrcRodData%Cat
    DstRodData%Cdn = SrcRodData%Cdn
    DstRodData%Cdt = SrcRodData%Cdt
    DstRodData%CdEnd = SrcRodData%CdEnd
    DstRodData%CaEnd = SrcRodData%CaEnd
    DstRodData%time = SrcRodData%time
    DstRodData%roll = SrcRodData%roll
    DstRodData%pitch = SrcRodData%pitch
IF (ALLOCATED(SrcRodData%r)) THEN
  i1_l = LBOUND(SrcRodData%r,1)
  i1_u = UBOUND(SrcRodData%r,1)
  i2_l = LBOUND(SrcRodData%r,2)
  i2_u = UBOUND(SrcRodData%r,2)
  IF (.NOT. ALLOCATED(DstRodData%r)) THEN 
    ALLOCATE(DstRodData%r(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%r.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%r = SrcRodData%r
ENDIF
IF (ALLOCATED(SrcRodData%rd)) THEN
  i1_l = LBOUND(SrcRodData%rd,1)
  i1_u = UBOUND(SrcRodData%rd,1)
  i2_l = LBOUND(SrcRodData%rd,2)
  i2_u = UBOUND(SrcRodData%rd,2)
  IF (.NOT. ALLOCATED(DstRodData%rd)) THEN 
    ALLOCATE(DstRodData%rd(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%rd.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%rd = SrcRodData%rd
ENDIF
    DstRodData%q = SrcRodData%q
IF (ALLOCATED(SrcRodData%l)) THEN
  i1_l = LBOUND(SrcRodData%l,1)
  i1_u = UBOUND(SrcRodData%l,1)
  IF (.NOT. ALLOCATED(DstRodData%l)) THEN 
    ALLOCATE(DstRodData%l(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%l.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%l = SrcRodData%l
ENDIF
IF (ALLOCATED(SrcRodData%V)) THEN
  i1_l = LBOUND(SrcRodData%V,1)
  i1_u = UBOUND(SrcRodData%V,1)
  IF (.NOT. ALLOCATED(DstRodData%V)) THEN 
    ALLOCATE(DstRodData%V(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%V.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%V = SrcRodData%V
ENDIF
IF (ALLOCATED(SrcRodData%U)) THEN
  i1_l = LBOUND(SrcRodData%U,1)
  i1_u = UBOUND(SrcRodData%U,1)
  i2_l = LBOUND(SrcRodData%U,2)
  i2_u = UBOUND(SrcRodData%U,2)
  IF (.NOT. ALLOCATED(DstRodData%U)) THEN 
    ALLOCATE(DstRodData%U(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%U.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%U = SrcRodData%U
ENDIF
IF (ALLOCATED(SrcRodData%Ud)) THEN
  i1_l = LBOUND(SrcRodData%Ud,1)
  i1_u = UBOUND(SrcRodData%Ud,1)
  i2_l = LBOUND(SrcRodData%Ud,2)
  i2_u = UBOUND(SrcRodData%Ud,2)
  IF (.NOT. ALLOCATED(DstRodData%Ud)) THEN 
    ALLOCATE(DstRodData%Ud(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%Ud.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%Ud = SrcRodData%Ud
ENDIF
IF (ALLOCATED(SrcRodData%zeta)) THEN
  i1_l = LBOUND(SrcRodData%zeta,1)
  i1_u = UBOUND(SrcRodData%zeta,1)
  IF (.NOT. ALLOCATED(DstRodData%zeta)) THEN 
    ALLOCATE(DstRodData%zeta(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%zeta.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%zeta = SrcRodData%zeta
ENDIF
IF (ALLOCATED(SrcRodData%PDyn)) THEN
  i1_l = LBOUND(SrcRodData%PDyn,1)
  i1_u = UBOUND(SrcRodData%PDyn,1)
  IF (.NOT. ALLOCATED(DstRodData%PDyn)) THEN 
    ALLOCATE(DstRodData%PDyn(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%PDyn.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%PDyn = SrcRodData%PDyn
ENDIF
IF (ALLOCATED(SrcRodData%W)) THEN
  i1_l = LBOUND(SrcRodData%W,1)
  i1_u = UBOUND(SrcRodData%W,1)
  i2_l = LBOUND(SrcRodData%W,2)
  i2_u = UBOUND(SrcRodData%W,2)
  IF (.NOT. ALLOCATED(DstRodData%W)) THEN 
    ALLOCATE(DstRodData%W(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%W.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%W = SrcRodData%W
ENDIF
IF (ALLOCATED(SrcRodData%Bo)) THEN
  i1_l = LBOUND(SrcRodData%Bo,1)
  i1_u = UBOUND(SrcRodData%Bo,1)
  i2_l = LBOUND(SrcRodData%Bo,2)
  i2_u = UBOUND(SrcRodData%Bo,2)
  IF (.NOT. ALLOCATED(DstRodData%Bo)) THEN 
    ALLOCATE(DstRodData%Bo(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%Bo.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%Bo = SrcRodData%Bo
ENDIF
IF (ALLOCATED(SrcRodData%Pd)) THEN
  i1_l = LBOUND(SrcRodData%Pd,1)
  i1_u = UBOUND(SrcRodData%Pd,1)
  i2_l = LBOUND(SrcRodData%Pd,2)
  i2_u = UBOUND(SrcRodData%Pd,2)
  IF (.NOT. ALLOCATED(DstRodData%Pd)) THEN 
    ALLOCATE(DstRodData%Pd(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%Pd.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%Pd = SrcRodData%Pd
ENDIF
IF (ALLOCATED(SrcRodData%Dp)) THEN
  i1_l = LBOUND(SrcRodData%Dp,1)
  i1_u = UBOUND(SrcRodData%Dp,1)
  i2_l = LBOUND(SrcRodData%Dp,2)
  i2_u = UBOUND(SrcRodData%Dp,2)
  IF (.NOT. ALLOCATED(DstRodData%Dp)) THEN 
    ALLOCATE(DstRodData%Dp(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%Dp.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%Dp = SrcRodData%Dp
ENDIF
IF (ALLOCATED(SrcRodData%Dq)) THEN
  i1_l = LBOUND(SrcRodData%Dq,1)
  i1_u = UBOUND(SrcRodData%Dq,1)
  i2_l = LBOUND(SrcRodData%Dq,2)
  i2_u = UBOUND(SrcRodData%Dq,2)
  IF (.NOT. ALLOCATED(DstRodData%Dq)) THEN 
    ALLOCATE(DstRodData%Dq(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%Dq.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%Dq = SrcRodData%Dq
ENDIF
IF (ALLOCATED(SrcRodData%Ap)) THEN
  i1_l = LBOUND(SrcRodData%Ap,1)
  i1_u = UBOUND(SrcRodData%Ap,1)
  i2_l = LBOUND(SrcRodData%Ap,2)
  i2_u = UBOUND(SrcRodData%Ap,2)
  IF (.NOT. ALLOCATED(DstRodData%Ap)) THEN 
    ALLOCATE(DstRodData%Ap(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%Ap.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%Ap = SrcRodData%Ap
ENDIF
IF (ALLOCATED(SrcRodData%Aq)) THEN
  i1_l = LBOUND(SrcRodData%Aq,1)
  i1_u = UBOUND(SrcRodData%Aq,1)
  i2_l = LBOUND(SrcRodData%Aq,2)
  i2_u = UBOUND(SrcRodData%Aq,2)
  IF (.NOT. ALLOCATED(DstRodData%Aq)) THEN 
    ALLOCATE(DstRodData%Aq(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%Aq.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%Aq = SrcRodData%Aq
ENDIF
IF (ALLOCATED(SrcRodData%B)) THEN
  i1_l = LBOUND(SrcRodData%B,1)
  i1_u = UBOUND(SrcRodData%B,1)
  i2_l = LBOUND(SrcRodData%B,2)
  i2_u = UBOUND(SrcRodData%B,2)
  IF (.NOT. ALLOCATED(DstRodData%B)) THEN 
    ALLOCATE(DstRodData%B(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%B.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%B = SrcRodData%B
ENDIF
IF (ALLOCATED(SrcRodData%Fnet)) THEN
  i1_l = LBOUND(SrcRodData%Fnet,1)
  i1_u = UBOUND(SrcRodData%Fnet,1)
  i2_l = LBOUND(SrcRodData%Fnet,2)
  i2_u = UBOUND(SrcRodData%Fnet,2)
  IF (.NOT. ALLOCATED(DstRodData%Fnet)) THEN 
    ALLOCATE(DstRodData%Fnet(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%Fnet.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%Fnet = SrcRodData%Fnet
ENDIF
IF (ALLOCATED(SrcRodData%M)) THEN
  i1_l = LBOUND(SrcRodData%M,1)
  i1_u = UBOUND(SrcRodData%M,1)
  i2_l = LBOUND(SrcRodData%M,2)
  i2_u = UBOUND(SrcRodData%M,2)
  i3_l = LBOUND(SrcRodData%M,3)
  i3_u = UBOUND(SrcRodData%M,3)
  IF (.NOT. ALLOCATED(DstRodData%M)) THEN 
    ALLOCATE(DstRodData%M(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%M.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%M = SrcRodData%M
ENDIF
    DstRodData%Mext = SrcRodData%Mext
    DstRodData%r6 = SrcRodData%r6
    DstRodData%v6 = SrcRodData%v6
    DstRodData%a6 = SrcRodData%a6
    DstRodData%F6net = SrcRodData%F6net
    DstRodData%M6net = SrcRodData%M6net
    DstRodData%OrMat = SrcRodData%OrMat
    DstRodData%RodUnOut = SrcRodData%RodUnOut
IF (ALLOCATED(SrcRodData%RodWrOutput)) THEN
  i1_l = LBOUND(SrcRodData%RodWrOutput,1)
  i1_u = UBOUND(SrcRodData%RodWrOutput,1)
  IF (.NOT. ALLOCATED(DstRodData%RodWrOutput)) THEN 
    ALLOCATE(DstRodData%RodWrOutput(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstRodData%RodWrOutput.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstRodData%RodWrOutput = SrcRodData%RodWrOutput
ENDIF
 END SUBROUTINE MD_CopyRod

 SUBROUTINE MD_DestroyRod( RodData, ErrStat, ErrMsg )
  TYPE(MD_Rod), INTENT(INOUT) :: RodData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'MD_DestroyRod'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(RodData%r)) THEN
  DEALLOCATE(RodData%r)
ENDIF
IF (ALLOCATED(RodData%rd)) THEN
  DEALLOCATE(RodData%rd)
ENDIF
IF (ALLOCATED(RodData%l)) THEN
  DEALLOCATE(RodData%l)
ENDIF
IF (ALLOCATED(RodData%V)) THEN
  DEALLOCATE(RodData%V)
ENDIF
IF (ALLOCATED(RodData%U)) THEN
  DEALLOCATE(RodData%U)
ENDIF
IF (ALLOCATED(RodData%Ud)) THEN
  DEALLOCATE(RodData%Ud)
ENDIF
IF (ALLOCATED(RodData%zeta)) THEN
  DEALLOCATE(RodData%zeta)
ENDIF
IF (ALLOCATED(RodData%PDyn)) THEN
  DEALLOCATE(RodData%PDyn)
ENDIF
IF (ALLOCATED(RodData%W)) THEN
  DEALLOCATE(RodData%W)
ENDIF
IF (ALLOCATED(RodData%Bo)) THEN
  DEALLOCATE(RodData%Bo)
ENDIF
IF (ALLOCATED(RodData%Pd)) THEN
  DEALLOCATE(RodData%Pd)
ENDIF
IF (ALLOCATED(RodData%Dp)) THEN
  DEALLOCATE(RodData%Dp)
ENDIF
IF (ALLOCATED(RodData%Dq)) THEN
  DEALLOCATE(RodData%Dq)
ENDIF
IF (ALLOCATED(RodData%Ap)) THEN
  DEALLOCATE(RodData%Ap)
ENDIF
IF (ALLOCATED(RodData%Aq)) THEN
  DEALLOCATE(RodData%Aq)
ENDIF
IF (ALLOCATED(RodData%B)) THEN
  DEALLOCATE(RodData%B)
ENDIF
IF (ALLOCATED(RodData%Fnet)) THEN
  DEALLOCATE(RodData%Fnet)
ENDIF
IF (ALLOCATED(RodData%M)) THEN
  DEALLOCATE(RodData%M)
ENDIF
IF (ALLOCATED(RodData%RodWrOutput)) THEN
  DEALLOCATE(RodData%RodWrOutput)
ENDIF
 END SUBROUTINE MD_DestroyRod

 SUBROUTINE MD_PackRod( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_Rod),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'MD_PackRod'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! IdNum
      Int_BufSz  = Int_BufSz  + 1*LEN(InData%type)  ! type
      Int_BufSz  = Int_BufSz  + 1  ! PropsIdNum
      Int_BufSz  = Int_BufSz  + 1  ! typeNum
      Int_BufSz  = Int_BufSz  + SIZE(InData%AttachedA)  ! AttachedA
      Int_BufSz  = Int_BufSz  + SIZE(InData%AttachedB)  ! AttachedB
      Int_BufSz  = Int_BufSz  + SIZE(InData%TopA)  ! TopA
      Int_BufSz  = Int_BufSz  + SIZE(InData%TopB)  ! TopB
      Int_BufSz  = Int_BufSz  + 1  ! nAttachedA
      Int_BufSz  = Int_BufSz  + 1  ! nAttachedB
      Int_BufSz  = Int_BufSz  + SIZE(InData%OutFlagList)  ! OutFlagList
      Int_BufSz  = Int_BufSz  + 1  ! N
      Int_BufSz  = Int_BufSz  + 1  ! endTypeA
      Int_BufSz  = Int_BufSz  + 1  ! endTypeB
      Db_BufSz   = Db_BufSz   + 1  ! UnstrLen
      Db_BufSz   = Db_BufSz   + 1  ! mass
      Db_BufSz   = Db_BufSz   + 1  ! rho
      Db_BufSz   = Db_BufSz   + 1  ! d
      Db_BufSz   = Db_BufSz   + 1  ! Can
      Db_BufSz   = Db_BufSz   + 1  ! Cat
      Db_BufSz   = Db_BufSz   + 1  ! Cdn
      Db_BufSz   = Db_BufSz   + 1  ! Cdt
      Db_BufSz   = Db_BufSz   + 1  ! CdEnd
      Db_BufSz   = Db_BufSz   + 1  ! CaEnd
      Db_BufSz   = Db_BufSz   + 1  ! time
      Db_BufSz   = Db_BufSz   + 1  ! roll
      Db_BufSz   = Db_BufSz   + 1  ! pitch
  Int_BufSz   = Int_BufSz   + 1     ! r allocated yes/no
  IF ( ALLOCATED(InData%r) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! r upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%r)  ! r
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! rd allocated yes/no
  IF ( ALLOCATED(InData%rd) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! rd upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%rd)  ! rd
  END IF
      Db_BufSz   = Db_BufSz   + SIZE(InData%q)  ! q
  Int_BufSz   = Int_BufSz   + 1     ! l allocated yes/no
  IF ( ALLOCATED(InData%l) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! l upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%l)  ! l
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! V allocated yes/no
  IF ( ALLOCATED(InData%V) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! V upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%V)  ! V
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! U allocated yes/no
  IF ( ALLOCATED(InData%U) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! U upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%U)  ! U
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Ud allocated yes/no
  IF ( ALLOCATED(InData%Ud) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Ud upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%Ud)  ! Ud
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! zeta allocated yes/no
  IF ( ALLOCATED(InData%zeta) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! zeta upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%zeta)  ! zeta
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! PDyn allocated yes/no
  IF ( ALLOCATED(InData%PDyn) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! PDyn upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%PDyn)  ! PDyn
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! W allocated yes/no
  IF ( ALLOCATED(InData%W) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! W upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%W)  ! W
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Bo allocated yes/no
  IF ( ALLOCATED(InData%Bo) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Bo upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%Bo)  ! Bo
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Pd allocated yes/no
  IF ( ALLOCATED(InData%Pd) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Pd upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%Pd)  ! Pd
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Dp allocated yes/no
  IF ( ALLOCATED(InData%Dp) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Dp upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%Dp)  ! Dp
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Dq allocated yes/no
  IF ( ALLOCATED(InData%Dq) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Dq upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%Dq)  ! Dq
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Ap allocated yes/no
  IF ( ALLOCATED(InData%Ap) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Ap upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%Ap)  ! Ap
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Aq allocated yes/no
  IF ( ALLOCATED(InData%Aq) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Aq upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%Aq)  ! Aq
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! B allocated yes/no
  IF ( ALLOCATED(InData%B) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! B upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%B)  ! B
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Fnet allocated yes/no
  IF ( ALLOCATED(InData%Fnet) ) THEN
    Int_BufSz   = Int_BufSz   + 2*2  ! Fnet upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%Fnet)  ! Fnet
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! M allocated yes/no
  IF ( ALLOCATED(InData%M) ) THEN
    Int_BufSz   = Int_BufSz   + 2*3  ! M upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%M)  ! M
  END IF
      Db_BufSz   = Db_BufSz   + SIZE(InData%Mext)  ! Mext
      Db_BufSz   = Db_BufSz   + SIZE(InData%r6)  ! r6
      Db_BufSz   = Db_BufSz   + SIZE(InData%v6)  ! v6
      Db_BufSz   = Db_BufSz   + SIZE(InData%a6)  ! a6
      Db_BufSz   = Db_BufSz   + SIZE(InData%F6net)  ! F6net
      Db_BufSz   = Db_BufSz   + SIZE(InData%M6net)  ! M6net
      Db_BufSz   = Db_BufSz   + SIZE(InData%OrMat)  ! OrMat
      Int_BufSz  = Int_BufSz  + 1  ! RodUnOut
  Int_BufSz   = Int_BufSz   + 1     ! RodWrOutput allocated yes/no
  IF ( ALLOCATED(InData%RodWrOutput) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! RodWrOutput upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%RodWrOutput)  ! RodWrOutput
  END IF
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%IdNum
    Int_Xferred = Int_Xferred + 1
    DO I = 1, LEN(InData%type)
      IntKiBuf(Int_Xferred) = ICHAR(InData%type(I:I), IntKi)
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    IntKiBuf(Int_Xferred) = InData%PropsIdNum
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%typeNum
    Int_Xferred = Int_Xferred + 1
    DO i1 = LBOUND(InData%AttachedA,1), UBOUND(InData%AttachedA,1)
      IntKiBuf(Int_Xferred) = InData%AttachedA(i1)
      Int_Xferred = Int_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%AttachedB,1), UBOUND(InData%AttachedB,1)
      IntKiBuf(Int_Xferred) = InData%AttachedB(i1)
      Int_Xferred = Int_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%TopA,1), UBOUND(InData%TopA,1)
      IntKiBuf(Int_Xferred) = InData%TopA(i1)
      Int_Xferred = Int_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%TopB,1), UBOUND(InData%TopB,1)
      IntKiBuf(Int_Xferred) = InData%TopB(i1)
      Int_Xferred = Int_Xferred + 1
    END DO
    IntKiBuf(Int_Xferred) = InData%nAttachedA
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%nAttachedB
    Int_Xferred = Int_Xferred + 1
    DO i1 = LBOUND(InData%OutFlagList,1), UBOUND(InData%OutFlagList,1)
      IntKiBuf(Int_Xferred) = InData%OutFlagList(i1)
      Int_Xferred = Int_Xferred + 1
    END DO
    IntKiBuf(Int_Xferred) = InData%N
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%endTypeA
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%endTypeB
    Int_Xferred = Int_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%UnstrLen
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%mass
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%rho
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%d
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%Can
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%Cat
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%Cdn
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%Cdt
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%CdEnd
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%CaEnd
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%time
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%roll
    Db_Xferred = Db_Xferred + 1
    DbKiBuf(Db_Xferred) = InData%pitch
    Db_Xferred = Db_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%r) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%r,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%r,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%r,2), UBOUND(InData%r,2)
        DO i1 = LBOUND(InData%r,1), UBOUND(InData%r,1)
          DbKiBuf(Db_Xferred) = InData%r(i1,i2)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%rd) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%rd,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%rd,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%rd,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%rd,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%rd,2), UBOUND(InData%rd,2)
        DO i1 = LBOUND(InData%rd,1), UBOUND(InData%rd,1)
          DbKiBuf(Db_Xferred) = InData%rd(i1,i2)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
    DO i1 = LBOUND(InData%q,1), UBOUND(InData%q,1)
      DbKiBuf(Db_Xferred) = InData%q(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
  IF ( .NOT. ALLOCATED(InData%l) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%l,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%l,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%l,1), UBOUND(InData%l,1)
        DbKiBuf(Db_Xferred) = InData%l(i1)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%V) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%V,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%V,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%V,1), UBOUND(InData%V,1)
        DbKiBuf(Db_Xferred) = InData%V(i1)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%U) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%U,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%U,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%U,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%U,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%U,2), UBOUND(InData%U,2)
        DO i1 = LBOUND(InData%U,1), UBOUND(InData%U,1)
          DbKiBuf(Db_Xferred) = InData%U(i1,i2)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Ud) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Ud,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Ud,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Ud,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Ud,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Ud,2), UBOUND(InData%Ud,2)
        DO i1 = LBOUND(InData%Ud,1), UBOUND(InData%Ud,1)
          DbKiBuf(Db_Xferred) = InData%Ud(i1,i2)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%zeta) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%zeta,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%zeta,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%zeta,1), UBOUND(InData%zeta,1)
        DbKiBuf(Db_Xferred) = InData%zeta(i1)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%PDyn) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%PDyn,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%PDyn,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%PDyn,1), UBOUND(InData%PDyn,1)
        DbKiBuf(Db_Xferred) = InData%PDyn(i1)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%W) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%W,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%W,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%W,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%W,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%W,2), UBOUND(InData%W,2)
        DO i1 = LBOUND(InData%W,1), UBOUND(InData%W,1)
          DbKiBuf(Db_Xferred) = InData%W(i1,i2)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Bo) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Bo,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Bo,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Bo,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Bo,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Bo,2), UBOUND(InData%Bo,2)
        DO i1 = LBOUND(InData%Bo,1), UBOUND(InData%Bo,1)
          DbKiBuf(Db_Xferred) = InData%Bo(i1,i2)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Pd) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Pd,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Pd,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Pd,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Pd,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Pd,2), UBOUND(InData%Pd,2)
        DO i1 = LBOUND(InData%Pd,1), UBOUND(InData%Pd,1)
          DbKiBuf(Db_Xferred) = InData%Pd(i1,i2)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Dp) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Dp,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Dp,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Dp,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Dp,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Dp,2), UBOUND(InData%Dp,2)
        DO i1 = LBOUND(InData%Dp,1), UBOUND(InData%Dp,1)
          DbKiBuf(Db_Xferred) = InData%Dp(i1,i2)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Dq) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Dq,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Dq,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Dq,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Dq,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Dq,2), UBOUND(InData%Dq,2)
        DO i1 = LBOUND(InData%Dq,1), UBOUND(InData%Dq,1)
          DbKiBuf(Db_Xferred) = InData%Dq(i1,i2)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Ap) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Ap,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Ap,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Ap,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Ap,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Ap,2), UBOUND(InData%Ap,2)
        DO i1 = LBOUND(InData%Ap,1), UBOUND(InData%Ap,1)
          DbKiBuf(Db_Xferred) = InData%Ap(i1,i2)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Aq) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Aq,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Aq,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Aq,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Aq,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Aq,2), UBOUND(InData%Aq,2)
        DO i1 = LBOUND(InData%Aq,1), UBOUND(InData%Aq,1)
          DbKiBuf(Db_Xferred) = InData%Aq(i1,i2)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%B) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%B,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%B,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%B,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%B,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%B,2), UBOUND(InData%B,2)
        DO i1 = LBOUND(InData%B,1), UBOUND(InData%B,1)
          DbKiBuf(Db_Xferred) = InData%B(i1,i2)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Fnet) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Fnet,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Fnet,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Fnet,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Fnet,2)
    Int_Xferred = Int_Xferred + 2

      DO i2 = LBOUND(InData%Fnet,2), UBOUND(InData%Fnet,2)
        DO i1 = LBOUND(InData%Fnet,1), UBOUND(InData%Fnet,1)
          DbKiBuf(Db_Xferred) = InData%Fnet(i1,i2)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%M) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%M,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%M,1)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%M,2)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%M,2)
    Int_Xferred = Int_Xferred + 2
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%M,3)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%M,3)
    Int_Xferred = Int_Xferred + 2

      DO i3 = LBOUND(InData%M,3), UBOUND(InData%M,3)
        DO i2 = LBOUND(InData%M,2), UBOUND(InData%M,2)
          DO i1 = LBOUND(InData%M,1), UBOUND(InData%M,1)
            DbKiBuf(Db_Xferred) = InData%M(i1,i2,i3)
            Db_Xferred = Db_Xferred + 1
          END DO
        END DO
      END DO
  END IF
    DO i1 = LBOUND(InData%Mext,1), UBOUND(InData%Mext,1)
      DbKiBuf(Db_Xferred) = InData%Mext(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%r6,1), UBOUND(InData%r6,1)
      DbKiBuf(Db_Xferred) = InData%r6(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%v6,1), UBOUND(InData%v6,1)
      DbKiBuf(Db_Xferred) = InData%v6(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%a6,1), UBOUND(InData%a6,1)
      DbKiBuf(Db_Xferred) = InData%a6(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    DO i1 = LBOUND(InData%F6net,1), UBOUND(InData%F6net,1)
      DbKiBuf(Db_Xferred) = InData%F6net(i1)
      Db_Xferred = Db_Xferred + 1
    END DO
    DO i2 = LBOUND(InData%M6net,2), UBOUND(InData%M6net,2)
      DO i1 = LBOUND(InData%M6net,1), UBOUND(InData%M6net,1)
        DbKiBuf(Db_Xferred) = InData%M6net(i1,i2)
        Db_Xferred = Db_Xferred + 1
      END DO
    END DO
    DO i2 = LBOUND(InData%OrMat,2), UBOUND(InData%OrMat,2)
      DO i1 = LBOUND(InData%OrMat,1), UBOUND(InData%OrMat,1)
        DbKiBuf(Db_Xferred) = InData%OrMat(i1,i2)
        Db_Xferred = Db_Xferred + 1
      END DO
    END DO
    IntKiBuf(Int_Xferred) = InData%RodUnOut
    Int_Xferred = Int_Xferred + 1
  IF ( .NOT. ALLOCATED(InData%RodWrOutput) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%RodWrOutput,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%RodWrOutput,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%RodWrOutput,1), UBOUND(InData%RodWrOutput,1)
        DbKiBuf(Db_Xferred) = InData%RodWrOutput(i1)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
 END SUBROUTINE MD_PackRod

 SUBROUTINE MD_UnPackRod( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_Rod), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: i2, i2_l, i2_u  !  bounds (upper/lower) for an array dimension 2
  INTEGER(IntKi)                 :: i3, i3_l, i3_u  !  bounds (upper/lower) for an array dimension 3
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'MD_UnPackRod'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%IdNum = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    DO I = 1, LEN(OutData%type)
      OutData%type(I:I) = CHAR(IntKiBuf(Int_Xferred))
      Int_Xferred = Int_Xferred + 1
    END DO ! I
    OutData%PropsIdNum = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%typeNum = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    i1_l = LBOUND(OutData%AttachedA,1)
    i1_u = UBOUND(OutData%AttachedA,1)
    DO i1 = LBOUND(OutData%AttachedA,1), UBOUND(OutData%AttachedA,1)
      OutData%AttachedA(i1) = IntKiBuf(Int_Xferred)
      Int_Xferred = Int_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%AttachedB,1)
    i1_u = UBOUND(OutData%AttachedB,1)
    DO i1 = LBOUND(OutData%AttachedB,1), UBOUND(OutData%AttachedB,1)
      OutData%AttachedB(i1) = IntKiBuf(Int_Xferred)
      Int_Xferred = Int_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%TopA,1)
    i1_u = UBOUND(OutData%TopA,1)
    DO i1 = LBOUND(OutData%TopA,1), UBOUND(OutData%TopA,1)
      OutData%TopA(i1) = IntKiBuf(Int_Xferred)
      Int_Xferred = Int_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%TopB,1)
    i1_u = UBOUND(OutData%TopB,1)
    DO i1 = LBOUND(OutData%TopB,1), UBOUND(OutData%TopB,1)
      OutData%TopB(i1) = IntKiBuf(Int_Xferred)
      Int_Xferred = Int_Xferred + 1
    END DO
    OutData%nAttachedA = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%nAttachedB = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    i1_l = LBOUND(OutData%OutFlagList,1)
    i1_u = UBOUND(OutData%OutFlagList,1)
    DO i1 = LBOUND(OutData%OutFlagList,1), UBOUND(OutData%OutFlagList,1)
      OutData%OutFlagList(i1) = IntKiBuf(Int_Xferred)
      Int_Xferred = Int_Xferred + 1
    END DO
    OutData%N = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%endTypeA = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%endTypeB = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%UnstrLen = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%mass = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%rho = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%d = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%Can = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%Cat = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%Cdn = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%Cdt = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%CdEnd = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%CaEnd = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%time = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%roll = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%pitch = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! r not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%r)) DEALLOCATE(OutData%r)
    ALLOCATE(OutData%r(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%r.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%r,2), UBOUND(OutData%r,2)
        DO i1 = LBOUND(OutData%r,1), UBOUND(OutData%r,1)
          OutData%r(i1,i2) = DbKiBuf(Db_Xferred)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! rd not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%rd)) DEALLOCATE(OutData%rd)
    ALLOCATE(OutData%rd(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%rd.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%rd,2), UBOUND(OutData%rd,2)
        DO i1 = LBOUND(OutData%rd,1), UBOUND(OutData%rd,1)
          OutData%rd(i1,i2) = DbKiBuf(Db_Xferred)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
    i1_l = LBOUND(OutData%q,1)
    i1_u = UBOUND(OutData%q,1)
    DO i1 = LBOUND(OutData%q,1), UBOUND(OutData%q,1)
      OutData%q(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! l not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%l)) DEALLOCATE(OutData%l)
    ALLOCATE(OutData%l(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%l.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%l,1), UBOUND(OutData%l,1)
        OutData%l(i1) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! V not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%V)) DEALLOCATE(OutData%V)
    ALLOCATE(OutData%V(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%V.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%V,1), UBOUND(OutData%V,1)
        OutData%V(i1) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! U not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%U)) DEALLOCATE(OutData%U)
    ALLOCATE(OutData%U(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%U.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%U,2), UBOUND(OutData%U,2)
        DO i1 = LBOUND(OutData%U,1), UBOUND(OutData%U,1)
          OutData%U(i1,i2) = DbKiBuf(Db_Xferred)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Ud not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Ud)) DEALLOCATE(OutData%Ud)
    ALLOCATE(OutData%Ud(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Ud.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Ud,2), UBOUND(OutData%Ud,2)
        DO i1 = LBOUND(OutData%Ud,1), UBOUND(OutData%Ud,1)
          OutData%Ud(i1,i2) = DbKiBuf(Db_Xferred)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! zeta not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%zeta)) DEALLOCATE(OutData%zeta)
    ALLOCATE(OutData%zeta(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%zeta.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%zeta,1), UBOUND(OutData%zeta,1)
        OutData%zeta(i1) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! PDyn not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%PDyn)) DEALLOCATE(OutData%PDyn)
    ALLOCATE(OutData%PDyn(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%PDyn.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%PDyn,1), UBOUND(OutData%PDyn,1)
        OutData%PDyn(i1) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! W not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%W)) DEALLOCATE(OutData%W)
    ALLOCATE(OutData%W(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%W.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%W,2), UBOUND(OutData%W,2)
        DO i1 = LBOUND(OutData%W,1), UBOUND(OutData%W,1)
          OutData%W(i1,i2) = DbKiBuf(Db_Xferred)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Bo not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Bo)) DEALLOCATE(OutData%Bo)
    ALLOCATE(OutData%Bo(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Bo.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Bo,2), UBOUND(OutData%Bo,2)
        DO i1 = LBOUND(OutData%Bo,1), UBOUND(OutData%Bo,1)
          OutData%Bo(i1,i2) = DbKiBuf(Db_Xferred)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Pd not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Pd)) DEALLOCATE(OutData%Pd)
    ALLOCATE(OutData%Pd(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Pd.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Pd,2), UBOUND(OutData%Pd,2)
        DO i1 = LBOUND(OutData%Pd,1), UBOUND(OutData%Pd,1)
          OutData%Pd(i1,i2) = DbKiBuf(Db_Xferred)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Dp not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Dp)) DEALLOCATE(OutData%Dp)
    ALLOCATE(OutData%Dp(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Dp.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Dp,2), UBOUND(OutData%Dp,2)
        DO i1 = LBOUND(OutData%Dp,1), UBOUND(OutData%Dp,1)
          OutData%Dp(i1,i2) = DbKiBuf(Db_Xferred)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Dq not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Dq)) DEALLOCATE(OutData%Dq)
    ALLOCATE(OutData%Dq(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Dq.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Dq,2), UBOUND(OutData%Dq,2)
        DO i1 = LBOUND(OutData%Dq,1), UBOUND(OutData%Dq,1)
          OutData%Dq(i1,i2) = DbKiBuf(Db_Xferred)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Ap not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Ap)) DEALLOCATE(OutData%Ap)
    ALLOCATE(OutData%Ap(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Ap.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Ap,2), UBOUND(OutData%Ap,2)
        DO i1 = LBOUND(OutData%Ap,1), UBOUND(OutData%Ap,1)
          OutData%Ap(i1,i2) = DbKiBuf(Db_Xferred)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Aq not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Aq)) DEALLOCATE(OutData%Aq)
    ALLOCATE(OutData%Aq(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Aq.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Aq,2), UBOUND(OutData%Aq,2)
        DO i1 = LBOUND(OutData%Aq,1), UBOUND(OutData%Aq,1)
          OutData%Aq(i1,i2) = DbKiBuf(Db_Xferred)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! B not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%B)) DEALLOCATE(OutData%B)
    ALLOCATE(OutData%B(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%B.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%B,2), UBOUND(OutData%B,2)
        DO i1 = LBOUND(OutData%B,1), UBOUND(OutData%B,1)
          OutData%B(i1,i2) = DbKiBuf(Db_Xferred)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Fnet not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Fnet)) DEALLOCATE(OutData%Fnet)
    ALLOCATE(OutData%Fnet(i1_l:i1_u,i2_l:i2_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Fnet.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i2 = LBOUND(OutData%Fnet,2), UBOUND(OutData%Fnet,2)
        DO i1 = LBOUND(OutData%Fnet,1), UBOUND(OutData%Fnet,1)
          OutData%Fnet(i1,i2) = DbKiBuf(Db_Xferred)
          Db_Xferred = Db_Xferred + 1
        END DO
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! M not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i2_l = IntKiBuf( Int_Xferred    )
    i2_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    i3_l = IntKiBuf( Int_Xferred    )
    i3_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%M)) DEALLOCATE(OutData%M)
    ALLOCATE(OutData%M(i1_l:i1_u,i2_l:i2_u,i3_l:i3_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%M.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i3 = LBOUND(OutData%M,3), UBOUND(OutData%M,3)
        DO i2 = LBOUND(OutData%M,2), UBOUND(OutData%M,2)
          DO i1 = LBOUND(OutData%M,1), UBOUND(OutData%M,1)
            OutData%M(i1,i2,i3) = DbKiBuf(Db_Xferred)
            Db_Xferred = Db_Xferred + 1
          END DO
        END DO
      END DO
  END IF
    i1_l = LBOUND(OutData%Mext,1)
    i1_u = UBOUND(OutData%Mext,1)
    DO i1 = LBOUND(OutData%Mext,1), UBOUND(OutData%Mext,1)
      OutData%Mext(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%r6,1)
    i1_u = UBOUND(OutData%r6,1)
    DO i1 = LBOUND(OutData%r6,1), UBOUND(OutData%r6,1)
      OutData%r6(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%v6,1)
    i1_u = UBOUND(OutData%v6,1)
    DO i1 = LBOUND(OutData%v6,1), UBOUND(OutData%v6,1)
      OutData%v6(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%a6,1)
    i1_u = UBOUND(OutData%a6,1)
    DO i1 = LBOUND(OutData%a6,1), UBOUND(OutData%a6,1)
      OutData%a6(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%F6net,1)
    i1_u = UBOUND(OutData%F6net,1)
    DO i1 = LBOUND(OutData%F6net,1), UBOUND(OutData%F6net,1)
      OutData%F6net(i1) = DbKiBuf(Db_Xferred)
      Db_Xferred = Db_Xferred + 1
    END DO
    i1_l = LBOUND(OutData%M6net,1)
    i1_u = UBOUND(OutData%M6net,1)
    i2_l = LBOUND(OutData%M6net,2)
    i2_u = UBOUND(OutData%M6net,2)
    DO i2 = LBOUND(OutData%M6net,2), UBOUND(OutData%M6net,2)
      DO i1 = LBOUND(OutData%M6net,1), UBOUND(OutData%M6net,1)
        OutData%M6net(i1,i2) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
    END DO
    i1_l = LBOUND(OutData%OrMat,1)
    i1_u = UBOUND(OutData%OrMat,1)
    i2_l = LBOUND(OutData%OrMat,2)
    i2_u = UBOUND(OutData%OrMat,2)
    DO i2 = LBOUND(OutData%OrMat,2), UBOUND(OutData%OrMat,2)
      DO i1 = LBOUND(OutData%OrMat,1), UBOUND(OutData%OrMat,1)
        OutData%OrMat(i1,i2) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
    END DO
    OutData%RodUnOut = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! RodWrOutput not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%RodWrOutput)) DEALLOCATE(OutData%RodWrOutput)
    ALLOCATE(OutData%RodWrOutput(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%RodWrOutput.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%RodWrOutput,1), UBOUND(OutData%RodWrOutput,1)
        OutData%RodWrOutput(i1) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
 END SUBROUTINE MD_UnPackRod

 SUBROUTINE MD_CopyLine( SrcLineData, DstLineData, CtrlCode, ErrStat, ErrMsg )
   TYPE(MD_Line), INTENT(IN) :: SrcLineData
   TYPE(MD_Line), INTENT(INOUT) :: DstLineData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'MD_CopyLine'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
    DstLineData%IdNum = SrcLineData%IdNum
    DstLineData%PropsIdNum = SrcLineData%PropsIdNum
    DstLineData%OutFlagList = SrcLineData%OutFlagList
    DstLineData%CtrlChan = SrcLineData%CtrlChan
    DstLineData%FairConnect = SrcLineData%FairConnect
    DstLineData%AnchConnect = SrcLineData%AnchConnect
    DstLineData%N = SrcLineData%N
 END SUBROUTINE MD_CopyLine

 SUBROUTINE MD_DestroyLine( LineData, ErrStat, ErrMsg )
  TYPE(MD_Line), INTENT(INOUT) :: LineData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'MD_DestroyLine'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
 END SUBROUTINE MD_DestroyLine

 SUBROUTINE MD_PackLine( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(MD_Line),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'MD_PackLine'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
      Int_BufSz  = Int_BufSz  + 1  ! IdNum
      Int_BufSz  = Int_BufSz  + 1  ! PropsIdNum
      Int_BufSz  = Int_BufSz  + SIZE(InData%OutFlagList)  ! OutFlagList
      Int_BufSz  = Int_BufSz  + 1  ! CtrlChan
      Int_BufSz  = Int_BufSz  + 1  ! FairConnect
      Int_BufSz  = Int_BufSz  + 1  ! AnchConnect
      Int_BufSz  = Int_BufSz  + 1  ! N
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

    IntKiBuf(Int_Xferred) = InData%IdNum
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%PropsIdNum
    Int_Xferred = Int_Xferred + 1
    DO i1 = LBOUND(InData%OutFlagList,1), UBOUND(InData%OutFlagList,1)
      IntKiBuf(Int_Xferred) = InData%OutFlagList(i1)
      Int_Xferred = Int_Xferred + 1
    END DO
    IntKiBuf(Int_Xferred) = InData%CtrlChan
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%FairConnect
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%AnchConnect
    Int_Xferred = Int_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%N
    Int_Xferred = Int_Xferred + 1
 END SUBROUTINE MD_PackLine

 SUBROUTINE MD_UnPackLine( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(MD_Line), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'MD_UnPackLine'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
    OutData%IdNum = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%PropsIdNum = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    i1_l = LBOUND(OutData%OutFlagList,1)
    i1_u = UBOUND(OutData%OutFlagList,1)
    DO i1 = LBOUND(OutData%OutFlagList,1), UBOUND(OutData%OutFlagList,1)
      OutData%OutFlagList(i1) = IntKiBuf(Int_Xferred)
      Int_Xferred = Int_Xferred + 1
    END DO
    OutData%CtrlChan = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%FairConnect = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%AnchConnect = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
    OutData%N = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
 END SUBROUTINE MD_UnPackLine

END MODULE MoorDyn_Types
!ENDOFREGISTRYGENERATEDFILE
