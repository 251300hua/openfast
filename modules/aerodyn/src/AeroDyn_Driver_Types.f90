!STARTOFREGISTRYGENERATEDFILE 'AeroDyn_Driver_Types.f90'
!
! WARNING This file is generated automatically by the FAST registry.
! Do not edit.  Your changes to this file will be lost.
!
! FAST Registry
!*********************************************************************************************************************************
! AeroDyn_Driver_Types
!.................................................................................................................................
! This file is part of AeroDyn_Driver.
!
! Copyright (C) 2012-2016 National Renewable Energy Laboratory
!
! Licensed under the Apache License, Version 2.0 (the "License");
! you may not use this file except in compliance with the License.
! You may obtain a copy of the License at
!
!     http://www.apache.org/licenses/LICENSE-2.0
!
! Unless required by applicable law or agreed to in writing, software
! distributed under the License is distributed on an "AS IS" BASIS,
! WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
! See the License for the specific language governing permissions and
! limitations under the License.
!
!
! W A R N I N G : This file was automatically generated from the FAST registry.  Changes made to this file may be lost.
!
!*********************************************************************************************************************************
!> This module contains the user-defined types needed in AeroDyn_Driver. It also contains copy, destroy, pack, and
!! unpack routines associated with each defined data type. This code is automatically generated by the FAST Registry.
MODULE AeroDyn_Driver_Types
!---------------------------------------------------------------------------------------------------------------------------------
USE AirfoilInfo_Types
USE UnsteadyAero_Types
USE DBEMT_Types
USE BEMT_Types
USE FVW_Types
USE AeroAcoustics_Types
USE AeroDyn_Types
USE IfW_UniformWind_Types
USE IfW_FFWind_Base_Types
USE IfW_TSFFWind_Types
USE IfW_BladedFFWind_Types
USE IfW_HAWCWind_Types
USE IfW_UserWind_Types
USE IfW_4Dext_Types
USE Lidar_Types
USE InflowWind_Types
USE NWTC_Library
IMPLICIT NONE
! =========  Dvr_Case  =======
  TYPE, PUBLIC :: Dvr_Case
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: WndSpeed      !< Wind Speed [m/s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: ShearExp      !< Power Law Wind-Shear Exponent [-]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: RotSpeed      !< Rotor Speed [rad/s]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Pitch      !< Pitch angle [rad]
    REAL(ReKi) , DIMENSION(:), ALLOCATABLE  :: Yaw      !< Yaw angle [rad]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: time      !< time increment [s]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: DOF      !< Degree of freedom for sinusoidal motion [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: Amplitude      !< Amplitude for sinusoidal motion (when DOF>0) [-]
    REAL(DbKi) , DIMENSION(:), ALLOCATABLE  :: Frequency      !< Frequency for sinusoidal motion (when DOF>0) [-]
    REAL(DbKi)  :: dT      !< time increment [s]
    INTEGER(IntKi)  :: numSteps      !< number of steps in this case [-]
  END TYPE Dvr_Case
! =======================
CONTAINS
 SUBROUTINE ADM_Dvr_CopyDvr_Case( SrcDvr_CaseData, DstDvr_CaseData, CtrlCode, ErrStat, ErrMsg )
   TYPE(Dvr_Case), INTENT(IN) :: SrcDvr_CaseData
   TYPE(Dvr_Case), INTENT(INOUT) :: DstDvr_CaseData
   INTEGER(IntKi),  INTENT(IN   ) :: CtrlCode
   INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
   CHARACTER(*),    INTENT(  OUT) :: ErrMsg
! Local 
   INTEGER(IntKi)                 :: i,j,k
   INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
   INTEGER(IntKi)                 :: ErrStat2
   CHARACTER(ErrMsgLen)           :: ErrMsg2
   CHARACTER(*), PARAMETER        :: RoutineName = 'ADM_Dvr_CopyDvr_Case'
! 
   ErrStat = ErrID_None
   ErrMsg  = ""
IF (ALLOCATED(SrcDvr_CaseData%WndSpeed)) THEN
  i1_l = LBOUND(SrcDvr_CaseData%WndSpeed,1)
  i1_u = UBOUND(SrcDvr_CaseData%WndSpeed,1)
  IF (.NOT. ALLOCATED(DstDvr_CaseData%WndSpeed)) THEN 
    ALLOCATE(DstDvr_CaseData%WndSpeed(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDvr_CaseData%WndSpeed.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstDvr_CaseData%WndSpeed = SrcDvr_CaseData%WndSpeed
ENDIF
IF (ALLOCATED(SrcDvr_CaseData%ShearExp)) THEN
  i1_l = LBOUND(SrcDvr_CaseData%ShearExp,1)
  i1_u = UBOUND(SrcDvr_CaseData%ShearExp,1)
  IF (.NOT. ALLOCATED(DstDvr_CaseData%ShearExp)) THEN 
    ALLOCATE(DstDvr_CaseData%ShearExp(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDvr_CaseData%ShearExp.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstDvr_CaseData%ShearExp = SrcDvr_CaseData%ShearExp
ENDIF
IF (ALLOCATED(SrcDvr_CaseData%RotSpeed)) THEN
  i1_l = LBOUND(SrcDvr_CaseData%RotSpeed,1)
  i1_u = UBOUND(SrcDvr_CaseData%RotSpeed,1)
  IF (.NOT. ALLOCATED(DstDvr_CaseData%RotSpeed)) THEN 
    ALLOCATE(DstDvr_CaseData%RotSpeed(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDvr_CaseData%RotSpeed.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstDvr_CaseData%RotSpeed = SrcDvr_CaseData%RotSpeed
ENDIF
IF (ALLOCATED(SrcDvr_CaseData%Pitch)) THEN
  i1_l = LBOUND(SrcDvr_CaseData%Pitch,1)
  i1_u = UBOUND(SrcDvr_CaseData%Pitch,1)
  IF (.NOT. ALLOCATED(DstDvr_CaseData%Pitch)) THEN 
    ALLOCATE(DstDvr_CaseData%Pitch(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDvr_CaseData%Pitch.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstDvr_CaseData%Pitch = SrcDvr_CaseData%Pitch
ENDIF
IF (ALLOCATED(SrcDvr_CaseData%Yaw)) THEN
  i1_l = LBOUND(SrcDvr_CaseData%Yaw,1)
  i1_u = UBOUND(SrcDvr_CaseData%Yaw,1)
  IF (.NOT. ALLOCATED(DstDvr_CaseData%Yaw)) THEN 
    ALLOCATE(DstDvr_CaseData%Yaw(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDvr_CaseData%Yaw.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstDvr_CaseData%Yaw = SrcDvr_CaseData%Yaw
ENDIF
IF (ALLOCATED(SrcDvr_CaseData%time)) THEN
  i1_l = LBOUND(SrcDvr_CaseData%time,1)
  i1_u = UBOUND(SrcDvr_CaseData%time,1)
  IF (.NOT. ALLOCATED(DstDvr_CaseData%time)) THEN 
    ALLOCATE(DstDvr_CaseData%time(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDvr_CaseData%time.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstDvr_CaseData%time = SrcDvr_CaseData%time
ENDIF
IF (ALLOCATED(SrcDvr_CaseData%DOF)) THEN
  i1_l = LBOUND(SrcDvr_CaseData%DOF,1)
  i1_u = UBOUND(SrcDvr_CaseData%DOF,1)
  IF (.NOT. ALLOCATED(DstDvr_CaseData%DOF)) THEN 
    ALLOCATE(DstDvr_CaseData%DOF(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDvr_CaseData%DOF.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstDvr_CaseData%DOF = SrcDvr_CaseData%DOF
ENDIF
IF (ALLOCATED(SrcDvr_CaseData%Amplitude)) THEN
  i1_l = LBOUND(SrcDvr_CaseData%Amplitude,1)
  i1_u = UBOUND(SrcDvr_CaseData%Amplitude,1)
  IF (.NOT. ALLOCATED(DstDvr_CaseData%Amplitude)) THEN 
    ALLOCATE(DstDvr_CaseData%Amplitude(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDvr_CaseData%Amplitude.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstDvr_CaseData%Amplitude = SrcDvr_CaseData%Amplitude
ENDIF
IF (ALLOCATED(SrcDvr_CaseData%Frequency)) THEN
  i1_l = LBOUND(SrcDvr_CaseData%Frequency,1)
  i1_u = UBOUND(SrcDvr_CaseData%Frequency,1)
  IF (.NOT. ALLOCATED(DstDvr_CaseData%Frequency)) THEN 
    ALLOCATE(DstDvr_CaseData%Frequency(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
      CALL SetErrStat(ErrID_Fatal, 'Error allocating DstDvr_CaseData%Frequency.', ErrStat, ErrMsg,RoutineName)
      RETURN
    END IF
  END IF
    DstDvr_CaseData%Frequency = SrcDvr_CaseData%Frequency
ENDIF
    DstDvr_CaseData%dT = SrcDvr_CaseData%dT
    DstDvr_CaseData%numSteps = SrcDvr_CaseData%numSteps
 END SUBROUTINE ADM_Dvr_CopyDvr_Case

 SUBROUTINE ADM_Dvr_DestroyDvr_Case( Dvr_CaseData, ErrStat, ErrMsg )
  TYPE(Dvr_Case), INTENT(INOUT) :: Dvr_CaseData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
  CHARACTER(*),    PARAMETER :: RoutineName = 'ADM_Dvr_DestroyDvr_Case'
  INTEGER(IntKi)                 :: i, i1, i2, i3, i4, i5 
! 
  ErrStat = ErrID_None
  ErrMsg  = ""
IF (ALLOCATED(Dvr_CaseData%WndSpeed)) THEN
  DEALLOCATE(Dvr_CaseData%WndSpeed)
ENDIF
IF (ALLOCATED(Dvr_CaseData%ShearExp)) THEN
  DEALLOCATE(Dvr_CaseData%ShearExp)
ENDIF
IF (ALLOCATED(Dvr_CaseData%RotSpeed)) THEN
  DEALLOCATE(Dvr_CaseData%RotSpeed)
ENDIF
IF (ALLOCATED(Dvr_CaseData%Pitch)) THEN
  DEALLOCATE(Dvr_CaseData%Pitch)
ENDIF
IF (ALLOCATED(Dvr_CaseData%Yaw)) THEN
  DEALLOCATE(Dvr_CaseData%Yaw)
ENDIF
IF (ALLOCATED(Dvr_CaseData%time)) THEN
  DEALLOCATE(Dvr_CaseData%time)
ENDIF
IF (ALLOCATED(Dvr_CaseData%DOF)) THEN
  DEALLOCATE(Dvr_CaseData%DOF)
ENDIF
IF (ALLOCATED(Dvr_CaseData%Amplitude)) THEN
  DEALLOCATE(Dvr_CaseData%Amplitude)
ENDIF
IF (ALLOCATED(Dvr_CaseData%Frequency)) THEN
  DEALLOCATE(Dvr_CaseData%Frequency)
ENDIF
 END SUBROUTINE ADM_Dvr_DestroyDvr_Case

 SUBROUTINE ADM_Dvr_PackDvr_Case( ReKiBuf, DbKiBuf, IntKiBuf, Indata, ErrStat, ErrMsg, SizeOnly )
  REAL(ReKi),       ALLOCATABLE, INTENT(  OUT) :: ReKiBuf(:)
  REAL(DbKi),       ALLOCATABLE, INTENT(  OUT) :: DbKiBuf(:)
  INTEGER(IntKi),   ALLOCATABLE, INTENT(  OUT) :: IntKiBuf(:)
  TYPE(Dvr_Case),  INTENT(IN) :: InData
  INTEGER(IntKi),   INTENT(  OUT) :: ErrStat
  CHARACTER(*),     INTENT(  OUT) :: ErrMsg
  LOGICAL,OPTIONAL, INTENT(IN   ) :: SizeOnly
    ! Local variables
  INTEGER(IntKi)                 :: Re_BufSz
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_BufSz
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_BufSz
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i,i1,i2,i3,i4,i5
  LOGICAL                        :: OnlySize ! if present and true, do not pack, just allocate buffers
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'ADM_Dvr_PackDvr_Case'
 ! buffers to store subtypes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)

  OnlySize = .FALSE.
  IF ( PRESENT(SizeOnly) ) THEN
    OnlySize = SizeOnly
  ENDIF
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_BufSz  = 0
  Db_BufSz  = 0
  Int_BufSz  = 0
  Int_BufSz   = Int_BufSz   + 1     ! WndSpeed allocated yes/no
  IF ( ALLOCATED(InData%WndSpeed) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! WndSpeed upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%WndSpeed)  ! WndSpeed
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! ShearExp allocated yes/no
  IF ( ALLOCATED(InData%ShearExp) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! ShearExp upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%ShearExp)  ! ShearExp
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! RotSpeed allocated yes/no
  IF ( ALLOCATED(InData%RotSpeed) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! RotSpeed upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%RotSpeed)  ! RotSpeed
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Pitch allocated yes/no
  IF ( ALLOCATED(InData%Pitch) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! Pitch upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Pitch)  ! Pitch
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Yaw allocated yes/no
  IF ( ALLOCATED(InData%Yaw) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! Yaw upper/lower bounds for each dimension
      Re_BufSz   = Re_BufSz   + SIZE(InData%Yaw)  ! Yaw
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! time allocated yes/no
  IF ( ALLOCATED(InData%time) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! time upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%time)  ! time
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! DOF allocated yes/no
  IF ( ALLOCATED(InData%DOF) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! DOF upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%DOF)  ! DOF
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Amplitude allocated yes/no
  IF ( ALLOCATED(InData%Amplitude) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! Amplitude upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%Amplitude)  ! Amplitude
  END IF
  Int_BufSz   = Int_BufSz   + 1     ! Frequency allocated yes/no
  IF ( ALLOCATED(InData%Frequency) ) THEN
    Int_BufSz   = Int_BufSz   + 2*1  ! Frequency upper/lower bounds for each dimension
      Db_BufSz   = Db_BufSz   + SIZE(InData%Frequency)  ! Frequency
  END IF
      Db_BufSz   = Db_BufSz   + 1  ! dT
      Int_BufSz  = Int_BufSz  + 1  ! numSteps
  IF ( Re_BufSz  .GT. 0 ) THEN 
     ALLOCATE( ReKiBuf(  Re_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating ReKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Db_BufSz  .GT. 0 ) THEN 
     ALLOCATE( DbKiBuf(  Db_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating DbKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF ( Int_BufSz  .GT. 0 ) THEN 
     ALLOCATE( IntKiBuf(  Int_BufSz  ), STAT=ErrStat2 )
     IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating IntKiBuf.', ErrStat, ErrMsg,RoutineName)
       RETURN
     END IF
  END IF
  IF(OnlySize) RETURN ! return early if only trying to allocate buffers (not pack them)

  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred = 1

  IF ( .NOT. ALLOCATED(InData%WndSpeed) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%WndSpeed,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%WndSpeed,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%WndSpeed,1), UBOUND(InData%WndSpeed,1)
        ReKiBuf(Re_Xferred) = InData%WndSpeed(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%ShearExp) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%ShearExp,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%ShearExp,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%ShearExp,1), UBOUND(InData%ShearExp,1)
        ReKiBuf(Re_Xferred) = InData%ShearExp(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%RotSpeed) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%RotSpeed,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%RotSpeed,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%RotSpeed,1), UBOUND(InData%RotSpeed,1)
        ReKiBuf(Re_Xferred) = InData%RotSpeed(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Pitch) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Pitch,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Pitch,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%Pitch,1), UBOUND(InData%Pitch,1)
        ReKiBuf(Re_Xferred) = InData%Pitch(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Yaw) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Yaw,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Yaw,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%Yaw,1), UBOUND(InData%Yaw,1)
        ReKiBuf(Re_Xferred) = InData%Yaw(i1)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%time) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%time,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%time,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%time,1), UBOUND(InData%time,1)
        DbKiBuf(Db_Xferred) = InData%time(i1)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%DOF) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%DOF,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%DOF,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%DOF,1), UBOUND(InData%DOF,1)
        DbKiBuf(Db_Xferred) = InData%DOF(i1)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Amplitude) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Amplitude,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Amplitude,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%Amplitude,1), UBOUND(InData%Amplitude,1)
        DbKiBuf(Db_Xferred) = InData%Amplitude(i1)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( .NOT. ALLOCATED(InData%Frequency) ) THEN
    IntKiBuf( Int_Xferred ) = 0
    Int_Xferred = Int_Xferred + 1
  ELSE
    IntKiBuf( Int_Xferred ) = 1
    Int_Xferred = Int_Xferred + 1
    IntKiBuf( Int_Xferred    ) = LBOUND(InData%Frequency,1)
    IntKiBuf( Int_Xferred + 1) = UBOUND(InData%Frequency,1)
    Int_Xferred = Int_Xferred + 2

      DO i1 = LBOUND(InData%Frequency,1), UBOUND(InData%Frequency,1)
        DbKiBuf(Db_Xferred) = InData%Frequency(i1)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
    DbKiBuf(Db_Xferred) = InData%dT
    Db_Xferred = Db_Xferred + 1
    IntKiBuf(Int_Xferred) = InData%numSteps
    Int_Xferred = Int_Xferred + 1
 END SUBROUTINE ADM_Dvr_PackDvr_Case

 SUBROUTINE ADM_Dvr_UnPackDvr_Case( ReKiBuf, DbKiBuf, IntKiBuf, Outdata, ErrStat, ErrMsg )
  REAL(ReKi),      ALLOCATABLE, INTENT(IN   ) :: ReKiBuf(:)
  REAL(DbKi),      ALLOCATABLE, INTENT(IN   ) :: DbKiBuf(:)
  INTEGER(IntKi),  ALLOCATABLE, INTENT(IN   ) :: IntKiBuf(:)
  TYPE(Dvr_Case), INTENT(INOUT) :: OutData
  INTEGER(IntKi),  INTENT(  OUT) :: ErrStat
  CHARACTER(*),    INTENT(  OUT) :: ErrMsg
    ! Local variables
  INTEGER(IntKi)                 :: Buf_size
  INTEGER(IntKi)                 :: Re_Xferred
  INTEGER(IntKi)                 :: Db_Xferred
  INTEGER(IntKi)                 :: Int_Xferred
  INTEGER(IntKi)                 :: i
  INTEGER(IntKi)                 :: i1, i1_l, i1_u  !  bounds (upper/lower) for an array dimension 1
  INTEGER(IntKi)                 :: ErrStat2
  CHARACTER(ErrMsgLen)           :: ErrMsg2
  CHARACTER(*), PARAMETER        :: RoutineName = 'ADM_Dvr_UnPackDvr_Case'
 ! buffers to store meshes, if any
  REAL(ReKi),      ALLOCATABLE   :: Re_Buf(:)
  REAL(DbKi),      ALLOCATABLE   :: Db_Buf(:)
  INTEGER(IntKi),  ALLOCATABLE   :: Int_Buf(:)
    !
  ErrStat = ErrID_None
  ErrMsg  = ""
  Re_Xferred  = 1
  Db_Xferred  = 1
  Int_Xferred  = 1
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! WndSpeed not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%WndSpeed)) DEALLOCATE(OutData%WndSpeed)
    ALLOCATE(OutData%WndSpeed(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%WndSpeed.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%WndSpeed,1), UBOUND(OutData%WndSpeed,1)
        OutData%WndSpeed(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! ShearExp not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%ShearExp)) DEALLOCATE(OutData%ShearExp)
    ALLOCATE(OutData%ShearExp(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%ShearExp.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%ShearExp,1), UBOUND(OutData%ShearExp,1)
        OutData%ShearExp(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! RotSpeed not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%RotSpeed)) DEALLOCATE(OutData%RotSpeed)
    ALLOCATE(OutData%RotSpeed(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%RotSpeed.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%RotSpeed,1), UBOUND(OutData%RotSpeed,1)
        OutData%RotSpeed(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Pitch not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Pitch)) DEALLOCATE(OutData%Pitch)
    ALLOCATE(OutData%Pitch(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Pitch.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%Pitch,1), UBOUND(OutData%Pitch,1)
        OutData%Pitch(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Yaw not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Yaw)) DEALLOCATE(OutData%Yaw)
    ALLOCATE(OutData%Yaw(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Yaw.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%Yaw,1), UBOUND(OutData%Yaw,1)
        OutData%Yaw(i1) = ReKiBuf(Re_Xferred)
        Re_Xferred = Re_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! time not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%time)) DEALLOCATE(OutData%time)
    ALLOCATE(OutData%time(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%time.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%time,1), UBOUND(OutData%time,1)
        OutData%time(i1) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! DOF not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%DOF)) DEALLOCATE(OutData%DOF)
    ALLOCATE(OutData%DOF(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%DOF.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%DOF,1), UBOUND(OutData%DOF,1)
        OutData%DOF(i1) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Amplitude not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Amplitude)) DEALLOCATE(OutData%Amplitude)
    ALLOCATE(OutData%Amplitude(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Amplitude.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%Amplitude,1), UBOUND(OutData%Amplitude,1)
        OutData%Amplitude(i1) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
  IF ( IntKiBuf( Int_Xferred ) == 0 ) THEN  ! Frequency not allocated
    Int_Xferred = Int_Xferred + 1
  ELSE
    Int_Xferred = Int_Xferred + 1
    i1_l = IntKiBuf( Int_Xferred    )
    i1_u = IntKiBuf( Int_Xferred + 1)
    Int_Xferred = Int_Xferred + 2
    IF (ALLOCATED(OutData%Frequency)) DEALLOCATE(OutData%Frequency)
    ALLOCATE(OutData%Frequency(i1_l:i1_u),STAT=ErrStat2)
    IF (ErrStat2 /= 0) THEN 
       CALL SetErrStat(ErrID_Fatal, 'Error allocating OutData%Frequency.', ErrStat, ErrMsg,RoutineName)
       RETURN
    END IF
      DO i1 = LBOUND(OutData%Frequency,1), UBOUND(OutData%Frequency,1)
        OutData%Frequency(i1) = DbKiBuf(Db_Xferred)
        Db_Xferred = Db_Xferred + 1
      END DO
  END IF
    OutData%dT = DbKiBuf(Db_Xferred)
    Db_Xferred = Db_Xferred + 1
    OutData%numSteps = IntKiBuf(Int_Xferred)
    Int_Xferred = Int_Xferred + 1
 END SUBROUTINE ADM_Dvr_UnPackDvr_Case

END MODULE AeroDyn_Driver_Types
!ENDOFREGISTRYGENERATEDFILE
